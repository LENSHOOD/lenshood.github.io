<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.2.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&family=Roboto+Mono:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" integrity="sha256-dABdfBfUoC8vJUBOwGVdm8L9qlMWaHTIfXt+7GnZCIo=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"lenshood.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.23.2","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js" defer></script>

    <meta name="description" content="B+ Tree 与 LSM Tree 是现今各类数据库中使用的比较多的两种数据结构，它们都可以作为数据库的文件组织形式，用于以相对高效的形式来执行数据库的读写。 本文简述了这两种数据结构的操作方式与操作开销，并对比了其自身的优缺点。">
<meta property="og:type" content="article">
<meta property="og:title" content="对比 B+ Tree 文件组织 &#x2F; LSM Tree 文件组织（第二篇：LSM Tree）">
<meta property="og:url" content="http://lenshood.github.io/2021/07/18/bpt-lsmt-2/index.html">
<meta property="og:site_name" content="Lenshood">
<meta property="og:description" content="B+ Tree 与 LSM Tree 是现今各类数据库中使用的比较多的两种数据结构，它们都可以作为数据库的文件组织形式，用于以相对高效的形式来执行数据库的读写。 本文简述了这两种数据结构的操作方式与操作开销，并对比了其自身的优缺点。">
<meta property="og:locale">
<meta property="og:image" content="http://lenshood.github.io/2021/07/18/bpt-lsmt-2/1.jpg">
<meta property="og:image" content="http://lenshood.github.io/2021/07/18/bpt-lsmt-2/2.png">
<meta property="og:image" content="http://lenshood.github.io/2021/07/18/bpt-lsmt-2/3.png">
<meta property="og:image" content="http://lenshood.github.io/2021/07/18/bpt-lsmt-2/4.png">
<meta property="og:image" content="http://lenshood.github.io/2021/07/18/bpt-lsmt-2/5.png">
<meta property="og:image" content="http://lenshood.github.io/2021/07/18/bpt-lsmt-2/6.png">
<meta property="og:image" content="http://lenshood.github.io/2021/07/18/bpt-lsmt-2/7.png">
<meta property="og:image" content="http://lenshood.github.io/2021/07/18/bpt-lsmt-2/8.png">
<meta property="og:image" content="http://lenshood.github.io/2021/07/18/bpt-lsmt-2/1.jpg">
<meta property="og:image" content="http://lenshood.github.io/2021/07/18/bpt-lsmt-2/9.png">
<meta property="og:image" content="http://lenshood.github.io/2021/07/18/bpt-lsmt-2/10.png">
<meta property="og:image" content="http://lenshood.github.io/2021/07/18/bpt-lsmt-2/11.png">
<meta property="og:image" content="http://lenshood.github.io/2021/07/18/bpt-lsmt-2/12.png">
<meta property="og:image" content="http://lenshood.github.io/2021/07/18/bpt-lsmt-2/13.png">
<meta property="og:image" content="http://lenshood.github.io/2021/07/18/bpt-lsmt-2/16.png">
<meta property="og:image" content="http://lenshood.github.io/2021/07/18/bpt-lsmt-2/17.png">
<meta property="og:image" content="http://lenshood.github.io/2021/07/18/bpt-lsmt-2/18.png">
<meta property="og:image" content="http://lenshood.github.io/2021/07/18/bpt-lsmt-2/14.png">
<meta property="og:image" content="http://lenshood.github.io/2021/07/18/bpt-lsmt-2/15.png">
<meta property="og:image" content="http://lenshood.github.io/2021/07/18/bpt-lsmt-2/19.png">
<meta property="article:published_time" content="2021-07-18T14:54:52.000Z">
<meta property="article:modified_time" content="2025-07-29T02:17:59.010Z">
<meta property="article:author" content="Lenshood">
<meta property="article:tag" content="b+ tree">
<meta property="article:tag" content="lsm tree">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://lenshood.github.io/2021/07/18/bpt-lsmt-2/1.jpg">


<link rel="canonical" href="http://lenshood.github.io/2021/07/18/bpt-lsmt-2/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh","comments":true,"permalink":"http://lenshood.github.io/2021/07/18/bpt-lsmt-2/","path":"2021/07/18/bpt-lsmt-2/","title":"对比 B+ Tree 文件组织 / LSM Tree 文件组织（第二篇：LSM Tree）"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>对比 B+ Tree 文件组织 / LSM Tree 文件组织（第二篇：LSM Tree） | Lenshood</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=PUEl-M5yzvvDvk3aBT4OetgMoLOX38OZ8nZgoLcEZp4"></script>
  <script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"PUEl-M5yzvvDvk3aBT4OetgMoLOX38OZ8nZgoLcEZp4","only_pageview":false,"measure_protocol_api_secret":null}</script>
  <script src="/js/third-party/analytics/google-analytics.js" defer></script>

  <script src="/js/third-party/analytics/baidu-analytics.js" defer></script>
  <script async src="https://hm.baidu.com/hm.js?9838df2db88eb05f5159ca8e58b5f778"></script>







  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  






  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js" defer></script>



  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><link rel="alternate" href="/atom.xml" title="Lenshood" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Lenshood</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Software Developer @ThoughtWorks</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#lsm-tree"><span class="nav-number">1.</span> <span class="nav-text">LSM-Tree</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%80%E5%88%9D%E7%9A%84-lsm-tree"><span class="nav-number">1.1.</span> <span class="nav-text">最初的 LSM-Tree</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%E9%A2%98%E4%B9%8B%E6%BA%90"><span class="nav-number">1.1.1.</span> <span class="nav-text">问题之源</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BD%92%E5%B9%B6%E6%9B%B4%E6%96%B0%E7%9A%84%E6%97%A5%E5%BF%97%E6%A0%91%E7%BB%93%E6%9E%84lsm-tree"><span class="nav-number">1.1.2.</span> <span class="nav-text">归并更新的日志树结构：LSM-Tree</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E9%98%B6two-componentslsm-tree-%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="nav-number">1.2.</span> <span class="nav-text">二阶（two
components）LSM-Tree 的操作</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8F%92%E5%85%A5"><span class="nav-number">1.2.1.</span> <span class="nav-text">插入</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9F%A5%E6%89%BE"><span class="nav-number">1.2.2.</span> <span class="nav-text">查找</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E6%9B%B4%E6%96%B0"><span class="nav-number">1.2.3.</span> <span class="nav-text">删除、更新</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#n-%E9%98%B6-lsm-tree"><span class="nav-number">1.3.</span> <span class="nav-text">n 阶 LSM-Tree</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%80%8E%E4%B9%88%E5%9C%A8%E6%88%90%E6%9C%AC%E6%9C%80%E4%BD%8E%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%E8%AE%A9-m-%E8%BE%BE%E5%88%B0%E6%9C%80%E5%A4%A7"><span class="nav-number">1.3.1.</span> <span class="nav-text">怎么在成本最低的情况下让
\(M\) 达到最大</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%89%A9%E5%B1%95%E8%87%B3-n-%E9%98%B6"><span class="nav-number">1.3.2.</span> <span class="nav-text">扩展至 n 阶</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%8E%B0%E4%BB%A3-lsm-tree-%E5%AE%9E%E7%8E%B0"><span class="nav-number">2.</span> <span class="nav-text">现代 LSM-Tree 实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%90%88%E5%B9%B6%E7%AD%96%E7%95%A5"><span class="nav-number">2.1.</span> <span class="nav-text">数据结构与合并策略</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%88%E5%B9%B6"><span class="nav-number">2.1.1.</span> <span class="nav-text">合并</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#leveling"><span class="nav-number">2.1.1.1.</span> <span class="nav-text">1. Leveling</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#tiering"><span class="nav-number">2.1.1.2.</span> <span class="nav-text">2. Tiering</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88"><span class="nav-number">2.2.</span> <span class="nav-text">优化方案</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#bloom-filter"><span class="nav-number">2.2.0.1.</span> <span class="nav-text">Bloom Filter</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#partitioning"><span class="nav-number">2.2.0.2.</span> <span class="nav-text">Partitioning</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#leveldb-%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">2.3.</span> <span class="nav-text">LevelDB 的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E6%9E%B6%E6%9E%84"><span class="nav-number">2.3.1.</span> <span class="nav-text">存储架构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#logmemtable-%E4%B8%8E-sst"><span class="nav-number">2.3.2.</span> <span class="nav-text">Log、MemTable 与 SST</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#log-file-format"><span class="nav-number">2.3.2.1.</span> <span class="nav-text">Log File Format</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#memtable"><span class="nav-number">2.3.2.2.</span> <span class="nav-text">MemTable</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#sstable"><span class="nav-number">2.3.2.3.</span> <span class="nav-text">SSTable</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%99%E5%85%A5%E6%93%8D%E4%BD%9C"><span class="nav-number">2.3.3.</span> <span class="nav-text">写入操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%BB%E5%8F%96%E6%93%8D%E4%BD%9C"><span class="nav-number">2.3.4.</span> <span class="nav-text">读取操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#compaction"><span class="nav-number">2.3.5.</span> <span class="nav-text">Compaction</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#reference"><span class="nav-number">3.</span> <span class="nav-text">Reference</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Lenshood</p>
  <div class="site-description" itemprop="description">Three Cats Man</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">91</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">104</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/LENSHOOD" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;LENSHOOD" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/atom.xml" title="RSS → atom.xml" rel="noopener me"><i class="fa fa-rss fa-fw"></i>RSS</a>
      </span>
  </div>
  <div class="cc-license animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdnjs.cloudflare.com/ajax/libs/creativecommons-vocabulary/2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh">
    <link itemprop="mainEntityOfPage" href="http://lenshood.github.io/2021/07/18/bpt-lsmt-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Lenshood">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lenshood">
      <meta itemprop="description" content="Three Cats Man">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="对比 B+ Tree 文件组织 &#x2F; LSM Tree 文件组织（第二篇：LSM Tree） | Lenshood">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          对比 B+ Tree 文件组织 / LSM Tree 文件组织（第二篇：LSM Tree）
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-07-18 22:54:52" itemprop="dateCreated datePublished" datetime="2021-07-18T22:54:52+08:00">2021-07-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2025-07-29 10:17:59" itemprop="dateModified" datetime="2025-07-29T10:17:59+08:00">2025-07-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/DB/" itemprop="url" rel="index"><span itemprop="name">DB</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><img src="/2021/07/18/bpt-lsmt-2/1.jpg" class="">
<p>B+ Tree 与 LSM Tree
是现今各类数据库中使用的比较多的两种数据结构，它们都可以作为数据库的文件组织形式，用于以相对高效的形式来执行数据库的读写。</p>
<p>本文简述了这两种数据结构的操作方式与操作开销，并对比了其自身的优缺点。</p>
<span id="more"></span>
<h2 id="lsm-tree">LSM-Tree</h2>
<p>LSM-Tree 最早是由 <em>Patrick O'Neil</em> 等人在 <a
href="https://www.cs.umb.edu/~poneil/lsmtree.pdf"><em>The Log-Structured
Merge-Tree (LSM-Tree)</em></a> 这篇论文中提出的，作者在论文中阐明：</p>
<p><em>由于传统的 B-Tree
类型的索引，其实时维护（插入、删除）开销很高。因此提出了 LSM-Tree
这种基于磁盘的数据结构，来为在较长时间内产生高速文件写入（或删除）的场景提供低成本的索引。</em></p>
<p><em>LSM-Tree
采用对写入进行延迟、批次化的算法，通过类似合并排序的高效方法，将更改以级联的方式从内存逐步推进到一个或多个磁盘组件中。</em></p>
<h3 id="最初的-lsm-tree">最初的 LSM-Tree</h3>
<h4 id="问题之源">问题之源</h4>
<p>当我们大量的采用 B-Tree
及其变体这类数据结构来存储索引、数据等的时候，我们能通过这类平衡树获得不错的读效率。从查找角度讲只需要
<code>logN</code>的时间复杂度；从存储角度讲，结合 Buffer Pool，
我们能做到通常一次查询最多只需要一次 Random
I/O。（以上内容详情可见本系列文的第一篇）</p>
<p>但为了维持这种高效读取所产生的代价就是：复杂的更新与随之带来的缓慢的更新耗时。</p>
<p>我们知道，对 B-Tree 类型的数据结构进行更新操作时，除了查找 node
所需的时间外，还可能涉及到 node 的
merge、spilt、上下层移动等操作，这些操作通常都是 Random
I/O。同时，这类更新操作都是是即时发生（in-place）的，即当场发生，当场完成，旧数据会被直接替换掉。</p>
<img src="/2021/07/18/bpt-lsmt-2/2.png" class="">
<p>但我们早就已经知道一种最常用也是最简单的数据结构：日志（Log）。它结构非常简单，实现起来也容易，最重要的，由于对
log 文件的更新全部都是追加操作，是 Sequential I/O，对 HDD
磁盘结构很友好，写入速度会很快。</p>
<p>那么，我们能不能用 log 来替代 B-Tree
呢？如下的两个问题阻挡住了我们：</p>
<ol type="1">
<li>查询效率差：由于插入的随机性，我们想要查找的数据可能会存在于 log
文件中的任何位置上</li>
<li>空间利用率差：由于所有更新操作都是直接追加至 log
末尾，被更新的数据仍旧存在于更早的 log
中，我们需要采用非即时（out-of-place）的方式来将旧数据清理掉，但这种清理存在滞后性，这导致了空间利用率变差。</li>
</ol>
<h4
id="归并更新的日志树结构lsm-tree">归并更新的日志树结构：LSM-Tree</h4>
<p>前述论文中首先假设了如下的一种数据结构（最基础的 LSM-Tree）：</p>
<img src="/2021/07/18/bpt-lsmt-2/3.png" class="">
<p>所有数据分成两个 Components 存放在 memory 和 disk 中，其中 memory
中的 Component 记为 <span class="math inline">\(C_0\)</span>，disk 中的
Component 记为 <span class="math inline">\(C_1\)</span>。<span
class="math inline">\(C_0\)</span> 相对<span
class="math inline">\(C_1\)</span>而言更小一些。</p>
<p>考虑到性能与可用性，一些常见的实践并没有在图上给出，如：</p>
<ul>
<li>仍然会通过 WAL 来进行恢复</li>
<li><span class="math inline">\(C_1\)</span> 仍然会采用 Buffer Pool
来提升读写性能</li>
</ul>
<p>上述 LSM-Tree 在有数据写入时，新增数据首先写入到 <span
class="math inline">\(C_0\)</span>，之后会在一定时间的 delay
后，合并（merge）入 <span
class="math inline">\(C_1\)</span>。而在对数据查询时，会先在 <span
class="math inline">\(C_0\)</span>中查找，找不到再去 <span
class="math inline">\(C_1\)</span>。</p>
<p>在具体的 Component 内部，其数据结构采用了树形结构来存放：</p>
<ul>
<li><span class="math inline">\(C_0\)</span> 作为存放在 memory
中的结构，不产生 I/O 消耗，不需要按 Page 或是 Batch
存取，因此采用了2-3-Tree 或 AVL-Tree 这类的平衡树。</li>
<li><span class="math inline">\(C_1\)</span> 作为存放在 disk
中的结构，仍旧采用了传统的 B-Tree 结构的变体（类似
SB-Tree），包括对顺序查询优化，单个节点可全满（100%
full），页打包为多页块（multi-page block）来提升磁盘臂效率。</li>
</ul>
<h3 id="二阶two-componentslsm-tree-的操作">二阶（two
components）LSM-Tree 的操作</h3>
<h4 id="插入">插入</h4>
<p>在整个数据结构最初的时候，并没有数据，因此刚开始的插入都只会影响
<span class="math inline">\(C_0\)</span>，而不会影响<span
class="math inline">\(C_1\)</span>。如下图所示：</p>
<img src="/2021/07/18/bpt-lsmt-2/4.png" class="">
<p>随着数据的不断增加，<span class="math inline">\(C_0\)</span>
的容量达到了阈值：</p>
<img src="/2021/07/18/bpt-lsmt-2/5.png" class="">
<p>之后会开始第一次合并，从左侧树开始，合并一部分数据至 <span
class="math inline">\(C_1\)</span>。整个合并过程采用的是逐步合并的方式，一次合并只搬移一部分数据。</p>
<img src="/2021/07/18/bpt-lsmt-2/6.png" class="">
<blockquote>
<p>上图中对整个流程进行了一些简化，实际上从 <span
class="math inline">\(C_0\)</span> 移动的数据会先进入 Buffer
Pool，最后由 Buffer Pool 选择何时写入 Disk</p>
</blockquote>
<p>在经过了一段时间后，<span class="math inline">\(C_0\)</span>
容量又一次触发阈值，需要将数据再次合并至 <span
class="math inline">\(C_1\)</span>：</p>
<img src="/2021/07/18/bpt-lsmt-2/7.png" class="">
<p>这里的关键之处在于，<span class="math inline">\(C_0\)</span>
中被选择合并的部分已经移出，但在 <span
class="math inline">\(C_1\)</span>
中，合并后的新节点，直接追加在其尾部，而最左侧被合并的部分并没有被删掉，只是做了标记（虚线）。</p>
<p>正因为新节点直接追加，因此写入速度很快，而父节点中虽然需要更新指针，但因为
Buffer Pool 的存在，除了叶节点以外，其内部节点都可以保存在 Buffer Pool
中，更新它们也就没有 I/O 消耗。</p>
<p>在整个合并流程彻底完成后，<span
class="math inline">\(C_1\)</span>最左侧的冗余数据将会被异步的删掉。</p>
<p>之后随着数据不断的插入，合并不断的进行，<span
class="math inline">\(C_1\)</span>
中被合并的部分也不断的被选取为更右侧的树枝，这一过程称为滚动合并（rolling-merge）。</p>
<h4 id="查找">查找</h4>
<p>查找操作从原理上讲就是先查找 <span
class="math inline">\(C_0\)</span>， 找不到就再查找 <span
class="math inline">\(C_1\)</span>。</p>
<p>通过观察我们能得知，最近插入的数据，其被访问的概率、频次会更高（LRU
）。正因为 <span class="math inline">\(C_0\)</span>
存放的都是相对更新、距离插入时间更近的数据，因此<span
class="math inline">\(C_0\)</span>
能够有效的提升查询效率，从这个角度看，<span
class="math inline">\(C_0\)</span> 在查询中更像是一个缓冲区。</p>
<h4 id="删除更新">删除、更新</h4>
<p>由于 LSM-Tree 这种结构，删除动作可以像插入一样高效：</p>
<img src="/2021/07/18/bpt-lsmt-2/8.png" class="">
<p>先在 <span class="math inline">\(C_0\)</span> 中查找被删除 entry
应该所在的位置，若<span class="math inline">\(C_0\)</span> 中不存在这一
entry，那么插入一个删除标记（tombstone），若存在则替换。在之后的查找中，只要发现了该标记，就可认为对应的
entry 不存在。随着合并的进行，删除标记被合并至<span
class="math inline">\(C_1\)</span>，此时如果 <span
class="math inline">\(C_1\)</span> 中的确存在该
entry，那么将其删除即可。</p>
<p>而对于 LSM-Tree
结构下的更新操作，实际上与插入操作没有本质的区别。</p>
<h3 id="n-阶-lsm-tree">n 阶 LSM-Tree</h3>
<p>由于 LSM-Tree 这种结构同时使用到了 Memory 和 Disk，即 mem 资源与 I/O
资源。那么怎么样对 LSM-Tree 进行设计和调优，才能达到理论最佳呢？</p>
<p>论文中定义了一种指标：<strong>批次合并参数 M（The Batch-Merge
Parameter M）</strong>。</p>
<p>全局上看，插入成本（insert cost）主要体现在滚动合并的过程中。因此定义
<span class="math inline">\(M\)</span> 为滚动合并中，插入到 <span
class="math inline">\(C_1\)</span> 树的每个单页叶节点中的 <span
class="math inline">\(C_0\)</span> 树的平均 entreis 数量。即：</p>
<p><span class="math inline">\(M = (S_p / S_e) \cdot
(S_0/(S_0+S_1))\)</span></p>
<p>其中，</p>
<p>$S_e = $ 单个 entry 的 size（以 byte 计）</p>
<p><span class="math inline">\(S_p=\)</span> Page size（以 byte 计）</p>
<p>$S_0 = $ <span class="math inline">\(C_0\)</span> 的 leaf level 的
size，（以 MByte 计）</p>
<p>$S_1 = $ <span class="math inline">\(C_1\)</span> 的 leaf level 的
size，（以 MByte 计）</p>
<p>所以 <span class="math inline">\((S_p / S_e)\)</span>
就是单页可存放的 entry 数量，<span
class="math inline">\((S_0/(S_0+S_1)\)</span> 是 <span
class="math inline">\(C_0\)</span> 中数据占总数据量的占比。</p>
<p>举例说明：</p>
<p>通常的实现中，<span class="math inline">\(S_1 = 40 \cdot
S_0\)</span>，<span class="math inline">\(S_p / S_e = 200\)</span>，
因此 <span class="math inline">\(M = 5\)</span>。</p>
<p>基于上述内容，我们可以知道，<span class="math inline">\(M\)</span>
越大，平均合并的 <span class="math inline">\(C_0\)</span> entry
越多，效率就越高。而假如 <span class="math inline">\(C_1\)</span> 远大于
<span class="math inline">\(C_0\)</span> 或者单个 entry
巨大导致单个页只能存放少量的几个 entries，那么就会导致 <span
class="math inline">\(M\)</span> 很小，甚至可能产生 <span
class="math inline">\(M &lt; 1\)</span> 的情况。</p>
<h4 id="怎么在成本最低的情况下让-m-达到最大">怎么在成本最低的情况下让
<span class="math inline">\(M\)</span> 达到最大</h4>
<p>前面讲到， <span class="math inline">\(C_1\)</span> 与 <span
class="math inline">\(C_1\)</span> 的大小差距越悬殊，<span
class="math inline">\(M\)</span>
会越小，所以我们就期望能在资源允许的情况下，尽可能的增大 <span
class="math inline">\(C_0\)</span>，来增大 <span
class="math inline">\(M\)</span>。</p>
<p>从成本角度看，整个 LSM-Tree 的成本包括：</p>
<ul>
<li>内存空间成本</li>
<li>磁盘 I/O 成本</li>
</ul>
<p>为了找到最小成本点，我们首先选取一个很大的 <span
class="math inline">\(C_0\)</span>，这种情况下，I/O
速率会相对较低。之后我们逐步的缩小 <span
class="math inline">\(C_0\)</span>，用昂贵的内存空间换取便宜的磁盘空间。一直到
I/O 速率达到全速状态。在这之后如果继续减少 <span
class="math inline">\(C_0\)</span> 的容量，就会导致 I/O 延迟加大。</p>
<p>实际上，即使是按照上述方式所选取出的 <span
class="math inline">\(C_0\)</span>
容量，如果在数据量稍大的场景下，也是十分庞大的，这就会导致内存投入过于昂贵。</p>
<h4 id="扩展至-n-阶">扩展至 n 阶</h4>
<p>从性能、成本的定性分析上我们知道，考虑到成本的限制，二阶的 LSM-Tree
其 <span class="math inline">\(C_0\)</span> 和 <span
class="math inline">\(C_1\)</span>
之间的容量差距还是太大了，那么一种缓解的办法就是在 <span
class="math inline">\(C_0\)</span> 和 <span
class="math inline">\(C_1\)</span> 之间插入更多的中间层。</p>
<img src="/2021/07/18/bpt-lsmt-2/1.jpg" class="">
<p>这样每一层的部分都与二阶一样，不断的向下一层合并。最终合并到最后一层。</p>
<p>此外，在论文给出的定理
3.1中证明了：每一层之间的容量比例为固定值时，整体滚动合并所产生的 I/O
速率（最小化速率等同于最小化 I/O 成本）最小。（相关证明可见论文 3.4
节）</p>
<h2 id="现代-lsm-tree-实现">现代 LSM-Tree 实现</h2>
<p><em>Patrick O'Neil</em> 等人的论文通过提出 LSM-Tree，开创性的解决了
log 结构存在的问题。但看一看如今的各种数据库中对 LSM-Tree
的实现，似乎都没有采用文中所提到的滚动合并的办法。其原因主要在于实现起来太过复杂。</p>
<p>但 LSM-Tree 本身的 memory + disk
存储的结构、以追加文件的方式提升写性能、证明层级之间保持比例一致等等概念与原则已经影响到了后续所有的
LSM-Tree 实现与改进。</p>
<h3 id="数据结构与合并策略">数据结构与合并策略</h3>
<p>从前文可知，在最初提出的 LSM-Tree 的滚动合并策略中，其 Disk Component
会不断地被更新，因此这种处理方式会增加并发控制与故障恢复的复杂度。</p>
<p>因此在现代的实现中，数据结构大都采用如下的实现：</p>
<ul>
<li>Mem Component：使用并发安全的数据结构如 skiplist、B+Tree 等</li>
<li>Disk Component：B+Tree 或 SSTable（Sorted String Table），其中
SSTable 使用的会更多
<ul>
<li>SSTable 通常包含两部分，data block 和 index block，分别用于顺序存放
k-v pair 与对 pair 进行索引</li>
<li>Disk Component
通常是不可变的，因此只可以新增或删除，不允许修改（简化并发控制）</li>
</ul></li>
</ul>
<h4 id="合并">合并</h4>
<p>正因为随着各种操作的不断实施，Component
的内容会不断增多，因此需要采用循序渐进的合并，来消除重复数据，减少数据总量。</p>
<p>前面已经讲到，为了降低并发控制和故障恢复的成本，现代的 LSM-Tree 其
disk component
都被限制为不可变，那么也就无法使用最初论文中提到的滚动合并。因此有了如下两种合并策略：</p>
<h5 id="leveling">1. Leveling</h5>
<p>leveling 策略下，与最初的 disk component
类似，每一层（level）只存在一个
component，它不可修改，只能在容量达到阈值时向下合并。</p>
<p>其中，<span class="math inline">\(Level_{L}\)</span> 的容量是 <span
class="math inline">\(Level_{L-1}\)</span> 的 <span
class="math inline">\(T\)</span> 倍，因此 <span
class="math inline">\(Level_{L}\)</span> 层的 component 将会被来自 <span
class="math inline">\(Level_{L-1}\)</span> 层的 component
合并数次，直到其容量达到 <span class="math inline">\(Level_{L}\)</span>
层的最大阈值。</p>
<img src="/2021/07/18/bpt-lsmt-2/9.png" class="">
<p>就如同上图中所示，其中 component 上的标注表示了当前 component 中存放
key 的 range。<span class="math inline">\(Level_0\)</span> 尝试向 <span
class="math inline">\(Level_1\)</span> 合并，合并后，<span
class="math inline">\(Level_1\)</span>
变大，但还未达到其阈值，因此不再向 <span
class="math inline">\(Level_2\)</span> 合并。</p>
<h5 id="tiering">2. Tiering</h5>
<p>tiering 策略下，每一层都可能存在最多 <span
class="math inline">\(T\)</span> 个 components，一旦 components
的数量达到 <span class="math inline">\(T\)</span> ，那么这 <span
class="math inline">\(T\)</span> 个 component
将会一并合入下一层。同样的，每一个 component 都不可变。</p>
<img src="/2021/07/18/bpt-lsmt-2/10.png" class="">
<p>如上图所示，<span class="math inline">\(Level_0\)</span> 的 component
数量达到了最大阈值，因此共同合并成为 <span
class="math inline">\(Level_1\)</span> 的新的一个 component。</p>
<h3 id="优化方案">优化方案</h3>
<p>通过前面的描述，我们或许会发现一些问题：</p>
<ul>
<li>即使存在 Mem Component，但对于冷数据的查询，仍然需要从 Disk
Component 中查找，对于一个 n 层的 LSM-Tree，最坏情况下要 n 次随机
IO（查找的 key 不存在时的情况也一样）</li>
<li>如果不只是用作 index
结构，而是直接作为存放数据的结构，数据量会大很多，那么在合并时就可能产生很多问题，比如反复在
memory 与 disk 之间交换数据、阻塞正常操作请求等</li>
</ul>
<p>基于以上的问题，常见的优化方案有：</p>
<h5 id="bloom-filter">Bloom Filter</h5>
<p>通过布隆过滤器，我们能够用极其少的空间消耗，来表明 key
的不存在性（可以确保不存在，但无法确保存在）。</p>
<p>其主要思想是通过 n 不同的 hash 函数计算同一个输入，得到 n
个位置点，当有查找需求时，如果待查找的 key 通过这 n 个 hash
函数后并没有得到相同的 n 个位置点，那么就能证明该 key
一定不存在与当前数据结构中，反之则不一定。</p>
<img src="/2021/07/18/bpt-lsmt-2/11.png" class="">
<p>我们知道布隆过滤器不存在假阴性（false
negative），但会存在假阳性（false
positive），对于其假阳性的概率有如下公式计算：</p>
<p><span class="math inline">\((1-e^{-kn/m})^k\)</span></p>
<p>其中，<span class="math inline">\(k\)</span> 是 hash
函数的数量，<span class="math inline">\(n\)</span> 是 key 的数量，<span
class="math inline">\(m\)</span> 是 bit-slot 的数量。</p>
<p>所以对满足最小假阳性的参数，有：</p>
<p><span class="math inline">\(k = \frac mnln2\)</span></p>
<p>在实际当中多数系统采用了 <span class="math inline">\(10\
bit/key\)</span> 的设置，那么代入公式后就能得出这种设置的假阳性率仅为 1%
。</p>
<p>由于布隆过滤器非常小的空间占用，以及高效的查询效率，他能极大地提升查询性能。</p>
<h5 id="partitioning">Partitioning</h5>
<p>前面提到了，随着层数的增加，Component
逐渐变大导致合并变得低效与缓慢。</p>
<p>分区正是这样一种优化，它讲大的 Component
分解为数个小的部分，这样一来：</p>
<ul>
<li>可以限制合并操作对空间、时间的要求。最早 LSM-Tree
实际上就通过滚动合并实现了对合并数据的限制，分区可以看做是对滚动合并的简化</li>
<li>每一个分区都可以设置特定的 key range，那么我们就可以仅对具有 key
重叠的分区进行合并，这对一些顺序插入或偏斜更新（skewed
update）的场景很有用。
<ul>
<li>由于不存在重叠，顺序插入甚至不需要合并，只要将足够大的分区向下层移动；</li>
<li>而对于偏斜更新，不涉及到更新范围的
“冷分区”，其合并的频次也非常低。</li>
</ul></li>
</ul>
<p>leveling 策略下的 partition 方案，是将单个 Component
拆分成多个固定大小的 SSTable，每一个 SSTable 都标记了自己所存储的 key
range。</p>
<img src="/2021/07/18/bpt-lsmt-2/12.png" class="">
<p>由于 <span class="math inline">\(Level_0\)</span> 的产生是由 mem
component 直接复制得到，因此比较特殊，没有分 key range，其余 <span
class="math inline">\(Level\)</span> 都按 key range 进行分区。</p>
<p>在进行合并时，选择需要合并 <span
class="math inline">\(Level_i\)</span> 的
partition（选择策略可以是任意算法，如 round robin），之后选择 <span
class="math inline">\(Level_{i+1}\)</span> 的所有被 key range 覆盖到的
partition，合并后产生 <span class="math inline">\(Level_{i+1}\)</span>
新的 SSTable。</p>
<p>对于 tiering 策略的 partitioning，可参见 <a
href="https://arxiv.org/pdf/1812.07527.pdf"><em>LSM-based Storage
Techniques: A Survey</em></a>。</p>
<h3 id="leveldb-的实现">LevelDB 的实现</h3>
<p>Google 在其 <a
href="https://static.googleusercontent.com/media/research.google.com/en//archive/bigtable-osdi06.pdf">BigTable</a>
的论文当中，描述了 BigTable 这种分布式结构化数据存储系统，其 Tablet
Server 的存储结构正式采用了 LSM-Tree
来实现。但文中并没有详细的讲述设计细节。</p>
<p>在这之后，Google 的 Sanjay Ghemawat 和 Jeff Dean
两位计算机科学家，共同编写并开源了一个单机版的 k-v 数据库
LevelDB，其设计思想与 BigTable
中所提到的存储设计十分相似。这给了外界对其 LSM-Tree
实现一窥究竟的机会。</p>
<p>LevelDB 用 C++ 编写，代码量不大，实现清晰、简洁。其 API
也十分简单：</p>
<ul>
<li><code>Put(key,value)</code></li>
<li><code>Get(key)</code></li>
<li><code>Delete(key)</code></li>
</ul>
<h4 id="存储架构">存储架构</h4>
<p>LevelDB 的整体存储架构如下图所示：</p>
<img src="/2021/07/18/bpt-lsmt-2/13.png" class="">
<p>如上图所示，整个架构中，主要由
<code>MemTable</code>、<code>ImmutableMemTable</code>、<code>TableCache</code>、<code>SSTable</code>、<code>WAL</code>、<code>FileMeta</code>
这几种组件构成。</p>
<p>通常写的动作会同时进入 <code>WAL</code> 与
<code>MemTable</code>。而后续的
<code>MemTable -&gt; ImmutableMemTable -&gt; SSTable</code>
的过程，都会在后台线程中完成。</p>
<p>读操作会在
<code>MemTable</code>、<code>ImmutableMemTable</code>、<code>TableCache</code>
中进行，其中 <code>TableCache</code>
可以看做是缓存层，当未命中时会在磁盘文件中继续查找。</p>
<p>对于 <code>SSTable</code> 的结构，单个文件最大 2MB。<span
class="math inline">\(Level_0\)</span>
由于是从内存中直接转换而来，比较特殊，默认 4
个文件，超出后就开始尝试合并（Compaction），最多不能超过 12 个文件。</p>
<p><span class="math inline">\(Level_1\)</span> 的层最大容量限制是
10MB，从 <span class="math inline">\(Level_1\)</span>
开始，每增加一层，其最大容量是上一层的 10 倍。</p>
<p>最大层数默认是 7 层。</p>
<p>根据上述我们就能简单的计算出：<span
class="math inline">\(Level_6\)</span> 的最大容量是 <span
class="math inline">\(10 * 10^5 = 1000000 MB = 1 TB\)</span>
，而所有层都达到最大的情况下，其空间利用率（数据量/实际存储量）约为
90%。</p>
<h4 id="logmemtable-与-sst">Log、MemTable 与 SST</h4>
<p>下文的所有数据结构，都包含了一个基础的数据结构：<code>Slice</code>。</p>
<p><code>Slice</code>
可以存放任何类型的数据，唯一的不同是，<code>Slice</code> 的定义：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Slice</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    ... ...</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* data_;</span><br><span class="line">    <span class="type">size_t</span> size_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可见除了数据本身以外，还包含了数据长度信息。</p>
<p>之后的数据结构中，所提到的 “数据”，都指的是 <code>Slice</code>。</p>
<h5 id="log-file-format">Log File Format</h5>
<img src="/2021/07/18/bpt-lsmt-2/16.png" class="">
<p>如上图所示，Log file 是由一个又一个 log-block 构成，每一个 block 的
size 为 32 KB （最后一个 block 除外）。</p>
<p>每个 block 都包含一个 7 byte 的 header，其中前 4 byte 存放该 block
中数据的 CRC，第 5、6 byte 存放数据长度，第 7 byte 存放数据类型。</p>
<p>其类型包括如下：</p>
<ul>
<li><code>kFullType</code>：待插入的数据长度小于当前 block
剩余空间，可以直接完整的插入</li>
<li><code>kFirstType</code>：待插入数据长度大于当前 block
剩余空间，且当前 block 放置的是待插入数据的第一部分</li>
<li><code>kMiddleType</code>：待插入数据长度大于当前 block
剩余空间，且当前 block 放置的是待插入数据的中间部分</li>
<li><code>kLastType</code>：待插入数据长度小于当前 block
剩余空间，但当前 block 放置的是待插入数据的最后一部分</li>
</ul>
<p>此外，图中的 padding，是因为若当前 block 剩余空间小于 header 的 7
bytes，则直接进行 padding。</p>
<h5 id="memtable">MemTable</h5>
<p><code>MemTable</code>
由于是内存中的数据结构，因此其对具体的空间占用要求并不严格，见如下定义：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MemTable</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">   ... ...</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    KeyComparator comparator_;</span><br><span class="line">    <span class="type">int</span> refs_;</span><br><span class="line">    Arena arena_;</span><br><span class="line">    SkipList&lt;<span class="type">const</span> <span class="type">char</span>*, KeyComparator&gt; table_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>显然，<code>MemTable</code>
实际上是用跳表来存储数据的。从插入、查找效率上讲，跳表与红黑树区别不大，但实现更简单。</p>
<p>properties：</p>
<ul>
<li><code>comparator_</code>是当前 <code>MemTable</code> 中 key
的比较器</li>
<li><code>refs_</code> 是引用计数，用于并发控制</li>
<li><code>arena_</code> 跳表实际使用的内存空间</li>
<li><code>table_</code>跳表的引用</li>
</ul>
<h5 id="sstable">SSTable</h5>
<p><code>SSTable</code> 的全称是
<code>Sorted String Table</code>，因此顾名思义，这种文件结构中存储的是有序的
Strings。</p>
<p>下图描述了 <code>SSTable</code> 的文件结构：</p>
<img src="/2021/07/18/bpt-lsmt-2/17.png" class="">
<p><code>SST</code> 的默认大小是2 MB。可以看到 <code>SST</code> 中除了
<code>Footer</code> 以外，主要存放的就是各种类型的
<code>Block</code>。<code>Block</code>
可以理解为一次磁盘操作所传输的数据量，类似于 <code>Page</code>，默认是 4
KB。</p>
<p>对于 <code>Block</code>，有如下结构：</p>
<img src="/2021/07/18/bpt-lsmt-2/18.png" class="">
<p>其结构相对简单，除了数据以外，就是 <code>type</code> 与
<code>CRC</code>，而 <code>type</code> 目前只有是/否压缩两种状态。</p>
<p>对于<code>SST</code>中的各种组成部分：</p>
<ul>
<li><p><code>DataBlock</code> 中按顺序放置了实际的数据</p></li>
<li><p><code>FilterMetaBlock</code> 中放置的是各种 filter，如最常见的
Bloom Filter，也可以放置其他用户自定义的 filter</p></li>
<li><p><code>MetaIndexBlock</code> 只有单个 block，其中放置的是各种
filter 数据的具体起始位置</p></li>
<li><p><code>IndexBlock</code> 中存放了每一个 key 的大小与位置，以
<code>BlockHandle</code> 结构来表示，其中 <code>BlockHandle</code>：</p>
<ul>
<li><div class="sourceCode" id="cb1"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>  <span class="kw">class</span> BlockHandle <span class="op">&#123;</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span><span class="op">:</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>     <span class="op">...</span> <span class="op">...</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">private</span><span class="op">:</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>      <span class="dt">uint64_t</span> <span class="va">offset_</span><span class="op">;</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>      <span class="dt">uint64_t</span> <span class="va">size_</span><span class="op">;</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>  <span class="op">&#125;</span></span></code></pre></div></li>
</ul></li>
<li><p><code>Footer</code> 中也存放了两个 <code>BlockHandle</code>
结构，分别指示了 <code>MetaIndex</code> 与 <code>Index</code> block 的
size 与在文件中的 offset 信息</p></li>
</ul>
<h4 id="写入操作">写入操作</h4>
<p>在实际写入之前，首先会判断当前写入空间是否足够，若不足则需要等待。大致的流程见下图：</p>
<img src="/2021/07/18/bpt-lsmt-2/14.png" class="">
<p>我们能看到，假如 <code>MemTable(mem)</code>
空间不足，会判断是否已经存在
<code>ImmutableMemTable(imm)</code>，如果不存在，会把当前
<code>mem</code> 转换为 <code>imm</code>，并创建一个新的
<code>mem</code> 用于本次以及后续的写入。此时会同步触发后台的
<code>Compaction</code>，因此 <code>imm</code> 主要用于延迟从 memory 到
disk 的合并，提升写入速度。</p>
<p>那么很显然，如果在 <code>MemTable(mem)</code>
空间不足的同时，<code>imm</code> 也存在，就代表当前已经有
<code>Compaction</code> 进行中，所以需要等待。</p>
<h4 id="读取操作">读取操作</h4>
<p>读取操作虽然在代码实现上内容不少（涉及到多种查找动作），但原理上相对简单：</p>
<img src="/2021/07/18/bpt-lsmt-2/15.png" class="">
<p>先在 <code>mem</code> 查找，找不到就到 <code>imm</code>
查找，再找不到就需要去 <code>SST</code> 中查找 （这里隐藏了
<code>TableCache</code> 作为缓存层的实现细节）。</p>
<h4 id="compaction">Compaction</h4>
<img src="/2021/07/18/bpt-lsmt-2/19.png" class="">
<p>Compaction 的动作，是独立的在一个后台线程中进行的，但每一次
Compact，都是由各种逻辑主动触发。</p>
<p>Compaction 线程通过一个 queue 来获取任务，而这个 “任务”，其实就是执行
Compaction 的函数指针和参数。在没有任务要执行时，后台线程处于 Wait
状态。</p>
<p>根据前文的配置限定，在某一层的总容量超出阈值时，就会从左至右依次选择一个
<code>SST</code> 准备向下合并。</p>
<p>这里的 <span class="math inline">\(Level_0\)</span> 层会与其他不同，
<span class="math inline">\(Level_0\)</span> 的数据都来自
<code>ImmutableMemTable</code>，因此会先将 <code>imm</code>
的数据生成一个 <span class="math inline">\(Level_0\)</span> 层的
<code>SST</code>，之后由于已经落盘，之前 WAL 中与 <code>imm</code>
有关的 log 不再需要了，因此将之删除。在执行完成 <span
class="math inline">\(Level_0\)</span> 的 Compaction
后，后台线程会再发送一个触发 Compaction 的任务回到任务队列。</p>
<p>假如 Compaction 发现不存在 <code>imm</code> 则正常进行其他 <span
class="math inline">\(Level\)</span> 的合并工作：</p>
<ol type="1">
<li>寻找合适的 <span class="math inline">\(Level\)</span>
，寻找标准就是总容量是否超出阈值</li>
<li>按顺序（round robin）选取待合并 <span
class="math inline">\(Level_n\)</span> 的一个 <code>SST</code>，同时根据
overlap 的情况选取 <span class="math inline">\(Level_{n+1}\)</span>
中的数个文件，准备进行合并</li>
<li>若不存在 overlap，那么就可以简单的将这个 <code>SST</code>
挪到下一层即可完成，这种情况称作 <code>TrivialMove</code></li>
<li>否则，将 <code>SST</code> 中的数据根据 range 的实际情况，与<span
class="math inline">\(Level_{n+1}\)</span> 中的 <code>SST</code>
进行合并即可，过程中可能涉及到创建新的 <code>SST</code></li>
<li>最后删除无用的文件，完成 Compaction</li>
</ol>
<h2 id="reference">Reference</h2>
<ol type="1">
<li><a href="https://www.cs.umb.edu/~poneil/lsmtree.pdf"><em>The
Log-Structured Merge-Tree (LSM-Tree)</em></a></li>
<li><a href="https://arxiv.org/pdf/1812.07527.pdf"><em>LSM-based Storage
Techniques: A Survey</em></a></li>
<li><a href="https://github.com/google/leveldb">LevelDB Source</a></li>
</ol>

    </div>

    
    
    

    <footer class="post-footer">
          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>Post author:  </strong>Lenshood
  </li>
  <li class="post-copyright-link">
      <strong>Post link: </strong>
      <a href="http://lenshood.github.io/2021/07/18/bpt-lsmt-2/" title="对比 B+ Tree 文件组织 &#x2F; LSM Tree 文件组织（第二篇：LSM Tree）">http://lenshood.github.io/2021/07/18/bpt-lsmt-2/</a>
  </li>
  <li class="post-copyright-license">
      <strong>Copyright Notice:  </strong>All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> unless stating additionally.
  </li>
</ul>
</div>

          <div class="followme">
  <span>Welcome to my other publishing channels</span>

  <div class="social-list">

      <div class="social-item">
          <a target="_blank" class="social-link" href="/atom.xml">
            <span class="icon">
              <i class="fa fa-rss"></i>
            </span>

            <span class="label">RSS</span>
          </a>
      </div>
  </div>
</div>

          <div class="post-tags">
              <a href="/tags/b-tree/" rel="tag"># b+ tree</a>
              <a href="/tags/lsm-tree/" rel="tag"># lsm tree</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2021/07/05/bpt-lsmt/" rel="prev" title="对比 B+ Tree 文件组织 &#x2F; LSM Tree 文件组织（第一篇：B+ Tree）">
                  <i class="fa fa-angle-left"></i> 对比 B+ Tree 文件组织 / LSM Tree 文件组织（第一篇：B+ Tree）
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2021/09/13/raft-paper/" rel="next" title="（译文）一种易于理解的共识算法的研究（In Search of an Understandable Consensus Algorithm）">
                  （译文）一种易于理解的共识算法的研究（In Search of an Understandable Consensus Algorithm） <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments utterances-container"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Lenshood</span>
  </div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>
<script class="next-config" data-name="utterances" type="application/json">{"enable":true,"repo":"LENSHOOD/lenshood.github.io","issue_term":"pathname","theme":"github-light"}</script>
<script src="/js/third-party/comments/utterances.js" defer></script>

</body>
</html>
