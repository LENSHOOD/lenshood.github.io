<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.2.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&family=Roboto+Mono:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" integrity="sha256-dABdfBfUoC8vJUBOwGVdm8L9qlMWaHTIfXt+7GnZCIo=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"lenshood.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.23.2","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js" defer></script>

    <meta name="description" content="本节课程主要学习的是 TiDB 的 事务原理。由于 TiDB 的分布式部署的特性，其事务的实现主要借鉴了 Percolator 中分布式事务的实现方式，将 TiDB 与 TiKV 结合起来，共同完成分布式事务的任务。  本文中涉及到的图片来源，都来自 PingCAP 官方网站。">
<meta property="og:type" content="article">
<meta property="og:title" content="TiDB 学习课程 Lesson-7">
<meta property="og:url" content="http://lenshood.github.io/2020/10/12/tidb-lesson-7/index.html">
<meta property="og:site_name" content="Lenshood">
<meta property="og:description" content="本节课程主要学习的是 TiDB 的 事务原理。由于 TiDB 的分布式部署的特性，其事务的实现主要借鉴了 Percolator 中分布式事务的实现方式，将 TiDB 与 TiKV 结合起来，共同完成分布式事务的任务。  本文中涉及到的图片来源，都来自 PingCAP 官方网站。">
<meta property="og:locale">
<meta property="og:image" content="http://lenshood.github.io/2020/10/12/tidb-lesson-7/optimize-txn.png">
<meta property="article:published_time" content="2020-10-12T14:26:46.000Z">
<meta property="article:modified_time" content="2025-07-29T02:17:59.459Z">
<meta property="article:author" content="Lenshood">
<meta property="article:tag" content="tidb">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://lenshood.github.io/2020/10/12/tidb-lesson-7/optimize-txn.png">


<link rel="canonical" href="http://lenshood.github.io/2020/10/12/tidb-lesson-7/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh","comments":true,"permalink":"http://lenshood.github.io/2020/10/12/tidb-lesson-7/","path":"2020/10/12/tidb-lesson-7/","title":"TiDB 学习课程 Lesson-7"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>TiDB 学习课程 Lesson-7 | Lenshood</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=PUEl-M5yzvvDvk3aBT4OetgMoLOX38OZ8nZgoLcEZp4"></script>
  <script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"PUEl-M5yzvvDvk3aBT4OetgMoLOX38OZ8nZgoLcEZp4","only_pageview":false,"measure_protocol_api_secret":null}</script>
  <script src="/js/third-party/analytics/google-analytics.js" defer></script>

  <script src="/js/third-party/analytics/baidu-analytics.js" defer></script>
  <script async src="https://hm.baidu.com/hm.js?9838df2db88eb05f5159ca8e58b5f778"></script>







  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  






  




  

  <script class="next-config" data-name="enableMath" type="application/json">false</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js" defer></script>



  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><link rel="alternate" href="/atom.xml" title="Lenshood" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Lenshood</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Software Developer @ThoughtWorks</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#tidb-%E4%BA%8B%E5%8A%A1"><span class="nav-number">1.</span> <span class="nav-text">TiDB 事务</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#kv-pair-%E4%B9%8B%E9%97%B4%E7%9A%84%E4%BA%8B%E5%8A%A1"><span class="nav-number">1.1.</span> <span class="nav-text">kv pair 之间的事务</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#percolator-%E4%BA%8B%E5%8A%A1"><span class="nav-number">1.2.</span> <span class="nav-text">Percolator 事务</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%99%E6%93%8D%E4%BD%9C"><span class="nav-number">1.2.1.</span> <span class="nav-text">写操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%BB%E6%93%8D%E4%BD%9C"><span class="nav-number">1.2.2.</span> <span class="nav-text">读操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%84%E7%90%86%E5%86%B2%E7%AA%81"><span class="nav-number">1.2.3.</span> <span class="nav-text">处理冲突</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%85%E9%9A%9C%E5%AE%B9%E9%94%99"><span class="nav-number">1.2.4.</span> <span class="nav-text">故障容错</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B9%90%E8%A7%82%E4%BA%8B%E5%8A%A1%E5%AE%9E%E7%8E%B0"><span class="nav-number">2.</span> <span class="nav-text">乐观事务实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%80%E5%90%AF%E6%96%B0%E4%BA%8B%E5%8A%A1"><span class="nav-number">2.1.</span> <span class="nav-text">开启新事务</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1%E5%86%85%E8%AF%BB%E5%86%99"><span class="nav-number">2.2.</span> <span class="nav-text">事务内读写</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%BB"><span class="nav-number">2.2.1.</span> <span class="nav-text">读</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%99"><span class="nav-number">2.2.2.</span> <span class="nav-text">写</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8F%90%E4%BA%A4%E4%BA%8B%E5%8A%A1"><span class="nav-number">2.3.</span> <span class="nav-text">提交事务</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#prewrite"><span class="nav-number">2.3.1.</span> <span class="nav-text">Prewrite</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#commit"><span class="nav-number">2.3.2.</span> <span class="nav-text">Commit</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%82%B2%E8%A7%82%E4%BA%8B%E5%8A%A1%E5%AE%9E%E7%8E%B0"><span class="nav-number">3.</span> <span class="nav-text">悲观事务实现</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Lenshood</p>
  <div class="site-description" itemprop="description">Three Cats Man</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">91</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">104</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/LENSHOOD" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;LENSHOOD" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/atom.xml" title="RSS → atom.xml" rel="noopener me"><i class="fa fa-rss fa-fw"></i>RSS</a>
      </span>
  </div>
  <div class="cc-license animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdnjs.cloudflare.com/ajax/libs/creativecommons-vocabulary/2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh">
    <link itemprop="mainEntityOfPage" href="http://lenshood.github.io/2020/10/12/tidb-lesson-7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Lenshood">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lenshood">
      <meta itemprop="description" content="Three Cats Man">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="TiDB 学习课程 Lesson-7 | Lenshood">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          TiDB 学习课程 Lesson-7
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-10-12 22:26:46" itemprop="dateCreated datePublished" datetime="2020-10-12T22:26:46+08:00">2020-10-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2025-07-29 10:17:59" itemprop="dateModified" datetime="2025-07-29T10:17:59+08:00">2025-07-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/TiDB/" itemprop="url" rel="index"><span itemprop="name">TiDB</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><p>本节课程主要学习的是 TiDB 的 事务原理。由于 TiDB
的分布式部署的特性，其事务的实现主要借鉴了 <a
href="https://storage.googleapis.com/pub-tools-public-publication-data/pdf/36726.pdf">Percolator</a>
中分布式事务的实现方式，将 TiDB 与 TiKV
结合起来，共同完成分布式事务的任务。</p>
<blockquote>
<p>本文中涉及到的图片来源，都来自 PingCAP 官方网站。</p>
</blockquote>
<span id="more"></span>
<h2 id="tidb-事务">TiDB 事务</h2>
<p>我们已经知道，TiKV 基于 k-v 实现了数据的存储，MVCC 层暴露了带版本的
k-v 的操作。而在 MVCC 层以下对每一个 kv pair 的一致性复制，采用 raft
实现。</p>
<p>所以，当一组操作涉及到了对多个 kv pair
的读写时，就需要采用事务来确保这组操作的完整性。另外需要注意的是，被操作数据很有可能分布在多个
TiKV
节点上，那么就要求事务是分布式事务，能够确保跨节点操作的一致性。</p>
<h3 id="kv-pair-之间的事务">kv pair 之间的事务</h3>
<p>设想假如只有单个 TiKV
节点，一组操作中涉及到的所有数据都限定在单节点中，那么事物的实现就可以简化对每一个涉及到的
kv pair 进行加锁，处理完之后，在提交时统一解锁就可以了。</p>
<p>扩展到分布式事务场景下，实际上我们也可以照搬加锁后提交的逻辑过程，只是在分布的节点中可能遇到许多不可控的因素来打破我们提交流程：</p>
<ul>
<li>由于网络通信的原因，导致一部分 key 提交成功，一部分 key
没收到提交请求</li>
<li>由于不满足约束条件，导致满足约束的节点提交成功，而不满足约束条件的节点提交失败</li>
<li>由于节点故障，某个节点失去响应，导致涉及到该节点的数据提交失败</li>
</ul>
<p>一旦发生上述情况，就会导致事务内的数据出现了部分提交，破坏了一致性。</p>
<p>由于我们无法确保上述现象一定不会发生，那么就只能加固提交的过程来规避这些问题。</p>
<p>既然部分 key 有可能因为种种原因无法成功提交，那么不如这样：</p>
<ol type="1">
<li>大家都先不要提交，而是增加一个准备阶段，发起者向每个节点发送准备请求，要求节点准备好要提交的数据，并等待发号施令</li>
<li>所有节点准备好数据后，都回复发起者说，我这里一切就绪了。假如在这一阶段发生了上述的问题，那么因为所有数据都还没有被提交，因此就不会破坏一致性</li>
<li>发起者汇总了大家都准备好的信息后，一声令下，全都提交，这时所有节点都在收到命令后开始提交流程。</li>
</ol>
<p>假如在提交阶段发生了上述问题，那么相应的节点会尽最大努力尝试提交。例如某节点在准备完成后，一直没有收到提交命令，此时他可能会采取继续等待，或与其他节点沟通等等策略。而由于不论是发起者发送请求之前，还是节点接收到请求之后，都会先记录日志（WAF），因此假如在提交过程中宕机，恢复后可以继续执行原来的操作。</p>
<p>以上的事务提交方式就是常见的 2PC 即两阶段提交。</p>
<h3 id="percolator-事务">Percolator 事务</h3>
<p>前面讲到了在处理跨 key 之间事务一致性时使用的 2PC 事务实现方式。在
Google 的 Percolator 中，也遇到了同样的问题，并且他们正是采用了 2PC
来实现事务。这一节会介绍 Percolator 的 2PC 实现。</p>
<p>Percolator 是 Google
构建的一个专门用于对巨大的数据集进行增量更新的系统，Google
用它来更新其搜索引擎索引。Google 的搜索引擎索引数据有数十 PB
的数据，他们存放在 BigTable 上。BigTable
作为能提供单行事务的表存储系统，无法满足多行修改的事务一致性，Percolator
以如下的方式，实现了基于 BigTable 的多行事务，它保证事务之间能提供 SI
的隔离级别（以下内容整理自 <a
href="https://tikv.org/deep-dive/distributed-transaction/percolator/">DeepDive
TiKV 对 Percolator 的讲解</a>）：</p>
<ol type="1">
<li>Percolator 的每一个逻辑列，都映射到 BigTable 上的五个物理列：
<ul>
<li>lock：锁记录，用于指示当前版本数据是否上锁，无论版本，一行数据至多只能存在一个锁</li>
<li>write：用于引用一条已经成功被事务写入的数据</li>
<li>data：实际数据，以多版本存储，形式类似 <code>v:data</code></li>
<li>notify：用于表明改行已经被修改，也可以作为用户自定义的 observer
的触发器，触发进行定制化的操作</li>
<li>ack_0：用于保存 observer
最后一次操作的时间戳，防止一次数据变动被错误的 notify 两次</li>
</ul></li>
<li>通过一个全局时钟服务 TSO（Timestamp
Oracle）来提供单调递增的时钟。所有读写之前都需要通过 TSO
获取最新的时间戳。</li>
</ol>
<p>假如我们暂时不考虑 <code>notify</code> 和 <code>ack_0</code>
列（由于分布式事务的逻辑部分与对 observer 的触发关系不大），那么
Percolator 中的某一条数据可以被展示为如下的结构：</p>
<table>
<thead>
<tr class="header">
<th>key</th>
<th>v:data</th>
<th>v:lock</th>
<th>v:write</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>k1</td>
<td>14:“value2"</td>
<td>14:primary</td>
<td>14:</td>
</tr>
<tr class="even">
<td></td>
<td>12:</td>
<td>12:</td>
<td>12:data@10</td>
</tr>
<tr class="odd">
<td></td>
<td>10:“value1”</td>
<td>10:</td>
<td>10:</td>
</tr>
</tbody>
</table>
<p>我们发现，对于 <code>k1</code> 这一行数据，从 <code>v:data</code>
来看，时间戳版本为 10 的数据是 “value1”，并且结合<code>v:write</code> 在
<code>12: data@10</code> 来看，时间戳版本为 10
的数据已经被提交，其提交记录就是
<code>12: data@10</code>。那么同样的，我们也可以得知，<code>14: “value2"</code>
这条数据是最新且未提交的数据，因为还没有任何一个 <code>v:write</code>
引用向它，且在<code>v:lock</code> 列存在一个锁。</p>
<h4 id="写操作">写操作</h4>
<p>由于 Percolator 也采用 2PC
来进行事务操作，因此事务写的动作一样被分为两个阶段：Prewrite 和
Commit。</p>
<p>在 Prewrite 阶段：</p>
<ol type="1">
<li>从 TSO
获取最新的时间戳，作为事务开始的时间点：<code>start_ts</code>。</li>
<li>将事务涉及到的每一行数据以 <code>start_ts</code>
作为版本号写入对应列中，同时在<code>v:lock</code>
列写入一个锁。其中，任选一行数据作为主行（primary），其锁的内容为
<code>start_ts: primary</code>，而其余行作为附属行（secondary），其锁内容为<code>start_ts: primary@primary_key</code>。</li>
<li>假如在这一阶段中发现任意行存在比 <code>start_ts</code>
还要新的行或该行已经上锁，则准备失败，当前事务回滚（显然是一个乐观的事务机制）。</li>
</ol>
<p>在 Commit 阶段：</p>
<ol type="1">
<li>在 TSO
获取新的时间戳，作为事务提交的时间点：<code>commit_ts</code>。</li>
<li>移除 primary 锁的同时在 <code>v:write</code>
列中写入一条数据：<code>commit_ts: data@start_ts</code> （BigTable
单行事务），假如此时 primary 锁并不存在，则提交失败。</li>
<li>对其他的附属行也执行类似 2 的动作。实际上只要 2 执行成功，Percolator
就认为整个事务已经成功提交，其附属行的操作可以异步化以提升性能（在后面读的过程中采用额外的逻辑来保证事务数据的一致性，详见下文）</li>
</ol>
<p>举例说明，假设我们在一个事务内修改两条记录，这两条记录的初始状态如下：</p>
<table>
<thead>
<tr class="header">
<th>key</th>
<th>bal:data</th>
<th>bal:lock</th>
<th>bal:write</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Bob</td>
<td>6:</td>
<td>6:</td>
<td>6:data@5</td>
</tr>
<tr class="even">
<td></td>
<td>5:$10</td>
<td>5:</td>
<td>5:</td>
</tr>
<tr class="odd">
<td>Joe</td>
<td>6:</td>
<td>6:</td>
<td>6:data@5</td>
</tr>
<tr class="even">
<td></td>
<td>5:$2</td>
<td>5:</td>
<td>5:</td>
</tr>
</tbody>
</table>
<p>现在 Bob 想要给 Joe 转 $7，那么在 Prewrite 成功后的状态如下：</p>
<table>
<thead>
<tr class="header">
<th>key</th>
<th>bal:data</th>
<th>bal:lock</th>
<th>bal:write</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Bob</td>
<td>7:$3</td>
<td>7:primary</td>
<td>7:</td>
</tr>
<tr class="even">
<td></td>
<td>6:</td>
<td>6:</td>
<td>6:data@5</td>
</tr>
<tr class="odd">
<td></td>
<td>5:$10</td>
<td>5:</td>
<td>5:</td>
</tr>
<tr class="even">
<td>Joe</td>
<td>7:$9</td>
<td>7:primay@Bob.bal</td>
<td>7:</td>
</tr>
<tr class="odd">
<td></td>
<td>6:</td>
<td>6:</td>
<td>6:data@5</td>
</tr>
<tr class="even">
<td></td>
<td>5:$2</td>
<td>5:</td>
<td>5:</td>
</tr>
</tbody>
</table>
<p>而当 Commit primary 成功后，状态如下，此时事务已经成功提交：</p>
<table>
<thead>
<tr class="header">
<th>key</th>
<th>bal:data</th>
<th>bal:lock</th>
<th>bal:write</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Bob</td>
<td>8:</td>
<td>8:</td>
<td>8:data@7</td>
</tr>
<tr class="even">
<td></td>
<td>7:$3</td>
<td>7:</td>
<td>7:</td>
</tr>
<tr class="odd">
<td></td>
<td>6:</td>
<td>6:</td>
<td>6:data@5</td>
</tr>
<tr class="even">
<td></td>
<td>5:$10</td>
<td>5:</td>
<td>5:</td>
</tr>
<tr class="odd">
<td>Joe</td>
<td>7:$9</td>
<td>7:primay@Bob.bal</td>
<td>7:</td>
</tr>
<tr class="even">
<td></td>
<td>6:</td>
<td>6:</td>
<td>6:data@5</td>
</tr>
<tr class="odd">
<td></td>
<td>5:$2</td>
<td>5:</td>
<td>5:</td>
</tr>
</tbody>
</table>
<p>最后，附属列异步执行完成后：</p>
<table>
<thead>
<tr class="header">
<th>key</th>
<th>bal:data</th>
<th>bal:lock</th>
<th>bal:write</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Bob</td>
<td>8:</td>
<td>8:</td>
<td>8:data@7</td>
</tr>
<tr class="even">
<td></td>
<td>7:$3</td>
<td>7:</td>
<td>7:</td>
</tr>
<tr class="odd">
<td></td>
<td>6:</td>
<td>6:</td>
<td>6:data@5</td>
</tr>
<tr class="even">
<td></td>
<td>5:$10</td>
<td>5:</td>
<td>5:</td>
</tr>
<tr class="odd">
<td>Joe</td>
<td>8:</td>
<td>8:</td>
<td>8:data@7</td>
</tr>
<tr class="even">
<td></td>
<td>7:$9</td>
<td>7:</td>
<td>7:</td>
</tr>
<tr class="odd">
<td></td>
<td>6:</td>
<td>6:</td>
<td>6:data@5</td>
</tr>
<tr class="even">
<td></td>
<td>5:$2</td>
<td>5:</td>
<td>5:</td>
</tr>
</tbody>
</table>
<h4 id="读操作">读操作</h4>
<p>读操作的执行过程比较简单：</p>
<ol type="1">
<li>从 TSO 获取时间戳 <code>ts</code>。</li>
<li>判断在 <code>[0, ts]</code> 之间的记录中是否存在锁
<ul>
<li>假如存在锁，代表当前存在一个比 <code>ts</code>
更早的写事务正在这一行中执行。我们并不清楚这个事务到底会在
<code>ts</code> 之前还是之后提交，因此本次读操作会终止并重试。</li>
<li>假如不存在锁，或锁的版本高于
<code>ts</code>，则可以继续进行读操作。</li>
</ul></li>
<li>从 <code>write</code> 列选取 <code>commit_ts</code> 处于
<code>[0, ts]</code>范围内最近的记录，该记录中保存了对应事务的
<code>start_ts</code>。</li>
<li>根据 <code>write</code> 列中取出的 <code>start_ts</code>
找到<code>data</code>列中对应的记录，取出数据。</li>
</ol>
<p>仍旧延续上述转账的例子，假设我们想要在如下状态中读取 Bob 的余额：</p>
<table>
<thead>
<tr class="header">
<th>key</th>
<th>bal:data</th>
<th>bal:lock</th>
<th>bal:write</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Bob</td>
<td>8:</td>
<td>8:</td>
<td>8:data@7</td>
</tr>
<tr class="even">
<td></td>
<td>7:$3</td>
<td>7:</td>
<td>7:</td>
</tr>
<tr class="odd">
<td></td>
<td>6:</td>
<td>6:</td>
<td>6:data@5</td>
</tr>
<tr class="even">
<td></td>
<td>5:$10</td>
<td>5:</td>
<td>5:</td>
</tr>
<tr class="odd">
<td>Joe</td>
<td>7:$9</td>
<td>7:primay@Bob.bal</td>
<td>7:</td>
</tr>
<tr class="even">
<td></td>
<td>6:</td>
<td>6:</td>
<td>6:data@5</td>
</tr>
<tr class="odd">
<td></td>
<td>5:$2</td>
<td>5:</td>
<td>5:</td>
</tr>
</tbody>
</table>
<ol type="1">
<li>获取当前时间戳，假设是 <code>9</code>。</li>
<li>显然，Bob 的记录中不存在锁，继续读取。</li>
<li><code>[0, 9]</code> 中最大的 <code>write</code> 记录为
<code>8:data@7</code>，即
<code>commit_ts = 8, start_ts = 7</code>。</li>
<li>根据 <code>start_ts = 7</code> 取得时间戳为 <code>7</code>
的数据：<code>$3</code>。</li>
</ol>
<p>这种读取方法同时提供了无锁读和历史读。在上述例子中，假如我们想要读取
<code>[0, 8]</code> 之间的 Bob 余额，最终就会得到 <code>$10</code>。</p>
<h4 id="处理冲突">处理冲突</h4>
<p>通过检查 <code>lock</code>
列来判断冲突。一行数据可以拥有多个版本，但至多只能拥有一个锁。当我们执行一个写操作时，我们会在
Prewrite
阶段给所有涉及到的行加锁。假如其中小部分行加锁失败，整个事务都会被回滚。使用这种乐观事务算法，有时
Percolator 的事务写入性能会在冲突频繁的场景下发生退化。</p>
<p>当需要回滚时，我们只需要删除锁和对应版本的数据即可。</p>
<h4 id="故障容错">故障容错</h4>
<p>Percolator
能够在不破坏数据完整性的情况下从故障中恢复，也正因为如此，对于附属列的写操作可以放心的异步执行。</p>
<p>系统可能会在 Prewrite、Commit
或二者之间发生故障。我们可以简单的将这些故障分为两种：Commit 前故障和
Commit 后故障。</p>
<p>假设当前有一个事务 <code>T1</code>
（读或写事务均可）在执行过程中发现在其期望读取的行 <code>R1</code>
中存在一个比 <code>T1</code> 更早的事务 <code>T0</code> 留下的锁。此时
<code>T1</code> 不会立即回滚，而是先检查 <code>T0</code> 的 primary lock
的情况：</p>
<ul>
<li>假如 primary lock 已经不存在，并且在对应记录的 <code>write</code>
列上发现有一条 <code>data @ T0.start_ts</code> 的记录。那么显然
<code>T0</code> 已经成功提交，<code>R1</code> 作为 <code>T0</code>
的附属列，其遗留的锁可以被一并提交。在提交后，<code>T1</code>
就能继续执行，这种操作称之为 <code>rolling forward</code>。</li>
<li>假如 primary lock 已经不存在，并且没发现其他的更新，这证明
<code>T0</code> 已经被回滚。那么 <code>R1</code>
上遗留的锁也应该被一并回滚。在回滚后，<code>T1</code> 仍可继续。</li>
<li>假如 primary lock
存在，但却太旧了（可以设定一个阈值来判断是否过旧），这说明
<code>T0</code> 在其提交或回滚之前系统就崩溃了。这时将 <code>T1</code>
回滚，驱使 <code>T0</code> 继续。</li>
<li>除以上之外的情况，我们都认为 <code>T0</code> 还在进行中。那么
<code>T1</code> 既可以回滚，也可以等待一会儿后重试并检查<code>T0</code>
是否会在 <code>T1.start_ts</code> 之前提交（如果在之后提交，则
<code>T1</code> 读不到最新数据，必须回滚）。</li>
</ul>
<h2 id="乐观事务实现">乐观事务实现</h2>
<p>TiDB 的乐观事务基本上是基于 Percolator
的事务模型来实现的，其基本原理完全一致，在具体的实现细节上做了许多优化。</p>
<p>总体上可以由下图来描绘 TiDB 中执行一次完整的乐观事务的过程（<a
href="https://pingcap.com/blog-cn/best-practice-optimistic-transaction/">图源</a>）：</p>
<img src="/2020/10/12/tidb-lesson-7/optimize-txn.png" class="">
<p>从上图所见，一个完整个 TiDB 事务，需要涉及到 TiDB PD TiKV
三部分，其中，TiDB 一端与 client 交互，进行开启、提交事务；一端与 PD
交互，获得时间戳与数据所在 region 信息；一端与 TiKV 交互，执行 2PC。</p>
<p>在 TiDB 中，对事务的的定义是
<code>kv.Transaction</code>，而由于事务操作都从 <code>session</code>
中发起，因此还定义了 <code>session.Txn()</code> 来从
<code>session</code> 中获取当前的事务。</p>
<p>如下代码片段以 <code>tables.Table.AddRecord()</code>
为例来展示在一次插入记录操作中，如何使用事务：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *TableCommon)</span></span> AddRecord(sctx sessionctx.Context, r []types.Datum, opts ...table.AddRecordOption) (recordID kv.Handle, err <span class="type">error</span>) &#123;</span><br><span class="line">  <span class="comment">// 获取当前 Txn （初始化 Txn 时已经放入了获取 start_ts 的 TSO future，会在如下方法首次调用时获取 future）</span></span><br><span class="line">  txn, err := sctx.Txn(<span class="literal">true</span>)</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// 启用 MemBuffer，在提交之前所有的改动都会暂存在其内</span></span><br><span class="line">  memBuffer := txn.GetMemBuffer()</span><br><span class="line">	sh := memBuffer.Staging()</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// 构造 key</span></span><br><span class="line">  key := t.RecordKey(recordID)</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// 获取 value</span></span><br><span class="line">  writeBufs.RowValBuf, err = tablecodec.EncodeRow(sc, row, colIDs, writeBufs.RowValBuf, writeBufs.AddRowValues, rd)</span><br><span class="line">  value := writeBufs.RowValBuf</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// 暂存</span></span><br><span class="line">  err = memBuffer.Set(key, value)</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// 在 MemBuffer 中发布</span></span><br><span class="line">  memBuffer.Release(sh)</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 外层逻辑：tidb.finishStmt()</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">finishStmt</span><span class="params">(ctx context.Context, se *session, meetsErr <span class="type">error</span>, sql sqlexec.Statement)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">	...</span><br><span class="line">  <span class="keyword">if</span> se.txn.Valid() &#123;</span><br><span class="line">			<span class="keyword">if</span> meetsErr != <span class="literal">nil</span> &#123;</span><br><span class="line">				se.StmtRollback()</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				se.StmtCommit()</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">  ...</span><br><span class="line">  err := autoCommitAfterStmt(ctx, se, meetsErr, sql)</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">autoCommitAfterStmt</span><span class="params">(ctx context.Context, se *session, meetsErr <span class="type">error</span>, sql sqlexec.Statement)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span> meetsErr != <span class="literal">nil</span> &#123;</span><br><span class="line">  	...</span><br><span class="line">    se.RollbackTxn(ctx)</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span> err := se.CommitTxn(ctx); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="开启新事务">开启新事务</h3>
<p>在 <code>session.NewTxn()</code> 中，session 通过配置的 store
来开启一个事务：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">txn, err := s.store.BeginWithTxnScope(s.sessionVars.CheckAndGetTxnScope())</span><br></pre></td></tr></table></figure>
<p>我们来看看 store 是如何开启事务的（以下都以
<code>tikvStore</code>为例 ）：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newTiKVTxn</span><span class="params">(store *tikvStore, txnScope <span class="type">string</span>)</span></span> (*tikvTxn, <span class="type">error</span>) &#123;</span><br><span class="line">	bo := NewBackofferWithVars(context.Background(), tsoMaxBackoff, <span class="literal">nil</span>)</span><br><span class="line">	startTS, err := store.getTimestampWithRetry(bo, txnScope)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, errors.Trace(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> newTiKVTxnWithStartTS(store, txnScope, startTS, store.nextReplicaReadSeed())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *tikvStore)</span></span> getTimestampWithRetry(bo *Backoffer, txnScope <span class="type">string</span>) (<span class="type">uint64</span>, <span class="type">error</span>) &#123;</span><br><span class="line">  ...</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		startTS, err := s.oracle.GetTimestamp(bo.ctx, &amp;oracle.Option&#123;TxnScope: txnScope&#125;)</span><br><span class="line">		...</span><br><span class="line">		<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> startTS, <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">		err = bo.Backoff(BoPDRPC, errors.Errorf(<span class="string">&quot;get timestamp failed: %v&quot;</span>, err))</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>, errors.Trace(err)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newTiKVTxnWithStartTS</span><span class="params">(store *tikvStore, txnScope <span class="type">string</span>, startTS <span class="type">uint64</span>, replicaReadSeed <span class="type">uint32</span>)</span></span> (*tikvTxn, <span class="type">error</span>) &#123;</span><br><span class="line">	ver := kv.NewVersion(startTS)</span><br><span class="line">	snapshot := newTiKVSnapshot(store, ver, replicaReadSeed)</span><br><span class="line">	newTiKVTxn := &amp;tikvTxn&#123;</span><br><span class="line">		snapshot:  snapshot,</span><br><span class="line">		us:        kv.NewUnionStore(snapshot),</span><br><span class="line">		store:     store,</span><br><span class="line">		startTS:   startTS,</span><br><span class="line">		startTime: time.Now(),</span><br><span class="line">		valid:     <span class="literal">true</span>,</span><br><span class="line">		vars:      kv.DefaultVars,</span><br><span class="line">	&#125;</span><br><span class="line">	newTiKVTxn.SetOption(kv.TxnScope, txnScope)</span><br><span class="line">	<span class="keyword">return</span> newTiKVTxn, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看到，如同前一节 Percolator
的流程所述，所谓开启一个事务，其实只是从 TSO 拿了
<code>start_ts</code>，之后以 <code>start_ts</code> 作为版本号创建了对应
snapshot
的事务。因为乐观事务读不加锁，只在最终提交时才判断是否有冲突。</p>
<h3 id="事务内读写">事务内读写</h3>
<h4 id="读">读</h4>
<p>读操作主要通过构造合适的 <code>kv.Request</code> 并通过
<code>distSql.Select()</code>来进行查询。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Request <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// Tp is the request type.</span></span><br><span class="line">	Tp        <span class="type">int64</span></span><br><span class="line">	StartTs   <span class="type">uint64</span></span><br><span class="line">	Data      []<span class="type">byte</span></span><br><span class="line">	KeyRanges []KeyRange</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Concurrency is 1, if it only sends the request to a single storage unit when</span></span><br><span class="line">	<span class="comment">// ResponseIterator.Next is called. If concurrency is greater than 1, the request will be</span></span><br><span class="line">	<span class="comment">// sent to multiple storage units concurrently.</span></span><br><span class="line">	Concurrency <span class="type">int</span></span><br><span class="line">	<span class="comment">// IsolationLevel is the isolation level, default is SI.</span></span><br><span class="line">	IsolationLevel IsoLevel</span><br><span class="line">	<span class="comment">// Priority is the priority of this KV request, its value may be PriorityNormal/PriorityLow/PriorityHigh.</span></span><br><span class="line">	Priority <span class="type">int</span></span><br><span class="line">	<span class="comment">// memTracker is used to trace and control memory usage in co-processor layer.</span></span><br><span class="line">	MemTracker *memory.Tracker</span><br><span class="line">	<span class="comment">// KeepOrder is true, if the response should be returned in order.</span></span><br><span class="line">	KeepOrder <span class="type">bool</span></span><br><span class="line">	<span class="comment">// Desc is true, if the request is sent in descending order.</span></span><br><span class="line">	Desc <span class="type">bool</span></span><br><span class="line">	<span class="comment">// NotFillCache makes this request do not touch the LRU cache of the underlying storage.</span></span><br><span class="line">	NotFillCache <span class="type">bool</span></span><br><span class="line">	<span class="comment">// SyncLog decides whether the WAL(write-ahead log) of this request should be synchronized.</span></span><br><span class="line">	SyncLog <span class="type">bool</span></span><br><span class="line">	<span class="comment">// Streaming indicates using streaming API for this request, result in that one Next()</span></span><br><span class="line">	<span class="comment">// call would not corresponds to a whole region result.</span></span><br><span class="line">	Streaming <span class="type">bool</span></span><br><span class="line">	<span class="comment">// ReplicaRead is used for reading data from replicas, only follower is supported at this time.</span></span><br><span class="line">	ReplicaRead ReplicaReadType</span><br><span class="line">	<span class="comment">// StoreType represents this request is sent to the which type of store.</span></span><br><span class="line">	StoreType StoreType</span><br><span class="line">	<span class="comment">// Cacheable is true if the request can be cached. Currently only deterministic DAG requests can be cached.</span></span><br><span class="line">	Cacheable <span class="type">bool</span></span><br><span class="line">	<span class="comment">// SchemaVer is for any schema-ful storage to validate schema correctness if necessary.</span></span><br><span class="line">	SchemaVar <span class="type">int64</span></span><br><span class="line">	<span class="comment">// BatchCop indicates whether send batch coprocessor request to tiflash.</span></span><br><span class="line">	BatchCop <span class="type">bool</span></span><br><span class="line">	<span class="comment">// TaskID is an unique ID for an execution of a statement</span></span><br><span class="line">	TaskID <span class="type">uint64</span></span><br><span class="line">	<span class="comment">// TiDBServerID is the specified TiDB serverID to execute request. `0` means all TiDB instances.</span></span><br><span class="line">	TiDBServerID <span class="type">uint64</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，上述 request 中包含了
<code>StartTs</code>，因此会以该时间戳来进行查询。</p>
<p>当然，上述通过 distSql
查询的方式主要用于复杂查询，对于简单查询例如直接通过主键查询的场景（<code>PointGetExec</code>）就可以通过
<code>Transaction</code> 的 <code>Get()</code> 来进行查询：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">val, err = e.txn.GetMemBuffer().Get(ctx, key)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 先尝试从本地 memdb 中读取，找不到，就通过 snapshot 从 tikv 读取</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(us *unionStore)</span></span> Get(ctx context.Context, k Key) ([]<span class="type">byte</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	v, err := us.memBuffer.Get(ctx, k)</span><br><span class="line">	<span class="keyword">if</span> IsErrNotFound(err) &#123;</span><br><span class="line">		v, err = us.snapshot.Get(ctx, k)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> v, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(v) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, ErrNotExist</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> v, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="写">写</h4>
<p>对于事务内写，我们从上一节已经了解到，所有的写操作都会暂存在本地，最后在提交时一并发出：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">memBuffer := txn.GetMemBuffer()</span><br><span class="line">err = memBuffer.Set(key, value)</span><br></pre></td></tr></table></figure>
<h3 id="提交事务">提交事务</h3>
<p>我们直接来看看 <code>tikvTxn</code> 的
<code>Commit()</code>实现：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(txn *tikvTxn)</span></span> Commit(ctx context.Context) <span class="type">error</span> &#123;</span><br><span class="line">	...</span><br><span class="line">  </span><br><span class="line">	<span class="comment">// connID is used for log.</span></span><br><span class="line">	<span class="keyword">var</span> connID <span class="type">uint64</span></span><br><span class="line">	val := ctx.Value(sessionctx.ConnID)</span><br><span class="line">	<span class="keyword">if</span> val != <span class="literal">nil</span> &#123;</span><br><span class="line">		connID = val.(<span class="type">uint64</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> err <span class="type">error</span></span><br><span class="line">	<span class="comment">// If the txn use pessimistic lock, committer is initialized.</span></span><br><span class="line">	committer := txn.committer</span><br><span class="line">	<span class="keyword">if</span> committer == <span class="literal">nil</span> &#123;</span><br><span class="line">		committer, err = newTwoPhaseCommitter(txn, connID)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> errors.Trace(err)</span><br><span class="line">		&#125;</span><br><span class="line">		txn.committer = committer</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	initRegion := trace.StartRegion(ctx, <span class="string">&quot;InitKeys&quot;</span>)</span><br><span class="line">	err = committer.initKeysAndMutations()</span><br><span class="line">	initRegion.End()</span><br><span class="line">	...</span><br><span class="line">  </span><br><span class="line">	<span class="comment">// latches disabled</span></span><br><span class="line">	<span class="comment">// pessimistic transaction should also bypass latch.</span></span><br><span class="line">	<span class="keyword">if</span> txn.store.txnLatches == <span class="literal">nil</span> || txn.IsPessimistic() &#123;</span><br><span class="line">		err = committer.execute(ctx)</span><br><span class="line">		<span class="keyword">if</span> val == <span class="literal">nil</span> || connID &gt; <span class="number">0</span> &#123;</span><br><span class="line">			txn.onCommitted(err)</span><br><span class="line">		&#125;</span><br><span class="line">		logutil.Logger(ctx).Debug(<span class="string">&quot;[kv] txnLatches disabled, 2pc directly&quot;</span>, zap.Error(err))</span><br><span class="line">		<span class="keyword">return</span> errors.Trace(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// latches enabled</span></span><br><span class="line">	<span class="comment">// for transactions which need to acquire latches</span></span><br><span class="line">	start = time.Now()</span><br><span class="line">	lock := txn.store.txnLatches.Lock(committer.startTS, committer.mutations.GetKeys())</span><br><span class="line">	commitDetail := committer.getDetail()</span><br><span class="line">	commitDetail.LocalLatchTime = time.Since(start)</span><br><span class="line">	<span class="keyword">if</span> commitDetail.LocalLatchTime &gt; <span class="number">0</span> &#123;</span><br><span class="line">		metrics.TiKVLocalLatchWaitTimeHistogram.Observe(commitDetail.LocalLatchTime.Seconds())</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> txn.store.txnLatches.UnLock(lock)</span><br><span class="line">	<span class="keyword">if</span> lock.IsStale() &#123;</span><br><span class="line">		<span class="keyword">return</span> kv.ErrWriteConflictInTiDB.FastGenByArgs(txn.startTS)</span><br><span class="line">	&#125;</span><br><span class="line">	err = committer.execute(ctx)</span><br><span class="line">	<span class="keyword">if</span> val == <span class="literal">nil</span> || connID &gt; <span class="number">0</span> &#123;</span><br><span class="line">		txn.onCommitted(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">		lock.SetCommitTS(committer.commitTS)</span><br><span class="line">	&#125;</span><br><span class="line">	logutil.Logger(ctx).Debug(<span class="string">&quot;[kv] txnLatches enabled while txn retryable&quot;</span>, zap.Error(err))</span><br><span class="line">	<span class="keyword">return</span> errors.Trace(err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（上面的 <code>latch</code>
是作为一个配置选项来进行开启的本地内存锁，默认关闭，文档中提到如果<a
href="https://docs.pingcap.com/zh/tidb/stable/tidb-configuration-file#txn-local-latches">本地事务冲突较多可以考虑开启</a>。）</p>
<p>在对<code>twoPhaseCommitter</code> 进行初始化后，关键逻辑就是
<code>err = committer.execute(ctx)</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *twoPhaseCommitter)</span></span> execute(ctx context.Context) (err <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">var</span> binlogSkipped <span class="type">bool</span></span><br><span class="line">	...</span><br><span class="line">  </span><br><span class="line">	err = c.prewriteMutations(prewriteBo, c.mutations)</span><br><span class="line">	...</span><br><span class="line">  </span><br><span class="line">	newCommitTS, err := c.getCommitTS(ctx, commitDetail)</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">return</span> c.commitTxn(ctx, commitDetail)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不论是 <code>prewriteMutations</code> 还是
<code>commitTxn</code>，实现当中都调用了</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *twoPhaseCommitter)</span></span> doActionOnMutations(bo *Backoffer, action twoPhaseCommitAction, mutations CommitterMutations) <span class="type">error</span> &#123;</span><br><span class="line">	...</span><br><span class="line">	groups, err := c.groupMutations(bo, mutations)</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> c.doActionOnGroupMutations(bo, action, groups)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法，先将本次提交所修改的 <code>mutations</code> 按照
<code>region</code>划分成组，之后根据不同的传入参数（分别是在
<code>prewrite.go</code>中的 <code>actionPrewrite&#123;&#125;</code> 以及
<code>commit.go</code> 中的
<code>actionCommit&#123;&#125;</code>）来执行具体的逻辑。</p>
<h4 id="prewrite">Prewrite</h4>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(action actionPrewrite)</span></span> handleSingleBatch(c *twoPhaseCommitter, bo *Backoffer, batch batchMutations) <span class="type">error</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">	</span><br><span class="line">  txnSize := <span class="type">uint64</span>(c.regionTxnSize[batch.region.id])</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	req := c.buildPrewriteRequest(batch, txnSize)</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		sender := NewRegionRequestSender(c.store.regionCache, c.store.client)</span><br><span class="line">		resp, err := sender.SendReq(bo, req, batch.region, readTimeoutShort)</span><br><span class="line">		...</span><br><span class="line">    </span><br><span class="line">		prewriteResp := resp.Resp.(*pb.PrewriteResponse)</span><br><span class="line">		keyErrs := prewriteResp.GetErrors()</span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(keyErrs) == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> batch.isPrimary &#123;</span><br><span class="line">				<span class="comment">// After writing the primary key, if the size of the transaction is larger than 32M,</span></span><br><span class="line">				<span class="comment">// start the ttlManager. The ttlManager will be closed in tikvTxn.Commit().</span></span><br><span class="line">				<span class="comment">// In this case 1PC is not expected to be used, but still check it for safety.</span></span><br><span class="line">				<span class="keyword">if</span> <span class="type">int64</span>(c.txnSize) &gt; config.GetGlobalConfig().TiKVClient.TTLRefreshedTxnSize &amp;&amp;</span><br><span class="line">					prewriteResp.OnePcCommitTs == <span class="number">0</span> &#123;</span><br><span class="line">					c.run(c, <span class="literal">nil</span>)</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			...</span><br><span class="line">      </span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">var</span> locks []*Lock</span><br><span class="line">		<span class="keyword">for</span> _, keyErr := <span class="keyword">range</span> keyErrs &#123;</span><br><span class="line">			<span class="comment">// Check already exists error</span></span><br><span class="line">			<span class="keyword">if</span> alreadyExist := keyErr.GetAlreadyExist(); alreadyExist != <span class="literal">nil</span> &#123;</span><br><span class="line">				key := alreadyExist.GetKey()</span><br><span class="line">				<span class="keyword">return</span> c.extractKeyExistsErr(key)</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Extract lock from key error</span></span><br><span class="line">			lock, err1 := extractLockFromKeyErr(keyErr)</span><br><span class="line">			<span class="keyword">if</span> err1 != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> errors.Trace(err1)</span><br><span class="line">			&#125;</span><br><span class="line">			...</span><br><span class="line">		&#125;</span><br><span class="line">		start := time.Now()</span><br><span class="line">		msBeforeExpired, err := c.store.lockResolver.resolveLocksForWrite(bo, c.startTS, locks)</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>handleSingleBatch</code>() 会按照 <code>Region</code>
拆分为的多个 <code>batch</code> 并行执行，每个 <code>batch</code>
都会执行一次。</p>
<p>显然，prewrite 请求会按照 <code>region</code> 发给对应的 tikv
来实际处理，具体处理流程见请见下一篇。</p>
<p>最后注意<code>c.store.lockResolver.resolveLocksForWrite(bo, c.startTS, locks)</code>
操作用来尝试解锁，解锁的逻辑如注释中所述：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ResolveLocks tries to resolve Locks. The resolving process is in 3 steps:</span></span><br><span class="line"><span class="comment">// 1) Use the `lockTTL` to pick up all expired locks. Only locks that are too</span></span><br><span class="line"><span class="comment">//    old are considered orphan locks and will be handled later. If all locks</span></span><br><span class="line"><span class="comment">//    are expired then all locks will be resolved so the returned `ok` will be</span></span><br><span class="line"><span class="comment">//    true, otherwise caller should sleep a while before retry.</span></span><br><span class="line"><span class="comment">// 2) For each lock, query the primary key to get txn(which left the lock)&#x27;s</span></span><br><span class="line"><span class="comment">//    commit status.</span></span><br><span class="line"><span class="comment">// 3) Send `ResolveLock` cmd to the lock&#x27;s region to resolve all locks belong to</span></span><br><span class="line"><span class="comment">//    the same transaction.</span></span><br></pre></td></tr></table></figure>
<h4 id="commit">Commit</h4>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(actionCommit)</span></span> handleSingleBatch(c *twoPhaseCommitter, bo *Backoffer, batch batchMutations) <span class="type">error</span> &#123;</span><br><span class="line">	keys := batch.mutations.GetKeys()</span><br><span class="line">	req := tikvrpc.NewRequest(tikvrpc.CmdCommit, &amp;pb.CommitRequest&#123;</span><br><span class="line">		StartVersion:  c.startTS,</span><br><span class="line">		Keys:          keys,</span><br><span class="line">		CommitVersion: c.commitTS,</span><br><span class="line">	&#125;, pb.Context&#123;Priority: c.priority, SyncLog: c.syncLog&#125;)</span><br><span class="line"></span><br><span class="line">	sender := NewRegionRequestSender(c.store.regionCache, c.store.client)</span><br><span class="line">	resp, err := sender.SendReq(bo, req, batch.region, readTimeoutShort)</span><br><span class="line">	...</span><br><span class="line">  </span><br><span class="line">	commitResp := resp.Resp.(*pb.CommitResponse)</span><br><span class="line">	<span class="comment">// Here we can make sure tikv has processed the commit primary key request. So</span></span><br><span class="line">	<span class="comment">// we can clean undetermined error.</span></span><br><span class="line">	<span class="keyword">if</span> batch.isPrimary &#123;</span><br><span class="line">		c.setUndeterminedErr(<span class="literal">nil</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> keyErr := commitResp.GetError(); keyErr != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> rejected := keyErr.GetCommitTsExpired(); rejected != <span class="literal">nil</span> &#123;</span><br><span class="line">			...</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Do not retry for a txn which has a too large MinCommitTs</span></span><br><span class="line">			<span class="comment">// 3600000 &lt;&lt; 18 = 943718400000</span></span><br><span class="line">			<span class="keyword">if</span> rejected.MinCommitTs-rejected.AttemptedCommitTs &gt; <span class="number">943718400000</span> &#123;</span><br><span class="line">				err := errors.Errorf(<span class="string">&quot;2PC MinCommitTS is too large, we got MinCommitTS: %d, and AttemptedCommitTS: %d&quot;</span>,</span><br><span class="line">					rejected.MinCommitTs, rejected.AttemptedCommitTs)</span><br><span class="line">				<span class="keyword">return</span> errors.Trace(err)</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Update commit ts and retry.</span></span><br><span class="line">			commitTS, err := c.store.getTimestampWithRetry(bo, c.txn.GetUnionStore().GetOption(kv.TxnScope).(<span class="type">string</span>))</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				logutil.Logger(bo.ctx).Warn(<span class="string">&quot;2PC get commitTS failed&quot;</span>,</span><br><span class="line">					zap.Error(err),</span><br><span class="line">					zap.Uint64(<span class="string">&quot;txnStartTS&quot;</span>, c.startTS))</span><br><span class="line">				<span class="keyword">return</span> errors.Trace(err)</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			c.mu.Lock()</span><br><span class="line">			c.commitTS = commitTS</span><br><span class="line">			c.mu.Unlock()</span><br><span class="line">			<span class="keyword">return</span> c.commitMutations(bo, batch.mutations)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		c.mu.RLock()</span><br><span class="line">		<span class="keyword">defer</span> c.mu.RUnlock()</span><br><span class="line">		err = extractKeyErr(keyErr)</span><br><span class="line">		<span class="keyword">if</span> c.mu.committed &#123;</span><br><span class="line">			<span class="comment">// No secondary key could be rolled back after it&#x27;s primary key is committed.</span></span><br><span class="line">			<span class="comment">// There must be a serious bug somewhere.</span></span><br><span class="line">			hexBatchKeys := <span class="function"><span class="keyword">func</span><span class="params">(keys [][]<span class="type">byte</span>)</span></span> []<span class="type">string</span> &#123;</span><br><span class="line">				<span class="keyword">var</span> res []<span class="type">string</span></span><br><span class="line">				<span class="keyword">for</span> _, k := <span class="keyword">range</span> keys &#123;</span><br><span class="line">					res = <span class="built_in">append</span>(res, hex.EncodeToString(k))</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">return</span> res</span><br><span class="line">			&#125;</span><br><span class="line">			logutil.Logger(bo.ctx).Error(<span class="string">&quot;2PC failed commit key after primary key committed&quot;</span>,</span><br><span class="line">				zap.Error(err),</span><br><span class="line">				zap.Uint64(<span class="string">&quot;txnStartTS&quot;</span>, c.startTS),</span><br><span class="line">				zap.Uint64(<span class="string">&quot;commitTS&quot;</span>, c.commitTS),</span><br><span class="line">				zap.Strings(<span class="string">&quot;keys&quot;</span>, hexBatchKeys(keys)))</span><br><span class="line">			<span class="keyword">return</span> errors.Trace(err)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// The transaction maybe rolled back by concurrent transactions.</span></span><br><span class="line">		logutil.Logger(bo.ctx).Debug(<span class="string">&quot;2PC failed commit primary key&quot;</span>,</span><br><span class="line">			zap.Error(err),</span><br><span class="line">			zap.Uint64(<span class="string">&quot;txnStartTS&quot;</span>, c.startTS))</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	c.mu.Lock()</span><br><span class="line">	<span class="keyword">defer</span> c.mu.Unlock()</span><br><span class="line">	<span class="comment">// Group that contains primary key is always the first.</span></span><br><span class="line">	<span class="comment">// We mark transaction&#x27;s status committed when we receive the first success response.</span></span><br><span class="line">	c.mu.committed = <span class="literal">true</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与 prewrite 阶段类似，commit 阶段也是按照 <code>region</code> 向 tikv
发送了 commit
请求，方法中大量的操作都是在处理可能返回的提交错误，包括重试，返回错误等等方式。</p>
<h2 id="悲观事务实现">悲观事务实现</h2>

    </div>

    
    
    

    <footer class="post-footer">
          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>Post author:  </strong>Lenshood
  </li>
  <li class="post-copyright-link">
      <strong>Post link: </strong>
      <a href="http://lenshood.github.io/2020/10/12/tidb-lesson-7/" title="TiDB 学习课程 Lesson-7">http://lenshood.github.io/2020/10/12/tidb-lesson-7/</a>
  </li>
  <li class="post-copyright-license">
      <strong>Copyright Notice:  </strong>All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> unless stating additionally.
  </li>
</ul>
</div>

          <div class="followme">
  <span>Welcome to my other publishing channels</span>

  <div class="social-list">

      <div class="social-item">
          <a target="_blank" class="social-link" href="/atom.xml">
            <span class="icon">
              <i class="fa fa-rss"></i>
            </span>

            <span class="label">RSS</span>
          </a>
      </div>
  </div>
</div>

          <div class="post-tags">
              <a href="/tags/tidb/" rel="tag"># tidb</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2020/10/03/tidb-lesson-6/" rel="prev" title="TiDB 学习课程 Lesson-6">
                  <i class="fa fa-angle-left"></i> TiDB 学习课程 Lesson-6
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2020/10/14/tidb-lesson-8/" rel="next" title="TiDB 学习课程 Lesson-8">
                  TiDB 学习课程 Lesson-8 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments utterances-container"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Lenshood</span>
  </div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>
<script class="next-config" data-name="utterances" type="application/json">{"enable":true,"repo":"LENSHOOD/lenshood.github.io","issue_term":"pathname","theme":"github-light"}</script>
<script src="/js/third-party/comments/utterances.js" defer></script>

</body>
</html>
