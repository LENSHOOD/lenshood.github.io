---
title: 读 DDIA 书评与总结
date: 2022-12-29 23:40:31
tags:
- ddia
- book review
categories:
- Others
---

{% asset_img header.jpg 500 %}

本文是我在读完 DDIA 后的总结和评价感想。

<!-- more -->

DDIA，22 年初我其实就已经看完了，一直拖到了年底才想到做一些总结，虽迟但到。

在刚刚读完的时候，对这本书整体上的感觉，从知识的角度看，在许多细分的知识点上让我知其然且知其所以然。一些知识点早就听说过，也大概知其原理，但一方面是了解的程度不够深，另一方面这些知识之间很孤立，无法与其他知识形成关联。

因此个人认为 DDIA 所能带给读者的，的确书如其名，是包含了*数据密集型应用系统* 设计的方方面面，且能帮助读者对 *数据密集型应用系统* 相关知识形成体系化的概念和理解。

## 总体架构



## 数据系统基础

### 第一章：可靠，可扩展与可维护的应用系统

不论是数据系统（data system）还是其他软件系统，在整个生命周期中都会面临三个问题：可靠性、可扩展性、可维护性。这三大问题都属于软件的跨功能需求（CFR）。能很好的解决这三大问题是成熟软件系统的必要条件。

#### 可靠性 Reliability

简单描述为在遇到故障时仍然可用的能力，亦可称之为容错性（fault-tolerant）或是韧性（resilient）。

对于复杂的大型系统，故障（fault）难以避免，对于容错来说，就是系统能够容忍一部分错误，从而防止系统失效（faillure）。失效便意味着系统不可用了（unavailable）。

软件需要通过可靠性设计来获得容错性或韧性，可以通过故障测试来验证系统的可靠性，如混沌测试（chaos test）。另外，不同的功能优先级不同，因此对故障的容错办法也不同，根据实际情况选择以达到最大投产比。

#### 可扩展性 Scalability

软件的可扩展性描述为，当负载增加时，增加系统资源来满足可接受的系统性能。

负载（load）：用参数来描述可以是用户量，请求数等指标。

性能（performance）与资源（resource）：性能参数可包括响应时间，吞吐量等，通常用百分位指标来描述如 P90、P95、P99

可扩展性的要求，可细化为

- 在资源不变的前提下，当负载上升时，性能如何变化
- 若要求性能稳定，那么如何提供资源来应对负载的变化

对于可扩展性设计，可采取水平扩展（horizontal）和垂直扩展（vertical）的方案。简单来说就是水平扩展加机器，垂直扩展升级机器。

#### 可维护性 Maintainability

可维护性意味着对软件在整个生命周期内的持续投入。

可以说软件系统在发布之后就已经是遗留系统（legacy system）了。随着时间的推移，可维护性差的软件，可能会变成没人愿意维护的遗留系统，糟糕的设计会导致软件变成大泥球（big mud ball）

可维护性细分为三种能力：

**可运维：**

可运维性要求软件系统可观测、可迁移、可理解。

可观测代表对系统运行状态的洞察能力，可迁移代表易于对系统操作的能力，可理解代表系统知识的整理、归档等等。

**简单：**

在复杂的需求下还能保持简单的软件，其核心要义在于设计合理的抽象（abstraction）。

通过抽象解决问题分层，在同一抽象层通过合理的边界，构建高内聚低耦合的软件架构。

**可演化性：**

软件在不断的演进，可演化性要求不论是人员的更迭，或是特性的增减，系统都支持持续的演进而不是停滞不前。

可演化性不仅针对软件本身，也对团队提出了要求，研发效能高的团队，演进的更快、更好。

软件本身良好的设计也是可演化的前提，设计良好则易于修改。

### 第二章：数据模型与查询语言

数据模型是数据系统表现数据的逻辑形态，从数据对象的角度看，数据模型保存了数据对象的**自身属性**以及与其他数据对象之间的**关联关系**。

有三种数据模型，基于数据对象的自身属性和关联关系，分别从不同的关注点来表示数据：

1. 文档模型：更关注数据对象的自身属性
   - 结构简单，易于理解
   - 底层存储更紧凑，空间局部性好
   - 弱模式要求，同一个数据对象不要求模式完全一致
   - 不易处理多对一，多对多的关系，数据间的 join 可能会依赖应用层逻辑
2. 图模型：更关注数据对象间的关系
   - 专门用于处理复杂的多对多关系
   - 通过节点和边描述数据
3. 关系模型：折中的数据模型
   - 通过 table 的形式描述数据
   - 能设计出严格符合数据规范化的数据模型
   - 通过查询优化器代理了上层应用的 join 动作

针对不同的数据模型，也存在多种查询语言。

查询语言可分为命令式和声明式的。对于数据库系统而言，大多数查询语言都是声明式的，因为声明式语言的抽象层次更高，对细节的描述更少。命令式语言更贴近代码，由代码来控制如何进行数据的写入和查询。

### 第三章： 数据存储与检索

#### 两种数据处理业务：

1. OLTP：在线事务处理
   - 面向用户，为了快速响应，每次查询只涉及少量数据
   - 应用程序基于 key 来做查询，查询瓶颈在磁盘寻道时间
2. OLAP：在线分析处理
   - 查询请求数量很少，但每个查询都可能需要在短时间内扫描数百万条记录
   - 范围检索，磁盘带宽是瓶颈

数据结构是数据库的核心，实际存储的数据结构可能与数据模型大相径庭。

索引是由原始数据派生出的数据结构，索引用于更高效的查询数据，两种常见的索引数据结构：

B-Tree（[详细](https://lenshood.github.io/2021/07/05/bpt-lsmt/)），LSM-Tree（[详细](https://lenshood.github.io/2021/07/18/bpt-lsmt-2/)）。

#### LSM-Tree 对比 B-Tree

1. 写入吞吐量高
   - LSM-Tree 相较于 B-Tree 在合理的配置下有较低的写放大（[详细](https://tikv.org/deep-dive/key-value-engine/b-tree-vs-lsm/)）
   - LSM-Tree 的顺序磁盘写入，速度更快
   - LSM-Tree 数据文件可压缩，碎片更少
2. 压缩工作影响读写业务
   - 磁盘并发资源有限，后台压缩可能导致读写等待
   - 磁盘带宽资源有限，后台压缩会占用大量带宽

#### 数据仓库

单独的数据库，包含的数据通常是 OLTP 数据库的副本，供分析人员进行分析。

分析型业务下数据模型通常采用事实表+维度表的形式：

- 事实表：每一行代表发生的一个事件，事件包含于所有维度相关的 id
- 维度表：记录不同维度的数据，通过 id 与事实表关联

事实表+维度表构成”星形模型“，对维度表的进一步规范化后，可得到”雪花模型“。

#### 列式存储

基于分析性业务的数据模型，通常一次分析可能只关注事实表中有限的几列，因此其他成百上千的列并没有分析价值。

因此通过列式存储，每一列单独存储后，分析时只加载特定列的数据即可。

此外，列式存储中，每一列存放的数据都高度相似，因此压缩比很高，节约磁盘空间。

## 分布式数据系统



## 派生数据

