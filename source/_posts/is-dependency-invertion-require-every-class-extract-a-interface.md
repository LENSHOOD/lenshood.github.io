---
title: 依赖倒置就是每一个实现都要抽一个接口出来吗？
date: 2020-01-25 16:59:59
tags: 
- SOLID
- Dependency Inversion
categories:
- Software Engineering
---

## 依赖倒置就是每一个实现都要抽一个接口出来吗？
本文的标题实际上来自于一次与项目上同事中午吃饭时的讨论
：

>  A: 我觉得我们现在的抽象有点多，infra 层里面每一个类都抽取了接口，这些被调用的类多半只有一个实现， 我们是不是做的太细了？
>  
>  B: 从依赖倒置的角度讲，domain 层和 service 层并不应该直接调用 infra 层的实现，因此我们确实是需要每一个实现都抽一个接口出来。
>  
>  A: 那依赖倒置就是每一个实现都要抽一个接口出来吗？
> 
>  B: 这个...

看来小伙伴 A 不经意间触碰到了 S.O.L.I.D. 的深水区..

相比于单一职责、开闭、接口隔离等原则，依赖倒置与里氏替换一样，属于更偏向操作指导的一类原则，比如：

1. 依赖倒置：高层模块不应直接依赖低层模块，他们都应该依赖于彼此间的抽象。
    - 开发角度看：**上层不要直接调用下层，而是调用抽出来的接口。**
2. 里氏替换：要确保超类所拥有的性质在子类中仍然成立。
    - 开发角度看：**派生的子类一定不能破坏父类已经定义好的行为。**

所以：**依赖倒置就是每一个实现都要抽一个接口出来吗？**

为了解释这个问题，我们尝试来提出一个新的问题：**为啥要依赖倒置**

### 为啥要依赖倒置

先说结论：***因为代码是由业务需求驱动出来的，而业务驱动路径一定是从高层逐渐传递至低层。高层不会去了解低层的细节，而只会对低层的需求给出定义。***

我们引入一个例子：
> 业务需求:
>
> 文件存储需求。现有若干 file 对象，期望提供服务，对 file 描述的文件进行存储，要求存储成功后拿到一个 id，并且可以通过该 id 再次取出该 file 对象。

我们分析这样的一个需求，显然对于获取文件并进行存储，最后返回唯一 id 的工作是由下层模块来提供。而上层模块只需要知道我能提供什么，以及我能得到什么，所以可以抽象出如下 API：
```
id:String saveFile(file:File)

file:File getFile(id:String)
```

以上是消费端对需求的理解。

假如从服务提供者角度来看呢？作为服务提供者，我给出方案可能是把文件远程存储在独立的文件服务器上，那么首先需要有调用方所在主机的 IP（如有必要还需要认证相关信息），其次需要文件的路径。执行过程是文件存储服务登录到主机上，根据路径找到文件，远程复制到独立的文件服务器，之后生成并记录该文件的唯一 id，最后将 id 返回给调用者。因此对于服务提供方，可能会提供如下 API：
```
id:String saveFile(ip:String, path:Path)

void getFile(id:String, ip:String, path:Path)
```

可以看到提供方和消费方给出的 API 是大相径庭的。那么到底应该以哪一方为准呢？从业务角度讲，应该是以需求方也就是消费者为准的，类似可见微服务中的消费者驱动契约开发（[Consumer-Driven Contracts](https://martinfowler.com/articles/consumerDrivenContracts.html)）。

### 说了半天，没提依赖倒置呀？
我们顺着上文的思路，来想一想，假如高低层模块都是由同一个团队来开发维护，并且严格按照业务驱动的模式来开发，上述需求会怎么一步步变成代码呢？

1. 出现业务需求，期望对文件进行存储
2. 团队认为，具体文件存储的实现应该不属于 domain 层，而是 infrastructure 层。
3. 为了不影响业务卡的开发，团队根据讨论，提取出了文件存储所需的抽象，即：
    ```
    id:String saveFile(file:File)

    file:File getFile(id:String)
    ```
4. 某小伙伴领取实现文件存储的故事卡，通过工具类获取本机 IP，从 file 对象中拿到文件路径，之后存储至远端文件服务，记录信息，返回唯一 id。
5. 后来，由于部署环境变更，远程文件服务不可用，文件存储要改为存在本地，对于这个需求，做卡的小伙伴只要遵循抽象，重新实现一套本地存储的方案即可，对上层业务完全透明。

可见，由业务需求驱动的开发天然满足了依赖倒置的需要，层与层之间互相解耦，整个系统也就对需求变更表现出了更强的适应性。

不过实际当中，很多时候不同层次的开发是由不同团队完成的，我们没法左右已经提供了 API 的基础设施，怎么办呢？

DDD 中，有一个[六边形架构](https://insights.thoughtworks.cn/from-sandwich-to-hexagon/)的概念，六边形架构内所有的业务逻辑与其他外部依赖之间，全部采用适配器进行适配，以尽可能的隔离业务边界，增加扩展性。

所以引申到上述例子，假如系统现有的文件服务提供给我们的 API 必须要以 IP 和文件路径作为参数，那么为了防止业务与外部服务产生依赖，我们仍旧以业务需求驱动的方式，提取文件存储抽象，之后新增适配器，适配器一端依赖抽象，一端依赖外部文件服务。通过这种办法就可以很好的实现依赖倒置。

有了适配器，无论外部服务怎么变化，只要跟着改适配器，我们的业务仍然是高度内聚的。

### 回过头来
上述文字具体说明了为什么要依赖倒置以及怎么进行依赖倒置。现在，我们再回到最开始的问题本身：

**依赖倒置就是每一个实现都要抽一个接口出来吗？**

答案显而易见了：

**恰恰相反，依赖倒置应该是先由消费方定义接口，再由提供方实现，只不过从最终产出物的角度看，的确是每个实现都抽取了一个接口而已。**

因此假如作为服务提供方，为了满足依赖倒置，臆想消费方的需求来抽取接口，那不叫依赖倒置，叫本末倒置。

### 最后总结一下
1. **什么是依赖倒置：** 高层模块不应直接依赖低层模块，他们应该都依赖于彼此间的抽象。
2. **为什么要依赖倒置：** 因为代码是由业务需求驱动出来的，而业务驱动路径一定是从高层逐渐传递至低层。高层不会去了解低层的细节，而只会对低层的需求给出定义。
3. **怎么实现依赖倒置：** 由消费方定义抽象，由提供方实现抽象。
