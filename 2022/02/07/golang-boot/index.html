<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.2.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&family=Roboto+Mono:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" integrity="sha256-dABdfBfUoC8vJUBOwGVdm8L9qlMWaHTIfXt+7GnZCIo=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"lenshood.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.23.2","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js" defer></script>

    <meta name="description" content="本文纯代码 + 注释，不适合人类阅读。Go Version &#x3D; 1.17.6">
<meta property="og:type" content="article">
<meta property="og:title" content="Go Runtime 代码随笔">
<meta property="og:url" content="http://lenshood.github.io/2022/02/07/golang-boot/index.html">
<meta property="og:site_name" content="Lenshood">
<meta property="og:description" content="本文纯代码 + 注释，不适合人类阅读。Go Version &#x3D; 1.17.6">
<meta property="og:locale">
<meta property="article:published_time" content="2022-02-07T14:55:34.000Z">
<meta property="article:modified_time" content="2025-07-29T02:17:59.094Z">
<meta property="article:author" content="Lenshood">
<meta property="article:tag" content="source">
<meta property="article:tag" content="go">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://lenshood.github.io/2022/02/07/golang-boot/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh","comments":true,"permalink":"http://lenshood.github.io/2022/02/07/golang-boot/","path":"2022/02/07/golang-boot/","title":"Go Runtime 代码随笔"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Go Runtime 代码随笔 | Lenshood</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=PUEl-M5yzvvDvk3aBT4OetgMoLOX38OZ8nZgoLcEZp4"></script>
  <script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"PUEl-M5yzvvDvk3aBT4OetgMoLOX38OZ8nZgoLcEZp4","only_pageview":false,"measure_protocol_api_secret":null}</script>
  <script src="/js/third-party/analytics/google-analytics.js" defer></script>

  <script src="/js/third-party/analytics/baidu-analytics.js" defer></script>
  <script async src="https://hm.baidu.com/hm.js?9838df2db88eb05f5159ca8e58b5f778"></script>







  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  






  




  

  <script class="next-config" data-name="enableMath" type="application/json">false</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js" defer></script>



  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><link rel="alternate" href="/atom.xml" title="Lenshood" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Lenshood</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Software Developer @ThoughtWorks</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B"><span class="nav-number">1.</span> <span class="nav-text">1. 启动过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#m-%E7%B3%BB%E7%BB%9F%E7%BA%BF%E7%A8%8B%E6%93%8D%E4%BD%9C"><span class="nav-number">2.</span> <span class="nav-text">2. M 系统线程操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%88"><span class="nav-number">3.</span> <span class="nav-text">3. 栈</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A0%86"><span class="nav-number">4.</span> <span class="nav-text">4. 堆</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="nav-number">5.</span> <span class="nav-text">5. 内存管理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="nav-number">5.1.</span> <span class="nav-text">5.1 内存分配</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6gc"><span class="nav-number">5.2.</span> <span class="nav-text">5.2 内存回收（GC）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8A%A2%E5%8D%A0"><span class="nav-number">6.</span> <span class="nav-text">6. 抢占</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Lenshood</p>
  <div class="site-description" itemprop="description">Three Cats Man</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">91</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">104</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/LENSHOOD" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;LENSHOOD" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/atom.xml" title="RSS → atom.xml" rel="noopener me"><i class="fa fa-rss fa-fw"></i>RSS</a>
      </span>
  </div>
  <div class="cc-license animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdnjs.cloudflare.com/ajax/libs/creativecommons-vocabulary/2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh">
    <link itemprop="mainEntityOfPage" href="http://lenshood.github.io/2022/02/07/golang-boot/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Lenshood">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lenshood">
      <meta itemprop="description" content="Three Cats Man">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Go Runtime 代码随笔 | Lenshood">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Go Runtime 代码随笔
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-02-07 22:55:34" itemprop="dateCreated datePublished" datetime="2022-02-07T22:55:34+08:00">2022-02-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2025-07-29 10:17:59" itemprop="dateModified" datetime="2025-07-29T10:17:59+08:00">2025-07-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Golang/" itemprop="url" rel="index"><span itemprop="name">Golang</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><blockquote>
<p>本文纯代码 + 注释，不适合人类阅读。Go Version = 1.17.6</p>
</blockquote>
<span id="more"></span>
<h3 id="启动过程">1. 启动过程</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br></pre></td><td class="code"><pre><span class="line">/*** go 1.17.6 ***/</span><br><span class="line"></span><br><span class="line">/**************** [asm_amd64.s] ****************/</span><br><span class="line"></span><br><span class="line">/* entry point */</span><br><span class="line">TEXT _rt0_amd64(SB),NOSPLIT,$-8</span><br><span class="line">	MOVQ	0(SP), DI	// argc</span><br><span class="line">	LEAQ	8(SP), SI	// argv</span><br><span class="line">	JMP	runtime·rt0_go(SB)</span><br><span class="line">	</span><br><span class="line">/* 主启动流程</span><br><span class="line"> * 1. 该函数代表 runtime 包下的 rt0_go 函数，“·” 符号用于路径分隔 </span><br><span class="line"> * 2. NOSPLIT = 不需要栈分割，TOPFRAME = 调用栈最顶层，Traceback 会在此停止</span><br><span class="line">*/</span><br><span class="line">TEXT runtime·rt0_go(SB),NOSPLIT|TOPFRAME,$0</span><br><span class="line">	/* AX = argc， BX = argv */</span><br><span class="line">	MOVQ	DI, AX		// argc</span><br><span class="line">	MOVQ	SI, BX		// argv</span><br><span class="line">	</span><br><span class="line">	/* 扩张当前栈空间至 SP - (4*8+7)，再将 SP 地址按 16 字节对齐（部分 CPU 指令要求对齐，如 SSE）*/</span><br><span class="line">	SUBQ	$(4*8+7), SP		// 2args 2auto</span><br><span class="line">	ANDQ	$~15, SP</span><br><span class="line">	</span><br><span class="line">	/* SP+16 = argc， SP+24 = argv */</span><br><span class="line">	MOVQ	AX, 16(SP)</span><br><span class="line">	MOVQ	BX, 24(SP)</span><br><span class="line"></span><br><span class="line">	/* 初始化 g0 的 stack，SB 伪寄存器配合前缀可得到 g0 在 DATA 区的地址 */</span><br><span class="line">	MOVQ	$runtime·g0(SB), DI</span><br><span class="line">	LEAQ	(-64*1024+104)(SP), BX</span><br><span class="line">	MOVQ	BX, g_stackguard0(DI)</span><br><span class="line">	MOVQ	BX, g_stackguard1(DI)</span><br><span class="line">	/* g0 栈空间下限 = SP - 64Kib + 104byte，栈空间上限 = SP */</span><br><span class="line">	MOVQ	BX, (g_stack+stack_lo)(DI)</span><br><span class="line">	MOVQ	SP, (g_stack+stack_hi)(DI)</span><br><span class="line"></span><br><span class="line">	/* CPU 信息设置以及 cgo 对 g0 栈空间的影响 */</span><br><span class="line">	MOVL	$0, AX</span><br><span class="line">	CPUID</span><br><span class="line">	MOVL	AX, SI</span><br><span class="line">	CMPL	AX, $0</span><br><span class="line">	JE	nocpuinfo</span><br><span class="line"></span><br><span class="line">	// Figure out how to serialize RDTSC.</span><br><span class="line">	// On Intel processors LFENCE is enough. AMD requires MFENCE.</span><br><span class="line">	// Don&#x27;t know about the rest, so let&#x27;s do MFENCE.</span><br><span class="line">	CMPL	BX, $0x756E6547  // &quot;Genu&quot;</span><br><span class="line">	JNE	notintel</span><br><span class="line">	CMPL	DX, $0x49656E69  // &quot;ineI&quot;</span><br><span class="line">	JNE	notintel</span><br><span class="line">	CMPL	CX, $0x6C65746E  // &quot;ntel&quot;</span><br><span class="line">	JNE	notintel</span><br><span class="line">	MOVB	$1, runtime·isIntel(SB)</span><br><span class="line">	MOVB	$1, runtime·lfenceBeforeRdtsc(SB)</span><br><span class="line">notintel:</span><br><span class="line"></span><br><span class="line">	// Load EAX=1 cpuid flags</span><br><span class="line">	MOVL	$1, AX</span><br><span class="line">	CPUID</span><br><span class="line">	MOVL	AX, runtime·processorVersionInfo(SB)</span><br><span class="line"></span><br><span class="line">nocpuinfo:</span><br><span class="line">	// if there is an _cgo_init, call it.</span><br><span class="line">	MOVQ	_cgo_init(SB), AX</span><br><span class="line">	TESTQ	AX, AX</span><br><span class="line">	JZ	needtls</span><br><span class="line">	// arg 1: g0, already in DI</span><br><span class="line">	MOVQ	$setg_gcc&lt;&gt;(SB), SI // arg 2: setg_gcc</span><br><span class="line">#ifdef GOOS_android</span><br><span class="line">	MOVQ	$runtime·tls_g(SB), DX 	// arg 3: &amp;tls_g</span><br><span class="line">	// arg 4: TLS base, stored in slot 0 (Android&#x27;s TLS_SLOT_SELF).</span><br><span class="line">	// Compensate for tls_g (+16).</span><br><span class="line">	MOVQ	-16(TLS), CX</span><br><span class="line">#else</span><br><span class="line">	MOVQ	$0, DX	// arg 3, 4: not used when using platform&#x27;s TLS</span><br><span class="line">	MOVQ	$0, CX</span><br><span class="line">#endif</span><br><span class="line">#ifdef GOOS_windows</span><br><span class="line">	// Adjust for the Win64 calling convention.</span><br><span class="line">	MOVQ	CX, R9 // arg 4</span><br><span class="line">	MOVQ	DX, R8 // arg 3</span><br><span class="line">	MOVQ	SI, DX // arg 2</span><br><span class="line">	MOVQ	DI, CX // arg 1</span><br><span class="line">#endif</span><br><span class="line">	CALL	AX</span><br><span class="line"></span><br><span class="line">	// update stackguard after _cgo_init</span><br><span class="line">	MOVQ	$runtime·g0(SB), CX</span><br><span class="line">	MOVQ	(g_stack+stack_lo)(CX), AX</span><br><span class="line">	ADDQ	$const__StackGuard, AX</span><br><span class="line">	MOVQ	AX, g_stackguard0(CX)</span><br><span class="line">	MOVQ	AX, g_stackguard1(CX)</span><br><span class="line"></span><br><span class="line">/* 设置 TLS，部分 OS 直接跳过 */</span><br><span class="line">#ifndef GOOS_windows</span><br><span class="line">	JMP ok</span><br><span class="line">#endif</span><br><span class="line">needtls:</span><br><span class="line">#ifdef GOOS_plan9</span><br><span class="line">	// skip TLS setup on Plan 9</span><br><span class="line">	JMP ok</span><br><span class="line">#endif</span><br><span class="line">#ifdef GOOS_solaris</span><br><span class="line">	// skip TLS setup on Solaris</span><br><span class="line">	JMP ok</span><br><span class="line">#endif</span><br><span class="line">#ifdef GOOS_illumos</span><br><span class="line">	// skip TLS setup on illumos</span><br><span class="line">	JMP ok</span><br><span class="line">#endif</span><br><span class="line">#ifdef GOOS_darwin</span><br><span class="line">	// skip TLS setup on Darwin</span><br><span class="line">	JMP ok</span><br><span class="line">#endif</span><br><span class="line">#ifdef GOOS_openbsd</span><br><span class="line">	// skip TLS setup on OpenBSD</span><br><span class="line">	JMP ok</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">  /* DI = m0 的 m_tls 字段 DATA 地址 */</span><br><span class="line">	LEAQ	runtime·m0+m_tls(SB), DI</span><br><span class="line">	/* settls 函数在 sys_linux_amd64.s 内</span><br><span class="line">	 * 主要通过 arch_prctl 系统调用，将 m_tls 的地址设置到 FS 寄存器内</span><br><span class="line">	*/</span><br><span class="line">	CALL	runtime·settls(SB)</span><br><span class="line"></span><br><span class="line">	/* 检查 TLS 是否成功设置：</span><br><span class="line">   * get_tls(BX) 将当前 TLS 地址放入 BX （实际上是一个宏定义： #define	get_tls(r)	MOVQ TLS, r ）</span><br><span class="line">   * 将 0x123 立即数存入 TLS，再从 m_tls 地址读出，如果相等说明立即数已经正确存入</span><br><span class="line">  */</span><br><span class="line">	get_tls(BX)</span><br><span class="line">	MOVQ	$0x123, g(BX)</span><br><span class="line">	MOVQ	runtime·m0+m_tls(SB), AX</span><br><span class="line">	CMPQ	AX, $0x123</span><br><span class="line">	JEQ 2(PC)</span><br><span class="line">	CALL	runtime·abort(SB)</span><br><span class="line">	</span><br><span class="line">ok:</span><br><span class="line">	/* 绑定 m0 和 g0 */</span><br><span class="line">	get_tls(BX)</span><br><span class="line">	LEAQ	runtime·g0(SB), CX</span><br><span class="line">	MOVQ	CX, g(BX)</span><br><span class="line">	LEAQ	runtime·m0(SB), AX</span><br><span class="line"></span><br><span class="line">	// save m-&gt;g0 = g0</span><br><span class="line">	MOVQ	CX, m_g0(AX)</span><br><span class="line">	// save m0 to g0-&gt;m</span><br><span class="line">	MOVQ	AX, g_m(CX)</span><br><span class="line"></span><br><span class="line">	CLD				// convention is D is always left cleared</span><br><span class="line">	/* 类型检查，见 runtime1.go: check() */</span><br><span class="line">	CALL	runtime·check(SB)</span><br><span class="line"></span><br><span class="line">  /* SP = argc, SP + 8 = argv, SP 和 SP + 8 作为调用下层函数 args 的输入参数（函数参数可见 FP 伪寄存器） */</span><br><span class="line">	MOVL	16(SP), AX		// copy argc</span><br><span class="line">	MOVL	AX, 0(SP)</span><br><span class="line">	MOVQ	24(SP), AX		// copy argv</span><br><span class="line">	MOVQ	AX, 8(SP)</span><br><span class="line">	CALL	runtime·args(SB)</span><br><span class="line">	</span><br><span class="line">	/* osinit 主要用于设置 cpu 数量，见 runtime2.go: ncpu，以及设置物理页的 size */</span><br><span class="line">	CALL	runtime·osinit(SB)</span><br><span class="line">	</span><br><span class="line">	/* 调度器初始化，详细见下文 */</span><br><span class="line">	CALL	runtime·schedinit(SB)</span><br><span class="line"></span><br><span class="line">	/* 调用 proc.go: newproc(siz int32, fn *funcval) 创建 main goroutine */</span><br><span class="line">	MOVQ	$runtime·mainPC(SB), AX		// entry</span><br><span class="line">	PUSHQ	AX</span><br><span class="line">	PUSHQ	$0			// arg size</span><br><span class="line">	CALL	runtime·newproc(SB)</span><br><span class="line">	POPQ	AX</span><br><span class="line">	POPQ	AX</span><br><span class="line"></span><br><span class="line">	/* 启动 m0 */</span><br><span class="line">	CALL	runtime·mstart(SB)</span><br><span class="line"></span><br><span class="line">  /* mstart 不会返回，若返回则终止程序 */</span><br><span class="line">	CALL	runtime·abort(SB)	// mstart should never return</span><br><span class="line">	RET</span><br><span class="line"></span><br><span class="line">	// Prevent dead-code elimination of debugCallV2, which is</span><br><span class="line">	// intended to be called by debuggers.</span><br><span class="line">	MOVQ	$runtime·debugCallV2&lt;ABIInternal&gt;(SB), AX</span><br><span class="line">	RET</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**************** [proc.go] ****************/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">schedinit</span><span class="params">()</span></span> &#123;</span><br><span class="line">  </span><br><span class="line">  ... ...</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* getg() 由编译器替换为汇编指令，实际是从 TLS 中拿到当前 m 正在执行的 goroutine */</span></span><br><span class="line">	_g_ := getg()</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 初始化 race detector 的上下文（仅当开启竞争检测时） */</span></span><br><span class="line">	<span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">		_g_.racectx, raceprocctx0 = raceinit()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 调度器最多可以启动的 m 数量 */</span></span><br><span class="line">	sched.maxmcount = <span class="number">10000</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// The world starts stopped.</span></span><br><span class="line">	worldStopped()</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* moduledata 中存储的是与 tracing 相关的module、package、function、pc 等信息（存储在编译后的二进制文件内），如下是验证这些信息的有效性 */</span></span><br><span class="line">	moduledataverify()</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 初始化栈 </span></span><br><span class="line"><span class="comment">   * 有两个全局的栈内存池：</span></span><br><span class="line"><span class="comment">   * 1. stackpool：存放了全局的栈 mspan 链表，可用于分配小于 32KiB 的内存空间，定义见：_StackCacheSize = 32 * 1024</span></span><br><span class="line"><span class="comment">   * 2. stackLarger：分配大于 32KiB 的内存</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">	stackinit()</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 初始化堆 */</span></span><br><span class="line">	mallocinit()</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 生成随机数，将在下面的 mcommoninit() 中用到 */</span></span><br><span class="line">	fastrandinit() <span class="comment">// must run before mcommoninit</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 初始化 m0</span></span><br><span class="line"><span class="comment">   * 并为 m0 创建一个 gsignal goroutine 用于处理系统信号，m 中的 fastrand 即前面生成的</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">	mcommoninit(_g_.m, <span class="number">-1</span>)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 初始化 cpu，设置 cpu 扩展指令集 */</span></span><br><span class="line">	cpuinit()       <span class="comment">// must run before alginit</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 初始化 hash 种子 */</span></span><br><span class="line">	alginit()       <span class="comment">// maps must not be used before this call</span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">	modulesinit()   <span class="comment">// provides activeModules</span></span><br><span class="line">	typelinksinit() <span class="comment">// uses maps, activeModules</span></span><br><span class="line">	itabsinit()     <span class="comment">// uses activeModules</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 保存当前信号 mask */</span></span><br><span class="line">	sigsave(&amp;_g_.m.sigmask)</span><br><span class="line">	initSigmask = _g_.m.sigmask</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> offset := unsafe.Offsetof(sched.timeToRun); offset%<span class="number">8</span> != <span class="number">0</span> &#123;</span><br><span class="line">		<span class="built_in">println</span>(offset)</span><br><span class="line">		throw(<span class="string">&quot;sched.timeToRun not aligned to 8 bytes&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* argslice 中保存 argv，envs 中保存 env，解析 debug 参数 */</span></span><br><span class="line">	goargs()</span><br><span class="line">	goenvs()</span><br><span class="line">	parsedebugvars()</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 开启 GC */</span></span><br><span class="line">	gcinit()</span><br><span class="line"></span><br><span class="line">	lock(&amp;sched.lock)</span><br><span class="line">	sched.lastpoll = <span class="type">uint64</span>(nanotime())</span><br><span class="line">	procs := ncpu</span><br><span class="line">	<span class="keyword">if</span> n, ok := atoi32(gogetenv(<span class="string">&quot;GOMAXPROCS&quot;</span>)); ok &amp;&amp; n &gt; <span class="number">0</span> &#123;</span><br><span class="line">		procs = n</span><br><span class="line">	&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 按 GOMAXPROCS 的数量设置 p </span></span><br><span class="line"><span class="comment">   * 1. 主要是设置 allp slice，并初始化其中的每一个 p</span></span><br><span class="line"><span class="comment">   * 2. 绑定 m0 和 p0，p0 设置为 _Prunning，其他的 p 设置为 _Pidle</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">	<span class="keyword">if</span> procresize(procs) != <span class="literal">nil</span> &#123;</span><br><span class="line">		throw(<span class="string">&quot;unknown runnable goroutine during bootstrap&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	unlock(&amp;sched.lock)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// World is effectively started now, as P&#x27;s can run.</span></span><br><span class="line">	worldStarted()</span><br><span class="line"></span><br><span class="line">	... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**************** [runtime2.go] ****************/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> funcval <span class="keyword">struct</span> &#123;</span><br><span class="line">	fn <span class="type">uintptr</span></span><br><span class="line">	<span class="comment">// variable-size, fn-specific data here</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**************** [proc.go] ****************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//go:nosplit</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newproc</span><span class="params">(siz <span class="type">int32</span>, fn *funcval)</span></span> &#123;</span><br><span class="line">  <span class="comment">/* argp 指向 fn 函数的第一个参数 */</span></span><br><span class="line">	argp := add(unsafe.Pointer(&amp;fn), sys.PtrSize)</span><br><span class="line">	gp := getg()</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 这里的 caller pc，指向的就是 CALL	runtime·newproc(SB) 的下一行：POPQ AX */</span></span><br><span class="line">	pc := getcallerpc()</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* systemstack 先将调用者栈切换到 g0 栈，不过目前已经在 g0 栈了，因此什么也不做 */</span></span><br><span class="line">	systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">/* 构造一个新的 g 结构，见下文 */</span></span><br><span class="line">		newg := newproc1(fn, argp, siz, gp, pc)</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 目前是在 m0 执行，前文讲到 m0 绑定了 allp[0]，所以 _p_ 正是 allp[0] */</span></span><br><span class="line">		_p_ := getg().m.p.ptr()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 将 g 入队 */</span></span><br><span class="line">		runqput(_p_, newg, <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 目前还没有执行 main goroutine，因此 mainStarted == false */</span></span><br><span class="line">		<span class="keyword">if</span> mainStarted &#123;</span><br><span class="line">			wakep()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newproc1</span><span class="params">(fn *funcval, argp unsafe.Pointer, narg <span class="type">int32</span>, callergp *g, callerpc <span class="type">uintptr</span>)</span></span> *g &#123;</span><br><span class="line">	... ...</span><br><span class="line"></span><br><span class="line">	_g_ := getg()</span><br><span class="line"></span><br><span class="line">	... ...</span><br><span class="line">	</span><br><span class="line">	siz := narg</span><br><span class="line">	siz = (siz + <span class="number">7</span>) &amp;^ <span class="number">7</span></span><br><span class="line"></span><br><span class="line">	... ...</span><br><span class="line"></span><br><span class="line">	_p_ := _g_.m.p.ptr()</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 由于当前是在初始化第一个 goroutine，因此 gFreeList 没有空闲的 g 可用，需要创建 */</span></span><br><span class="line">	newg := gfget(_p_)</span><br><span class="line">	<span class="keyword">if</span> newg == <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">/* _StackMin = 2048，因此创建一个新的 g，其栈空间为 2M */</span></span><br><span class="line">		newg = malg(_StackMin)</span><br><span class="line">		casgstatus(newg, _Gidle, _Gdead)</span><br><span class="line">		allgadd(newg) <span class="comment">// publishes with a g-&gt;status of Gdead so GC scanner doesn&#x27;t look at uninitialized stack.</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">  ... ...</span><br><span class="line"></span><br><span class="line">	totalSize := <span class="number">4</span>*sys.PtrSize + <span class="type">uintptr</span>(siz) + sys.MinFrameSize <span class="comment">// extra space in case of reads slightly beyond frame</span></span><br><span class="line">	totalSize += -totalSize &amp; (sys.StackAlign - <span class="number">1</span>)               <span class="comment">// align to StackAlign</span></span><br><span class="line">	sp := newg.stack.hi - totalSize</span><br><span class="line">	spArg := sp</span><br><span class="line">	</span><br><span class="line">  ... ...</span><br><span class="line">  </span><br><span class="line">	<span class="keyword">if</span> narg &gt; <span class="number">0</span> &#123;</span><br><span class="line">    <span class="comment">/* 创建 g 之前，fn 的参数是放在 caller 的栈上的，memmove 将其 copy 到 newg 的栈上 */</span></span><br><span class="line">		memmove(unsafe.Pointer(spArg), argp, <span class="type">uintptr</span>(narg))</span><br><span class="line">		<span class="comment">// This is a stack-to-stack copy. If write barriers</span></span><br><span class="line">		<span class="comment">// are enabled and the source stack is grey (the</span></span><br><span class="line">		<span class="comment">// destination is always black), then perform a</span></span><br><span class="line">		<span class="comment">// barrier copy. We do this *after* the memmove</span></span><br><span class="line">		<span class="comment">// because the destination stack may have garbage on</span></span><br><span class="line">		<span class="comment">// it.</span></span><br><span class="line">		<span class="keyword">if</span> writeBarrier.needed &amp;&amp; !_g_.m.curg.gcscandone &#123;</span><br><span class="line">			f := findfunc(fn.fn)</span><br><span class="line">			stkmap := (*stackmap)(funcdata(f, _FUNCDATA_ArgsPointerMaps))</span><br><span class="line">			<span class="keyword">if</span> stkmap.nbit &gt; <span class="number">0</span> &#123;</span><br><span class="line">				<span class="comment">// We&#x27;re in the prologue, so it&#x27;s always stack map index 0.</span></span><br><span class="line">				bv := stackmapdata(stkmap, <span class="number">0</span>)</span><br><span class="line">				bulkBarrierBitmap(spArg, spArg, <span class="type">uintptr</span>(bv.n)*sys.PtrSize, <span class="number">0</span>, bv.bytedata)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 将 newg 的 sp pc 等信息保存在 gobuf 中，待实际被调度时，就会被加载出来执行</span></span><br><span class="line"><span class="comment">   * 这里的 pc 存放的是 goexit + 1 的地址，这是为了让 fn 执行完毕后，跳到 goexit 来做一些退出工作，详见下文</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">	memclrNoHeapPointers(unsafe.Pointer(&amp;newg.sched), unsafe.Sizeof(newg.sched))</span><br><span class="line">	newg.sched.sp = sp</span><br><span class="line">	newg.stktopsp = sp</span><br><span class="line">	newg.sched.pc = abi.FuncPCABI0(goexit) + sys.PCQuantum <span class="comment">// +PCQuantum so that previous instruction is in same function</span></span><br><span class="line">	newg.sched.g = guintptr(unsafe.Pointer(newg))</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 深入到 gostartcallfn 函数内我们就可以看到：</span></span><br><span class="line"><span class="comment">   * 该函数在 newg 的 sp 栈顶申请了一个 ptr 的位置，将 goexit 地址保存进去，然后让 sched.sp = sp-1，并将 sched.pc = fn，</span></span><br><span class="line"><span class="comment">   * 这实际上相当于 fake 了 fn 是由 goexit 调用的，当 fn 执行完毕后 pc 会被恢复为 goexit+1 的地址，并执行 goexit。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">	gostartcallfn(&amp;newg.sched, fn)</span><br><span class="line">	newg.gopc = callerpc</span><br><span class="line">	newg.ancestors = saveAncestors(callergp)</span><br><span class="line">	newg.startpc = fn.fn</span><br><span class="line">	</span><br><span class="line">  ... ...</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 修改状态为 _Grunnable，代表可以被运行了 */</span></span><br><span class="line">	casgstatus(newg, _Gdead, _Grunnable)</span><br><span class="line"></span><br><span class="line">	... ...</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 至此 main goroutine 的 g 就创建好了，返回后会进入队，并等待在 mstart 时被调度 */</span></span><br><span class="line">	<span class="keyword">return</span> newg</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/**************** [asm_amd64.s] ****************/</span><br><span class="line"></span><br><span class="line">TEXT runtime·mstart(SB),NOSPLIT|TOPFRAME,$0</span><br><span class="line">	CALL	runtime·mstart0(SB)</span><br><span class="line">	RET // not reached</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**************** [proc.go] ****************/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mstart0</span><span class="params">()</span></span> &#123;</span><br><span class="line">	_g_ := getg()</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 显然目前 _g_ == g0，所以不需要再初始化栈了 */</span></span><br><span class="line">	osStack := _g_.stack.lo == <span class="number">0</span></span><br><span class="line">	<span class="keyword">if</span> osStack &#123;</span><br><span class="line">		<span class="comment">// Initialize stack bounds from system stack.</span></span><br><span class="line">		<span class="comment">// Cgo may have left stack size in stack.hi.</span></span><br><span class="line">		<span class="comment">// minit may update the stack bounds.</span></span><br><span class="line">		<span class="comment">//</span></span><br><span class="line">		<span class="comment">// Note: these bounds may not be very accurate.</span></span><br><span class="line">		<span class="comment">// We set hi to &amp;size, but there are things above</span></span><br><span class="line">		<span class="comment">// it. The 1024 is supposed to compensate this,</span></span><br><span class="line">		<span class="comment">// but is somewhat arbitrary.</span></span><br><span class="line">		size := _g_.stack.hi</span><br><span class="line">		<span class="keyword">if</span> size == <span class="number">0</span> &#123;</span><br><span class="line">			size = <span class="number">8192</span> * sys.StackGuardMultiplier</span><br><span class="line">		&#125;</span><br><span class="line">		_g_.stack.hi = <span class="type">uintptr</span>(noescape(unsafe.Pointer(&amp;size)))</span><br><span class="line">		_g_.stack.lo = _g_.stack.hi - size + <span class="number">1024</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Initialize stack guard so that we can start calling regular</span></span><br><span class="line">	<span class="comment">// Go code.</span></span><br><span class="line">	_g_.stackguard0 = _g_.stack.lo + _StackGuard</span><br><span class="line">	<span class="comment">// This is the g0, so we can also call go:systemstack</span></span><br><span class="line">	<span class="comment">// functions, which check stackguard1.</span></span><br><span class="line">	_g_.stackguard1 = _g_.stackguard0</span><br><span class="line">	</span><br><span class="line">  <span class="comment">/* 实际执行的部分，见下文 */</span></span><br><span class="line">  mstart1()</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 若执行到这里，就说明主程序要结束了 */</span></span><br><span class="line">	<span class="comment">// Exit this thread.</span></span><br><span class="line">	<span class="keyword">if</span> mStackIsSystemAllocated() &#123;</span><br><span class="line">		<span class="comment">// Windows, Solaris, illumos, Darwin, AIX and Plan 9 always system-allocate</span></span><br><span class="line">		<span class="comment">// the stack, but put it in _g_.stack before mstart,</span></span><br><span class="line">		<span class="comment">// so the logic above hasn&#x27;t set osStack yet.</span></span><br><span class="line">		osStack = <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">	mexit(osStack)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mstart1</span><span class="params">()</span></span> &#123;</span><br><span class="line">	_g_ := getg()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> _g_ != _g_.m.g0 &#123;</span><br><span class="line">		throw(<span class="string">&quot;bad runtime·mstart&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 这里将 g0 goroutine 的调度上下文设置为跳转到前面 mstart1() 的下一句，意味着跳转后程序会结束*/</span></span><br><span class="line">	<span class="comment">// Set up m.g0.sched as a label returning to just</span></span><br><span class="line">	<span class="comment">// after the mstart1 call in mstart0 above, for use by goexit0 and mcall.</span></span><br><span class="line">	<span class="comment">// We&#x27;re never coming back to mstart1 after we call schedule,</span></span><br><span class="line">	<span class="comment">// so other calls can reuse the current frame.</span></span><br><span class="line">	<span class="comment">// And goexit0 does a gogo that needs to return from mstart1</span></span><br><span class="line">	<span class="comment">// and let mstart0 exit the thread.</span></span><br><span class="line">	_g_.sched.g = guintptr(unsafe.Pointer(_g_))</span><br><span class="line">	_g_.sched.pc = getcallerpc()</span><br><span class="line">	_g_.sched.sp = getcallersp()</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* amd64 架构下是空函数 */</span></span><br><span class="line">	asminit()</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 执行一些信号的初始化，mstartm0() 也一样 */</span></span><br><span class="line">	minit()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Install signal handlers; after minit so that minit can</span></span><br><span class="line">	<span class="comment">// prepare the thread to be able to handle the signals.</span></span><br><span class="line">	<span class="keyword">if</span> _g_.m == &amp;m0 &#123;</span><br><span class="line">		mstartm0()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 执行创建 m 时传入的函数，m0 没有，所以 fn == nil */</span></span><br><span class="line">	<span class="keyword">if</span> fn := _g_.m.mstartfn; fn != <span class="literal">nil</span> &#123;</span><br><span class="line">		fn()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> _g_.m != &amp;m0 &#123;</span><br><span class="line">		acquirep(_g_.m.nextp.ptr())</span><br><span class="line">		_g_.m.nextp = <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 开始调度，经过一系列操作后，main goroutine 会被调度到 m0 上 */</span></span><br><span class="line">	schedule()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在看 <code>schedule()</code> 之前，我们先跳到 main goroutine 的 main
function 看一看：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**************** [proc.go] ****************/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	g := getg()</span><br><span class="line">	</span><br><span class="line">  ... ...</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 我们在前面 newproc 中看到了，当 mainStarted == true 时，newproc 就可以尝试创建新的 m 来执行 g 了 */</span></span><br><span class="line">	<span class="comment">// Allow newproc to start new Ms.</span></span><br><span class="line">	mainStarted = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* monitor 线程 */</span></span><br><span class="line">	<span class="keyword">if</span> GOARCH != <span class="string">&quot;wasm&quot;</span> &#123; <span class="comment">// no threads on wasm yet, so no sysmon</span></span><br><span class="line">		<span class="comment">// For runtime_syscall_doAllThreadsSyscall, we</span></span><br><span class="line">		<span class="comment">// register sysmon is not ready for the world to be</span></span><br><span class="line">		<span class="comment">// stopped.</span></span><br><span class="line">		atomic.Store(&amp;sched.sysmonStarting, <span class="number">1</span>)</span><br><span class="line">		systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			newm(sysmon, <span class="literal">nil</span>, <span class="number">-1</span>)</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	... ...</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 执行依赖中的 init() */</span></span><br><span class="line">	doInit(&amp;runtime_inittask) <span class="comment">// Must be before defer.</span></span><br><span class="line"></span><br><span class="line">	... ...</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 启用 gc */</span></span><br><span class="line">	gcenable()</span><br><span class="line"></span><br><span class="line">	main_init_done = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>)</span><br><span class="line">  ... ...</span><br><span class="line">  <span class="comment">/* 执行用户 main.go 中的 init() */</span></span><br><span class="line">	doInit(&amp;main_inittask)</span><br><span class="line">	... ...</span><br><span class="line">	<span class="built_in">close</span>(main_init_done)</span><br><span class="line"></span><br><span class="line">	needUnlock = <span class="literal">false</span></span><br><span class="line">	unlockOSThread()</span><br><span class="line"></span><br><span class="line">	... ...</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 这里开始调用用户代码中的 main()，正式执行到用户代码 */</span></span><br><span class="line">	fn := main_main <span class="comment">// make an indirect call, as the linker doesn&#x27;t know the address of the main package when laying down the runtime</span></span><br><span class="line">	fn()</span><br><span class="line"></span><br><span class="line">	... ...</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 显然当用户的 main() 执行完毕后，程序自然就可以退出了 */</span></span><br><span class="line">	exit(<span class="number">0</span>)</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">var</span> x *<span class="type">int32</span></span><br><span class="line">		*x = <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**************** [proc.go] ****************/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">schedule</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">/* 如果是从 mstart0 而来，则当前拿到的是 g0 */</span></span><br><span class="line">	_g_ := getg()</span><br><span class="line"></span><br><span class="line">	... ...</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 假如 g 所在的 m 锁定了固定运行的 goroutine，则暂停当前 m，将 m 上的 p 转移到其他 m，再运行锁定的 g*/</span></span><br><span class="line">	<span class="keyword">if</span> _g_.m.lockedg != <span class="number">0</span> &#123;</span><br><span class="line">		stoplockedm()</span><br><span class="line">		execute(_g_.m.lockedg.ptr(), <span class="literal">false</span>) <span class="comment">// Never returns.</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	... ...</span><br><span class="line"></span><br><span class="line">top:</span><br><span class="line">  <span class="comment">/* preempt == true 代表 p 需要立即进入调度，目前已经在 scheduler() 内，因此清零它 */</span></span><br><span class="line">	pp := _g_.m.p.ptr()</span><br><span class="line">	pp.preempt = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 如果当前有 GC 在等待，则先 GC，再执行调度 */</span></span><br><span class="line">	<span class="keyword">if</span> sched.gcwaiting != <span class="number">0</span> &#123;</span><br><span class="line">    <span class="comment">/* 停止当前 m，执行 GC，阻塞等待直到被唤醒，之后跳转 top，重新开始调度 */</span></span><br><span class="line">    gcstopm()</span><br><span class="line">		<span class="keyword">goto</span> top</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">  ... ...</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* gp 就是即将被选出的 g */</span></span><br><span class="line">	<span class="keyword">var</span> gp *g</span><br><span class="line">	<span class="keyword">var</span> inheritTime <span class="type">bool</span></span><br><span class="line"></span><br><span class="line">	... ...</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 为了保证公平性，当前 p 的 schedtick（每一次调度循环都 +1） 等于 61 时，强制从全局队列中拿一个 g 出来，否则如果有两个 goroutine 互相创建对方，他们就会永远占有当前 p */</span></span><br><span class="line">	<span class="keyword">if</span> gp == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// Check the global runnable queue once in a while to ensure fairness.</span></span><br><span class="line">		<span class="comment">// Otherwise two goroutines can completely occupy the local runqueue</span></span><br><span class="line">		<span class="comment">// by constantly respawning each other.</span></span><br><span class="line">		<span class="keyword">if</span> _g_.m.p.ptr().schedtick%<span class="number">61</span> == <span class="number">0</span> &amp;&amp; sched.runqsize &gt; <span class="number">0</span> &#123;</span><br><span class="line">			lock(&amp;sched.lock)</span><br><span class="line">			gp = globrunqget(_g_.m.p.ptr(), <span class="number">1</span>)</span><br><span class="line">			unlock(&amp;sched.lock)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 如果 schedtick没到 61，或者全局队列也没有 g 了，就尝试从本地 runq 中获取 g */</span></span><br><span class="line">	<span class="keyword">if</span> gp == <span class="literal">nil</span> &#123;</span><br><span class="line">		gp, inheritTime = runqget(_g_.m.p.ptr())</span><br><span class="line">		<span class="comment">// We can see gp != nil here even if the M is spinning,</span></span><br><span class="line">		<span class="comment">// if checkTimers added a local goroutine via goready.</span></span><br><span class="line">	&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 如果本地 runq 里也没有 g 了，就需要通过 findrunnable() 阻塞获取 g（可能会从其他 p 的 runq 中进行工作窃取） </span></span><br><span class="line"><span class="comment">   * findrunnable 会：</span></span><br><span class="line"><span class="comment">   * 1. 再次尝试：是否需要 gc、是否存在 finalizers g、cgo、本地 runq、全局队列等等</span></span><br><span class="line"><span class="comment">   * 2. 从 netpoll 中查找是否存在等待完成的 g</span></span><br><span class="line"><span class="comment">   * 3. 尝试工作窃取</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">	<span class="keyword">if</span> gp == <span class="literal">nil</span> &#123;</span><br><span class="line">		gp, inheritTime = findrunnable() <span class="comment">// blocks until work is available</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// This thread is going to run a goroutine and is not spinning anymore,</span></span><br><span class="line">	<span class="comment">// so if it was marked as spinning we need to reset it now and potentially</span></span><br><span class="line">	<span class="comment">// start a new spinning M.</span></span><br><span class="line">	<span class="keyword">if</span> _g_.m.spinning &#123;</span><br><span class="line">		resetspinning()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	... ...</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 如果拿到的 g 要求必须在锁定的 m 上执行，则将之交给锁定的 m 去执行，并再次进入调度循环 */</span></span><br><span class="line">	<span class="keyword">if</span> gp.lockedm != <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// Hands off own p to the locked m,</span></span><br><span class="line">		<span class="comment">// then blocks waiting for a new p.</span></span><br><span class="line">		startlockedm(gp)</span><br><span class="line">		<span class="keyword">goto</span> top</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 一切就绪，准备开始调度被选中的 g 了 */</span></span><br><span class="line">	execute(gp, inheritTime)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">execute</span><span class="params">(gp *g, inheritTime <span class="type">bool</span>)</span></span> &#123;</span><br><span class="line">	_g_ := getg()</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 将被调度的 g 与当前 m 绑定 */</span></span><br><span class="line">	<span class="comment">// Assign gp.m before entering _Grunning so running Gs have an</span></span><br><span class="line">	<span class="comment">// M.</span></span><br><span class="line">	_g_.m.curg = gp</span><br><span class="line">	gp.m = _g_.m</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 将状态改为 _Grunning */</span></span><br><span class="line">	casgstatus(gp, _Grunnable, _Grunning)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* waitsince 是当前 g 被阻塞的估计时间，preempt 指示是否被抢占，重置 stackguard0 */</span></span><br><span class="line">	gp.waitsince = <span class="number">0</span></span><br><span class="line">	gp.preempt = <span class="literal">false</span></span><br><span class="line">	gp.stackguard0 = gp.stack.lo + _StackGuard</span><br><span class="line">	</span><br><span class="line">  ... ...</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 传入 gobuf，跳转到汇编代码 */</span></span><br><span class="line">	gogo(&amp;gp.sched)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">/**************** [asm_amd64.s] ****************/</span><br><span class="line"></span><br><span class="line">TEXT runtime·gogo(SB), NOSPLIT, $0-8</span><br><span class="line">	MOVQ	buf+0(FP), BX		// gobuf</span><br><span class="line">	MOVQ	gobuf_g(BX), DX</span><br><span class="line">	MOVQ	0(DX), CX		// make sure g != nil</span><br><span class="line">	JMP	gogo&lt;&gt;(SB)</span><br><span class="line"></span><br><span class="line">TEXT gogo&lt;&gt;(SB), NOSPLIT, $0</span><br><span class="line">	get_tls(CX)</span><br><span class="line">	</span><br><span class="line">	/* 恢复现场第一步：用 gobuf 中的 g，覆盖 tls 中的 g，并放入 R14 */</span><br><span class="line">	MOVQ	DX, g(CX)</span><br><span class="line">	MOVQ	DX, R14		// set the g register</span><br><span class="line">	</span><br><span class="line">	/* 恢复现场第二步：用 gobuf 中的 sp 覆盖 SP，切换到 gp 的栈 */</span><br><span class="line">	MOVQ	gobuf_sp(BX), SP	// restore SP</span><br><span class="line">	</span><br><span class="line">	/* 恢复现场第三步：用 gobuf 中的 ret 地址覆盖 AX（amd64 下通用返回地址放在 AX） */</span><br><span class="line">	MOVQ	gobuf_ret(BX), AX</span><br><span class="line">	</span><br><span class="line">	/* 恢复现场第四步：用 gobuf 中的 ctxt(函数调用 traceback 的上下文寄存器) 地址覆盖 DX */</span><br><span class="line">	MOVQ	gobuf_ctxt(BX), DX</span><br><span class="line">	</span><br><span class="line">	/* 恢复现场第五步：用 gobuf 中的 bp 覆盖 BP */</span><br><span class="line">	MOVQ	gobuf_bp(BX), BP</span><br><span class="line">	</span><br><span class="line">	/* 清空前面用过的 gobuf 值 */</span><br><span class="line">	MOVQ	$0, gobuf_sp(BX)	// clear to help garbage collector</span><br><span class="line">	MOVQ	$0, gobuf_ret(BX)</span><br><span class="line">	MOVQ	$0, gobuf_ctxt(BX)</span><br><span class="line">	MOVQ	$0, gobuf_bp(BX)</span><br><span class="line">	</span><br><span class="line">	/* 最后将 gobuf 中保存的 pc 写入 BX，并直接跳到 BX 处开始执行 */</span><br><span class="line">	MOVQ	gobuf_pc(BX), BX</span><br><span class="line">	JMP	BX</span><br></pre></td></tr></table></figure>
<p>最后关注一下 goroutine 执行结束后的操作：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/**************** [asm_amd64.s] ****************/</span><br><span class="line"></span><br><span class="line">/* 本函数是在 newproc 的时候设置的 gobuf 的默认 pc，用于在 goroutine 执行结束后作为伪造调用方而跳转的 */</span><br><span class="line">// The top-most function running on a goroutine</span><br><span class="line">// returns to goexit+PCQuantum.</span><br><span class="line">TEXT runtime·goexit(SB),NOSPLIT|NOFRAME|TOPFRAME,$0-0</span><br><span class="line">	MOVD	R0, R0	// NOP</span><br><span class="line">	BL	runtime·goexit1(SB)	// does not return</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**************** [proc.go] ****************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Finishes execution of the current goroutine.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">goexit1</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">		racegoend()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> trace.enabled &#123;</span><br><span class="line">		traceGoEnd()</span><br><span class="line">	&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* mcall 专用做将当前执行栈切换为 g0（</span></span><br><span class="line"><span class="comment">   * 1. 将当前 g 的 pc、sp、bp 等保存在 gobuf</span></span><br><span class="line"><span class="comment">   * 2. 通过当前 g 的 m 找到 g0，切换 sp 为 g0 的sp，完成栈切换</span></span><br><span class="line"><span class="comment">   * 3. 调用 mcall 的传入函数 goexit0，并将切换前的 g 传入 goexit0</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">	mcall(goexit0)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">goexit0</span><span class="params">(gp *g)</span></span> &#123;</span><br><span class="line">  <span class="comment">/* 这里 _g_ == g0 */</span></span><br><span class="line">	_g_ := getg()</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 将原 g 状态设置为 _Gdead */</span></span><br><span class="line">	casgstatus(gp, _Grunning, _Gdead)</span><br><span class="line"></span><br><span class="line">  ... ...</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 做一些原 g 的清理工作 */</span></span><br><span class="line">	gp.m = <span class="literal">nil</span></span><br><span class="line">	locked := gp.lockedm != <span class="number">0</span></span><br><span class="line">	gp.lockedm = <span class="number">0</span></span><br><span class="line">	_g_.m.lockedg = <span class="number">0</span></span><br><span class="line">	gp.preemptStop = <span class="literal">false</span></span><br><span class="line">	gp.paniconfault = <span class="literal">false</span></span><br><span class="line">	gp._defer = <span class="literal">nil</span> <span class="comment">// should be true already but just in case.</span></span><br><span class="line">	gp._panic = <span class="literal">nil</span> <span class="comment">// non-nil for Goexit during panic. points at stack-allocated data.</span></span><br><span class="line">	gp.writebuf = <span class="literal">nil</span></span><br><span class="line">	gp.waitreason = <span class="number">0</span></span><br><span class="line">	gp.param = <span class="literal">nil</span></span><br><span class="line">	gp.labels = <span class="literal">nil</span></span><br><span class="line">	gp.timer = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">	... ...</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 将 m 与 curg 的关联断开*/</span></span><br><span class="line">	dropg()</span><br><span class="line"></span><br><span class="line">	... ...</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 原 g 执行完了，将其剩余的部分放入 gfree list，以便复用 */</span></span><br><span class="line">	gfput(_g_.m.p.ptr(), gp)</span><br><span class="line">	</span><br><span class="line">  ... ...</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 重新进入调度循环 */</span></span><br><span class="line">	schedule()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="m-系统线程操作">2. M 系统线程操作</h3>
<p>m 是作为程序的实际执行载体，首先看看创建 m：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**************** [proc.go] ****************/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newm</span><span class="params">(fn <span class="keyword">func</span>()</span></span>, _p_ *p, id <span class="type">int64</span>) &#123;</span><br><span class="line">  <span class="comment">/* 创建 m 结构 */</span></span><br><span class="line">	mp := allocm(_p_, fn, id)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 执行 p 的 m 可以 park；设置 nextp 为 _p_；设置 sigmask */</span></span><br><span class="line">	mp.doesPark = (_p_ != <span class="literal">nil</span>)</span><br><span class="line">	mp.nextp.set(_p_)</span><br><span class="line">	mp.sigmask = initSigmask</span><br><span class="line">	</span><br><span class="line">  ... ...</span><br><span class="line">	</span><br><span class="line">  <span class="comment">/* 创建系统线程 */</span></span><br><span class="line">  newm1(mp)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">allocm</span><span class="params">(_p_ *p, fn <span class="keyword">func</span>()</span></span>, id <span class="type">int64</span>) *m &#123;</span><br><span class="line">	_g_ := getg()</span><br><span class="line">	acquirem() <span class="comment">// disable GC because it can be called from sysmon</span></span><br><span class="line">	<span class="keyword">if</span> _g_.m.p == <span class="number">0</span> &#123;</span><br><span class="line">		acquirep(_p_) <span class="comment">// temporarily borrow p for mallocs in this function</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	... ...</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 初始化 m 结构*/</span></span><br><span class="line">	mp := <span class="built_in">new</span>(m)</span><br><span class="line">	mp.mstartfn = fn</span><br><span class="line">	mcommoninit(mp, id)</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 每个 m 都有自己的 g0，初始化 g0 */</span></span><br><span class="line">	<span class="comment">// In case of cgo or Solaris or illumos or Darwin, pthread_create will make us a stack.</span></span><br><span class="line">	<span class="comment">// Windows and Plan 9 will layout sched stack on OS stack.</span></span><br><span class="line">	<span class="keyword">if</span> iscgo || mStackIsSystemAllocated() &#123;</span><br><span class="line">		mp.g0 = malg(<span class="number">-1</span>)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		mp.g0 = malg(<span class="number">8192</span> * sys.StackGuardMultiplier)</span><br><span class="line">	&#125;</span><br><span class="line">	mp.g0.m = mp</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> _p_ == _g_.m.p.ptr() &#123;</span><br><span class="line">		releasep()</span><br><span class="line">	&#125;</span><br><span class="line">	releasem(_g_.m)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> mp</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newm1</span><span class="params">(mp *m)</span></span> &#123;</span><br><span class="line">	... ...</span><br><span class="line">	execLock.rlock() <span class="comment">// Prevent process clone.</span></span><br><span class="line">  <span class="comment">/* 根据不同操作系统，按照实际系统创建系统线程 */</span></span><br><span class="line">	newosproc(mp)</span><br><span class="line">	execLock.runlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**************** [os_linux.go] ****************/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newosproc</span><span class="params">(mp *m)</span></span> &#123;</span><br><span class="line">	stk := unsafe.Pointer(mp.g0.stack.hi)</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * note: strace gets confused if we use CLONE_PTRACE here.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> <span class="literal">false</span> &#123;</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;newosproc stk=&quot;</span>, stk, <span class="string">&quot; m=&quot;</span>, mp, <span class="string">&quot; g=&quot;</span>, mp.g0, <span class="string">&quot; clone=&quot;</span>, funcPC(clone), <span class="string">&quot; id=&quot;</span>, mp.id, <span class="string">&quot; ostk=&quot;</span>, &amp;mp, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Disable signals during clone, so that the new thread starts</span></span><br><span class="line">	<span class="comment">// with signals disabled. It will enable them in minit.</span></span><br><span class="line">	<span class="keyword">var</span> oset sigset</span><br><span class="line">	sigprocmask(_SIG_SETMASK, &amp;sigset_all, &amp;oset)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 通过系统调用 clone 创建 linux 线程 */</span></span><br><span class="line">	ret := clone(cloneFlags, stk, unsafe.Pointer(mp), unsafe.Pointer(mp.g0), unsafe.Pointer(funcPC(mstart)))</span><br><span class="line">	</span><br><span class="line">  sigprocmask(_SIG_SETMASK, &amp;oset, <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ret &lt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;runtime: failed to create new OS thread (have &quot;</span>, mcount(), <span class="string">&quot; already; errno=&quot;</span>, -ret, <span class="string">&quot;)\n&quot;</span>)</span><br><span class="line">		<span class="keyword">if</span> ret == -_EAGAIN &#123;</span><br><span class="line">			<span class="built_in">println</span>(<span class="string">&quot;runtime: may need to increase max user processes (ulimit -u)&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		throw(<span class="string">&quot;newosproc&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">/**************** [sys_linux_amd64.s] ****************/</span><br><span class="line"></span><br><span class="line">// int32 clone(int32 flags, void *stk, M *mp, G *gp, void (*fn)(void));</span><br><span class="line">TEXT runtime·clone(SB),NOSPLIT,$0</span><br><span class="line">  /* 在 os_linux.go 中可以查到传入的 flags：*/</span><br><span class="line">    cloneFlags = _CLONE_VM | /* share memory */</span><br><span class="line">		_CLONE_FS | /* share cwd, etc */</span><br><span class="line">		_CLONE_FILES | /* share fd table */</span><br><span class="line">		_CLONE_SIGHAND | /* share sig handler table */</span><br><span class="line">		_CLONE_SYSVSEM | /* share SysV semaphore undo lists (see issue #20763) */</span><br><span class="line">		_CLONE_THREAD /* revisit - okay for now */</span><br><span class="line">  /* 更多详情：https://man7.org/linux/man-pages/man2/clone.2.html */</span><br><span class="line">	MOVL	flags+0(FP), DI</span><br><span class="line">	</span><br><span class="line">	/* 这里传入的是 g0 的 stack.hi */</span><br><span class="line">	MOVQ	stk+8(FP), SI</span><br><span class="line">	MOVQ	$0, DX</span><br><span class="line">	MOVQ	$0, R10</span><br><span class="line">	MOVQ    $0, R8</span><br><span class="line">	</span><br><span class="line">	/* mp gp fn 等结构原本是在父线程栈内创建的，需要 copy 到新线程栈内 */</span><br><span class="line">	// Copy mp, gp, fn off parent stack for use by child.</span><br><span class="line">	// Careful: Linux system call clobbers CX and R11.</span><br><span class="line">	MOVQ	mp+16(FP), R13</span><br><span class="line">	MOVQ	gp+24(FP), R9</span><br><span class="line">	MOVQ	fn+32(FP), R12</span><br><span class="line">	CMPQ	R13, $0    // m</span><br><span class="line">	JEQ	nog1</span><br><span class="line">	CMPQ	R9, $0    // g</span><br><span class="line">	JEQ	nog1</span><br><span class="line">	</span><br><span class="line">	/* 前面 m、g 都不为 0，因此保存 m_tls 到 R8 */</span><br><span class="line">	LEAQ	m_tls(R13), R8</span><br><span class="line">#ifdef GOOS_android</span><br><span class="line">	// Android stores the TLS offset in runtime·tls_g.</span><br><span class="line">	SUBQ	runtime·tls_g(SB), R8</span><br><span class="line">#else</span><br><span class="line">	ADDQ	$8, R8	// ELF wants to use -8(FS)</span><br><span class="line">#endif</span><br><span class="line">	ORQ 	$0x00080000, DI //add flag CLONE_SETTLS(0x00080000) to call clone</span><br><span class="line">nog1:</span><br><span class="line">  /* call clone 系统调用 */</span><br><span class="line">	MOVL	$SYS_clone, AX</span><br><span class="line">	SYSCALL</span><br><span class="line"></span><br><span class="line">  /* 由于 clone 创建了新的线程空间，对于子线程，返回值 AX = 0 代表创建成功，对于父线程，返回值 AX 放入的是子线程 pid */</span><br><span class="line">	// In parent, return.</span><br><span class="line">	CMPQ	AX, $0</span><br><span class="line">	JEQ	3(PC)</span><br><span class="line">	</span><br><span class="line">	/* 这里是父线程，copy pid 到栈上，直接返回 */</span><br><span class="line">	MOVL	AX, ret+40(FP)</span><br><span class="line">	RET</span><br><span class="line"></span><br><span class="line">  /* 这里是子线程，先恢复 g0 栈 */</span><br><span class="line">	// In child, on new stack.</span><br><span class="line">	MOVQ	SI, SP</span><br><span class="line"></span><br><span class="line">	// If g or m are nil, skip Go-related setup.</span><br><span class="line">	CMPQ	R13, $0    // m</span><br><span class="line">	JEQ	nog2</span><br><span class="line">	CMPQ	R9, $0    // g</span><br><span class="line">	JEQ	nog2</span><br><span class="line"></span><br><span class="line">  /* 获取当前线程 id，放入 m_procid */</span><br><span class="line">	// Initialize m-&gt;procid to Linux tid</span><br><span class="line">	MOVL	$SYS_gettid, AX</span><br><span class="line">	SYSCALL</span><br><span class="line">	MOVQ	AX, m_procid(R13)</span><br><span class="line"></span><br><span class="line">  /* 恢复 m，g */</span><br><span class="line">	// In child, set up new stack</span><br><span class="line">	get_tls(CX)</span><br><span class="line">	MOVQ	R13, g_m(R9)</span><br><span class="line">	MOVQ	R9, g(CX)</span><br><span class="line">	MOVQ	R9, R14 // set g register</span><br><span class="line">	CALL	runtime·stackcheck(SB)</span><br><span class="line"></span><br><span class="line">nog2:</span><br><span class="line">  /* 执行传入的 fn，根据 newosproc，这里执行的是 mstart，这里又回到了启动时候的路径，mstart 的终点，就是 schedule() */</span><br><span class="line">	// Call fn. This is the PC of an ABI0 function.</span><br><span class="line">	CALL	R12</span><br><span class="line"></span><br><span class="line">  /* 正常情况下 schdule() 是永远不返回的，如果返回了，就关闭当前线程 */</span><br><span class="line">	// It shouldn&#x27;t return. If it does, exit that thread.</span><br><span class="line">	MOVL	$111, DI</span><br><span class="line">	MOVL	$SYS_exit, AX</span><br><span class="line">	SYSCALL</span><br><span class="line">	JMP	-3(PC)	// keep exiting</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**************** [proc.go] ****************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* startm 用于将传入的 _p_ 放到 m 上执行 */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">startm</span><span class="params">(_p_ *p, spinning <span class="type">bool</span>)</span></span> &#123;</span><br><span class="line">  <span class="comment">/* 先给当前 m 加锁，若传入的 _p_ 为 nil 则从 pidle 中获取空闲的 p，没有空闲的 p 则退出 */</span></span><br><span class="line">	mp := acquirem()</span><br><span class="line">	lock(&amp;sched.lock)</span><br><span class="line">	<span class="keyword">if</span> _p_ == <span class="literal">nil</span> &#123;</span><br><span class="line">		_p_ = pidleget()</span><br><span class="line">		<span class="keyword">if</span> _p_ == <span class="literal">nil</span> &#123;</span><br><span class="line">			unlock(&amp;sched.lock)</span><br><span class="line">			<span class="keyword">if</span> spinning &#123;</span><br><span class="line">				<span class="comment">// The caller incremented nmspinning, but there are no idle Ps,</span></span><br><span class="line">				<span class="comment">// so it&#x27;s okay to just undo the increment and give up.</span></span><br><span class="line">				<span class="keyword">if</span> <span class="type">int32</span>(atomic.Xadd(&amp;sched.nmspinning, <span class="number">-1</span>)) &lt; <span class="number">0</span> &#123;</span><br><span class="line">					throw(<span class="string">&quot;startm: negative nmspinning&quot;</span>)</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			releasem(mp)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 尝试从 midle 中获取一个空闲的 m，若获取不到，就创建一个新的 m */</span></span><br><span class="line">	nmp := mget()</span><br><span class="line">	<span class="keyword">if</span> nmp == <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">/* 先为 m 分配一个 id，防止在释放 sched.lock 后运行 checkdead() 时被判定为死锁 */</span></span><br><span class="line">		id := mReserveID()</span><br><span class="line">		unlock(&amp;sched.lock)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">var</span> fn <span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line">    <span class="comment">/* 如果期望启动一个 spining 状态的 m，那么新创建的 m 就是正在自旋的 */</span></span><br><span class="line">		<span class="keyword">if</span> spinning &#123;</span><br><span class="line">			<span class="comment">// The caller incremented nmspinning, so set m.spinning in the new M.</span></span><br><span class="line">			fn = mspinning</span><br><span class="line">		&#125;</span><br><span class="line">		newm(fn, _p_, id)</span><br><span class="line">		<span class="comment">// Ownership transfer of _p_ committed by start in newm.</span></span><br><span class="line">		<span class="comment">// Preemption is now safe.</span></span><br><span class="line">		releasem(mp)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	unlock(&amp;sched.lock)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 从 midle 中拿到的 m 一定不处于自旋状态（只有 stopm 后，m 才会进入 midle，而停止的 m 不处于自旋态） */</span></span><br><span class="line">	<span class="keyword">if</span> nmp.spinning &#123;</span><br><span class="line">		throw(<span class="string">&quot;startm: m is spinning&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* midle 中的 m 不应拥有 p */</span></span><br><span class="line">	<span class="keyword">if</span> nmp.nextp != <span class="number">0</span> &#123;</span><br><span class="line">		throw(<span class="string">&quot;startm: m has p&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 如果传入了非空闲的 p，且还期望启动一个自旋的 m，是自相矛盾的 */</span></span><br><span class="line">	<span class="keyword">if</span> spinning &amp;&amp; !runqempty(_p_) &#123;</span><br><span class="line">		throw(<span class="string">&quot;startm: p has runnable gs&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 根据需要自旋的情况设置自旋 */</span></span><br><span class="line">	<span class="comment">// The caller incremented nmspinning, so set m.spinning in the new M.</span></span><br><span class="line">	nmp.spinning = spinning</span><br><span class="line">	nmp.nextp.set(_p_)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 唤醒该 m 所绑定的系统线程，正式开始工作</span></span><br><span class="line"><span class="comment">   *（如果是从 findrunnable() 调用的 stopm()，那么就会继续执行 findrunnable() 寻找新的 g） </span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">	notewakeup(&amp;nmp.park)</span><br><span class="line">	<span class="comment">// Ownership transfer of _p_ committed by wakeup. Preemption is now</span></span><br><span class="line">	<span class="comment">// safe.</span></span><br><span class="line">	releasem(mp)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 在 m 确实找不到可运行的 g 时，将被放入 midle 中，同时其关联的系统线程也将休眠 */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">stopm</span><span class="params">()</span></span> &#123;</span><br><span class="line">	_g_ := getg()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> _g_.m.locks != <span class="number">0</span> &#123;</span><br><span class="line">		throw(<span class="string">&quot;stopm holding locks&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> _g_.m.p != <span class="number">0</span> &#123;</span><br><span class="line">		throw(<span class="string">&quot;stopm holding p&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> _g_.m.spinning &#123;</span><br><span class="line">		throw(<span class="string">&quot;stopm spinning&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	lock(&amp;sched.lock)</span><br><span class="line">  <span class="comment">/* midle 入队 */</span></span><br><span class="line">	mput(_g_.m)</span><br><span class="line">	unlock(&amp;sched.lock)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 系统线程休眠 */</span></span><br><span class="line">	mPark()</span><br><span class="line">	acquirep(_g_.m.nextp.ptr())</span><br><span class="line">	_g_.m.nextp = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**************** [lock_futex.go] ****************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 在 linux 系统下，notesleep 和 notewakeup 是基于 futex 实现，而在 macos 下则是 mutex cond */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">notesleep</span><span class="params">(n *note)</span></span> &#123;</span><br><span class="line">	gp := getg()</span><br><span class="line">	<span class="keyword">if</span> gp != gp.m.g0 &#123;</span><br><span class="line">		throw(<span class="string">&quot;notesleep not on g0&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	ns := <span class="type">int64</span>(<span class="number">-1</span>)</span><br><span class="line">	<span class="keyword">if</span> *cgo_yield != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// Sleep for an arbitrary-but-moderate interval to poll libc interceptors.</span></span><br><span class="line">		ns = <span class="number">10e6</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> atomic.Load(key32(&amp;n.key)) == <span class="number">0</span> &#123;</span><br><span class="line">		gp.m.blocked = <span class="literal">true</span></span><br><span class="line">		futexsleep(key32(&amp;n.key), <span class="number">0</span>, ns)</span><br><span class="line">		<span class="keyword">if</span> *cgo_yield != <span class="literal">nil</span> &#123;</span><br><span class="line">			asmcgocall(*cgo_yield, <span class="literal">nil</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		gp.m.blocked = <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">notewakeup</span><span class="params">(n *note)</span></span> &#123;</span><br><span class="line">	old := atomic.Xchg(key32(&amp;n.key), <span class="number">1</span>)</span><br><span class="line">	<span class="keyword">if</span> old != <span class="number">0</span> &#123;</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;notewakeup - double wakeup (&quot;</span>, old, <span class="string">&quot;)\n&quot;</span>)</span><br><span class="line">		throw(<span class="string">&quot;notewakeup - double wakeup&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	futexwakeup(key32(&amp;n.key), <span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="栈">3. 栈</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**************** [stack.go] ****************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 为调用者分配一段栈空间，返回栈顶与栈底地址（即 stack 结构） */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">stackalloc</span><span class="params">(n <span class="type">uint32</span>)</span></span> stack &#123;</span><br><span class="line">  <span class="comment">/* 需要在系统栈上运行，因此 thisg 一定是 g0 */</span></span><br><span class="line">	thisg := getg()</span><br><span class="line"></span><br><span class="line">  ... ...</span><br><span class="line">  </span><br><span class="line">	<span class="comment">// Small stacks are allocated with a fixed-size free-list allocator.</span></span><br><span class="line">	<span class="comment">// If we need a stack of a bigger size, we fall back on allocating</span></span><br><span class="line">	<span class="comment">// a dedicated span.</span></span><br><span class="line">	<span class="keyword">var</span> v unsafe.Pointer</span><br><span class="line">  <span class="comment">/* 1. _FixedStack 是根据 _StackSystem 所调整的 _StackMin 的二次幂数值，</span></span><br><span class="line"><span class="comment">   *    在 linux 下 _StackSystem = 0，因此 linux 下 _FixedStack == _StackMin == 2048</span></span><br><span class="line"><span class="comment">   * 2. _NumStackOrders 代表栈阶数，golang 中将栈分为 n 阶，第 k + 1 阶的栈容量是 k 阶的 2 倍</span></span><br><span class="line"><span class="comment">   *    linux 下 _NumStackOrders = 4，其每阶栈空间大小分别是 2k、4k、8k、16k</span></span><br><span class="line"><span class="comment">   * 3. _StackCacheSize = 32k，小于 32k 的栈空间分配可以尝试在 P 缓存中分配</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">	<span class="keyword">if</span> n &lt; _FixedStack&lt;&lt;_NumStackOrders &amp;&amp; n &lt; _StackCacheSize &#123;</span><br><span class="line">		order := <span class="type">uint8</span>(<span class="number">0</span>)</span><br><span class="line">		n2 := n</span><br><span class="line">    <span class="comment">/* 根据需要分配的空间大小 n，找到需要在哪一阶（order）中分配 */</span></span><br><span class="line">		<span class="keyword">for</span> n2 &gt; _FixedStack &#123;</span><br><span class="line">			order++</span><br><span class="line">			n2 &gt;&gt;= <span class="number">1</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">var</span> x gclinkptr</span><br><span class="line">		<span class="keyword">if</span> stackNoCache != <span class="number">0</span> || thisg.m.p == <span class="number">0</span> || thisg.m.preemptoff != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">      <span class="comment">/* 部分情况下需要直接从全局的 stackpool 中分配栈空间，stackpoolalloc 见后文 */</span></span><br><span class="line">			<span class="comment">// thisg.m.p == 0 can happen in the guts of exitsyscall</span></span><br><span class="line">			<span class="comment">// or procresize. Just get a stack from the global pool.</span></span><br><span class="line">			<span class="comment">// Also don&#x27;t touch stackcache during gc</span></span><br><span class="line">			<span class="comment">// as it&#x27;s flushed concurrently.</span></span><br><span class="line">			lock(&amp;stackpool[order].item.mu)</span><br><span class="line">			x = stackpoolalloc(order)</span><br><span class="line">			unlock(&amp;stackpool[order].item.mu)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">/* 否则就可以在 P 缓存内分配栈空间</span></span><br><span class="line"><span class="comment">       * 每个 p 结构中都持有一个 mcache，其中保存了 _NumStackOrders 个 stackfreelist 用来存放空闲栈空间</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">			c := thisg.m.p.ptr().mcache</span><br><span class="line">			x = c.stackcache[order].list</span><br><span class="line">			<span class="keyword">if</span> x.ptr() == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">/* 若当前阶的 stackfreelist 还未分配，对其进行分配</span></span><br><span class="line"><span class="comment">         *（实际上还是从全局 stackpool 中分配，一次性分配 _StackCacheSize 的一半）</span></span><br><span class="line"><span class="comment">         * 分配的栈空间会以一个个的 segment 的形式链式存储，每个 segment 的容量等于当前阶所规定的栈容量</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">				stackcacherefill(c, order)</span><br><span class="line">				x = c.stackcache[order].list</span><br><span class="line">			&#125;</span><br><span class="line">      <span class="comment">/* 从空闲列表 head 处分配 n 个字节，并将当前空闲列表 head 指向下一个 segment，若指到了 tail，下一次就又会对其进行分配</span></span><br><span class="line"><span class="comment">       * 由于 _StackMin = 2k，又要求 n 必须是二次幂，因此就能确保待分配的 n 字节栈空间恰好与对应阶的栈容量一致</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">			c.stackcache[order].list = x.ptr().next</span><br><span class="line">			c.stackcache[order].size -= <span class="type">uintptr</span>(n)</span><br><span class="line">		&#125;</span><br><span class="line">		v = unsafe.Pointer(x)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">/* 若需要的栈空间过大，就尝试在 stackLarge 中分配</span></span><br><span class="line"><span class="comment">     * stackLarge 实际上存放的是一组 span 链表，每一条链表存放的占空间大小是以一页大小（8k）的二次幂划分的，</span></span><br><span class="line"><span class="comment">     * 即 stackLarge.free[0] =》 8k，stackLarge.free[1] =》 16k，stackLarge.free[1] =》 32k，... ...</span></span><br><span class="line"><span class="comment">     * 同样的，由于 _StackMin = 2k，又要求 n 必须是二次幂，因此传入的 n 转换为 npages 后也会遵循 1，2，4，8... 的要求</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">		<span class="keyword">var</span> s *mspan</span><br><span class="line">    <span class="comment">/* 计算需要的 page 数量 */</span></span><br><span class="line">		npage := <span class="type">uintptr</span>(n) &gt;&gt; _PageShift</span><br><span class="line">		log2npage := stacklog2(npage)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Try to get a stack from the large stack cache.</span></span><br><span class="line">		lock(&amp;stackLarge.lock)</span><br><span class="line">		<span class="keyword">if</span> !stackLarge.free[log2npage].isEmpty() &#123;</span><br><span class="line">      <span class="comment">/* 如果存在合适的空闲空间，直接使用 */</span></span><br><span class="line">			s = stackLarge.free[log2npage].first</span><br><span class="line">			stackLarge.free[log2npage].remove(s)</span><br><span class="line">		&#125;</span><br><span class="line">		unlock(&amp;stackLarge.lock)</span><br><span class="line"></span><br><span class="line">		lockWithRankMayAcquire(&amp;mheap_.lock, lockRankMheap)</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果 stackLarge 中没有剩余空间了，那么直接从堆中分配 npage 空间 */</span></span><br><span class="line">		<span class="keyword">if</span> s == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="comment">// Allocate a new stack from the heap.</span></span><br><span class="line">			s = mheap_.allocManual(npage, spanAllocStack)</span><br><span class="line">			<span class="keyword">if</span> s == <span class="literal">nil</span> &#123;</span><br><span class="line">				throw(<span class="string">&quot;out of memory&quot;</span>)</span><br><span class="line">			&#125;</span><br><span class="line">			osStackAlloc(s)</span><br><span class="line">			s.elemsize = <span class="type">uintptr</span>(n)</span><br><span class="line">		&#125;</span><br><span class="line">		v = unsafe.Pointer(s.base())</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	... ...</span><br><span class="line">	<span class="keyword">return</span> stack&#123;<span class="type">uintptr</span>(v), <span class="type">uintptr</span>(v) + <span class="type">uintptr</span>(n)&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 全局 stackpool 的分配 */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">stackpoolalloc</span><span class="params">(order <span class="type">uint8</span>)</span></span> gclinkptr &#123;</span><br><span class="line">  <span class="comment">/* 每一阶都存放了一个 span 链表作为空闲链表 */</span></span><br><span class="line">	list := &amp;stackpool[order].item.span</span><br><span class="line">	s := list.first</span><br><span class="line">	lockWithRankMayAcquire(&amp;mheap_.lock, lockRankMheap)</span><br><span class="line">  <span class="comment">/* 如果当前阶的空闲列表为空，尝试从堆分配，但 allocManual 所分配的内存是不被 gc 管理的，因此一定要手动释放 */</span></span><br><span class="line">	<span class="keyword">if</span> s == <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">/* 一次性分配 _StackCacheSize 容量的页，返回一个 mspan */</span></span><br><span class="line">		<span class="comment">// no free stacks. Allocate another span worth.</span></span><br><span class="line">		s = mheap_.allocManual(_StackCacheSize&gt;&gt;_PageShift, spanAllocStack)</span><br><span class="line">		</span><br><span class="line">    ... ...</span><br><span class="line">		</span><br><span class="line">    <span class="comment">/* 按 order 所指定的大小，将内存切分成 segments，用 manualFreeList 管理 */</span></span><br><span class="line">    s.elemsize = _FixedStack &lt;&lt; order</span><br><span class="line">		<span class="keyword">for</span> i := <span class="type">uintptr</span>(<span class="number">0</span>); i &lt; _StackCacheSize; i += s.elemsize &#123;</span><br><span class="line">			x := gclinkptr(s.base() + i)</span><br><span class="line">			x.ptr().next = s.manualFreeList</span><br><span class="line">			s.manualFreeList = x</span><br><span class="line">		&#125;</span><br><span class="line">		list.insert(s)</span><br><span class="line">	&#125;</span><br><span class="line">	x := s.manualFreeList</span><br><span class="line">	<span class="keyword">if</span> x.ptr() == <span class="literal">nil</span> &#123;</span><br><span class="line">		throw(<span class="string">&quot;span has no free stacks&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	s.manualFreeList = x.ptr().next</span><br><span class="line">	s.allocCount++</span><br><span class="line">  <span class="comment">/* 当 manualFreeList 为 nil 时说明当前 mspan 持有的空闲 segment 都已经被分配掉了，因此把它移除 stackpool */</span></span><br><span class="line">	<span class="keyword">if</span> s.manualFreeList.ptr() == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// all stacks in s are allocated.</span></span><br><span class="line">		list.remove(s)</span><br><span class="line">	&#125;</span><br><span class="line">  <span class="comment">/* 最终返回的是 mspan manualFreeList 的首地址 */</span></span><br><span class="line">	<span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 将 stack 释放，通常在释放 g 的时候调用 */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">stackfree</span><span class="params">(stk stack)</span></span> &#123;</span><br><span class="line">	gp := getg()</span><br><span class="line">	v := unsafe.Pointer(stk.lo)</span><br><span class="line">	n := stk.hi - stk.lo</span><br><span class="line"></span><br><span class="line">  ... ...</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 一样是根据栈空间大小来决定释放的位置 */</span></span><br><span class="line">	<span class="keyword">if</span> n &lt; _FixedStack&lt;&lt;_NumStackOrders &amp;&amp; n &lt; _StackCacheSize &#123;</span><br><span class="line">		order := <span class="type">uint8</span>(<span class="number">0</span>)</span><br><span class="line">		n2 := n</span><br><span class="line">		<span class="keyword">for</span> n2 &gt; _FixedStack &#123;</span><br><span class="line">			order++</span><br><span class="line">			n2 &gt;&gt;= <span class="number">1</span></span><br><span class="line">		&#125;</span><br><span class="line">		x := gclinkptr(v)</span><br><span class="line">    <span class="comment">/* 选择从 stackpool 或者 stackcache 中释放 */</span></span><br><span class="line">		<span class="keyword">if</span> stackNoCache != <span class="number">0</span> || gp.m.p == <span class="number">0</span> || gp.m.preemptoff != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">			lock(&amp;stackpool[order].item.mu)</span><br><span class="line">			stackpoolfree(x, order)</span><br><span class="line">			unlock(&amp;stackpool[order].item.mu)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			c := gp.m.p.ptr().mcache</span><br><span class="line">			<span class="keyword">if</span> c.stackcache[order].size &gt;= _StackCacheSize &#123;</span><br><span class="line">        <span class="comment">/* 当 stackcache 已满时，尝试释放一部分（保证容量小于 _StackCacheSize/2） */</span></span><br><span class="line">				stackcacherelease(c, order)</span><br><span class="line">			&#125;</span><br><span class="line">      <span class="comment">/* 把 stack segment 插入 head */</span></span><br><span class="line">			x.ptr().next = c.stackcache[order].list</span><br><span class="line">			c.stackcache[order].list = x</span><br><span class="line">			c.stackcache[order].size += n</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">/* 若栈空间过大 */</span></span><br><span class="line">		s := spanOfUnchecked(<span class="type">uintptr</span>(v))</span><br><span class="line">		<span class="keyword">if</span> s.state.get() != mSpanManual &#123;</span><br><span class="line">			<span class="built_in">println</span>(hex(s.base()), v)</span><br><span class="line">			throw(<span class="string">&quot;bad span state&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">    <span class="comment">/* 假如当前 gc 未运行（在后台 sweep）直接将空间释放 */</span></span><br><span class="line">		<span class="keyword">if</span> gcphase == _GCoff &#123;</span><br><span class="line">			<span class="comment">// Free the stack immediately if we&#x27;re</span></span><br><span class="line">			<span class="comment">// sweeping.</span></span><br><span class="line">			osStackFree(s)</span><br><span class="line">			mheap_.freeManual(s, spanAllocStack)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">/* gc 正在运行时，不能直接释放，还回 stackLarge */</span></span><br><span class="line">			<span class="comment">// If the GC is running, we can&#x27;t return a</span></span><br><span class="line">			<span class="comment">// stack span to the heap because it could be</span></span><br><span class="line">			<span class="comment">// reused as a heap span, and this state</span></span><br><span class="line">			<span class="comment">// change would race with GC. Add it to the</span></span><br><span class="line">			<span class="comment">// large stack cache instead.</span></span><br><span class="line">			log2npage := stacklog2(s.npages)</span><br><span class="line">			lock(&amp;stackLarge.lock)</span><br><span class="line">			stackLarge.free[log2npage].insert(s)</span><br><span class="line">			unlock(&amp;stackLarge.lock)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 释放全局 stackpool */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">stackpoolfree</span><span class="params">(x gclinkptr, order <span class="type">uint8</span>)</span></span> &#123;</span><br><span class="line">	s := spanOfUnchecked(<span class="type">uintptr</span>(x))</span><br><span class="line">  <span class="comment">/* 用作 stack 的 mspan，都会持有 mSpanManual 状态 */</span></span><br><span class="line">	<span class="keyword">if</span> s.state.get() != mSpanManual &#123;</span><br><span class="line">		throw(<span class="string">&quot;freeing stack not in a stack span&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">  <span class="comment">/* 假如 manualFreeList 为 nil，把它重新加回 stackpool，因为在释放了空间后，这个 span 会重新拥有空闲空间 */</span></span><br><span class="line">	<span class="keyword">if</span> s.manualFreeList.ptr() == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// s will now have a free stack</span></span><br><span class="line">		stackpool[order].item.span.insert(s)</span><br><span class="line">	&#125;</span><br><span class="line">	x.ptr().next = s.manualFreeList</span><br><span class="line">	s.manualFreeList = x</span><br><span class="line">	s.allocCount--</span><br><span class="line">  <span class="comment">/* 当 gc 在后台未运行，且当前 span 的所有 segment 都被释放了，就把他还回 heap */</span></span><br><span class="line">	<span class="keyword">if</span> gcphase == _GCoff &amp;&amp; s.allocCount == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// Span is completely free. Return it to the heap</span></span><br><span class="line">		<span class="comment">// immediately if we&#x27;re sweeping.</span></span><br><span class="line">		<span class="comment">//</span></span><br><span class="line">		<span class="comment">// If GC is active, we delay the free until the end of</span></span><br><span class="line">		<span class="comment">// GC to avoid the following type of situation:</span></span><br><span class="line">		<span class="comment">//</span></span><br><span class="line">		<span class="comment">// 1) GC starts, scans a SudoG but does not yet mark the SudoG.elem pointer</span></span><br><span class="line">		<span class="comment">// 2) The stack that pointer points to is copied</span></span><br><span class="line">		<span class="comment">// 3) The old stack is freed</span></span><br><span class="line">		<span class="comment">// 4) The containing span is marked free</span></span><br><span class="line">		<span class="comment">// 5) GC attempts to mark the SudoG.elem pointer. The</span></span><br><span class="line">		<span class="comment">//    marking fails because the pointer looks like a</span></span><br><span class="line">		<span class="comment">//    pointer into a free span.</span></span><br><span class="line">		<span class="comment">//</span></span><br><span class="line">		<span class="comment">// By not freeing, we prevent step #4 until GC is done.</span></span><br><span class="line">		stackpool[order].item.span.remove(s)</span><br><span class="line">		s.manualFreeList = <span class="number">0</span></span><br><span class="line">		osStackFree(s)</span><br><span class="line">		mheap_.freeManual(s, spanAllocStack)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">/**************** [asm_amd64.s] ****************/</span><br><span class="line"></span><br><span class="line">/* 检查是否需要扩容当前栈</span><br><span class="line"> * 对于每一个非 NOSPLIT 的函数，编译器都会在最前面插入尝试调用 morestack 的逻辑：</span><br><span class="line"> * 若当前 SP 已经小于 stackgourd0，则跳转到 morestack</span><br><span class="line">*/</span><br><span class="line">TEXT runtime·morestack(SB),NOSPLIT,$0-0</span><br><span class="line">	// Cannot grow scheduler stack (m-&gt;g0).</span><br><span class="line">	get_tls(CX)</span><br><span class="line">	MOVQ	g(CX), BX</span><br><span class="line">	MOVQ	g_m(BX), BX</span><br><span class="line">	MOVQ	m_g0(BX), SI</span><br><span class="line">	/*  g0 的栈不能被扩容，因此如果检测到 morestack 在 g0 上被调用，直接终止程序 */</span><br><span class="line">	CMPQ	g(CX), SI</span><br><span class="line">	JNE	3(PC)</span><br><span class="line">	CALL	runtime·badmorestackg0(SB)</span><br><span class="line">	CALL	runtime·abort(SB)</span><br><span class="line"></span><br><span class="line">  /*  gsignal 的栈也不能被扩容 */</span><br><span class="line">	// Cannot grow signal stack (m-&gt;gsignal).</span><br><span class="line">	MOVQ	m_gsignal(BX), SI</span><br><span class="line">	CMPQ	g(CX), SI</span><br><span class="line">	JNE	3(PC)</span><br><span class="line">	CALL	runtime·badmorestackgsignal(SB)</span><br><span class="line">	CALL	runtime·abort(SB)</span><br><span class="line"></span><br><span class="line">  /* 将当前函数调用者的 pc sp g 等信息保存在 m 的 morebuf 中 */</span><br><span class="line">	// Called from f.</span><br><span class="line">	// Set m-&gt;morebuf to f&#x27;s caller.</span><br><span class="line">	NOP	SP	// tell vet SP changed - stop checking offsets</span><br><span class="line">	MOVQ	8(SP), AX	// f&#x27;s caller&#x27;s PC</span><br><span class="line">	MOVQ	AX, (m_morebuf+gobuf_pc)(BX)</span><br><span class="line">	LEAQ	16(SP), AX	// f&#x27;s caller&#x27;s SP</span><br><span class="line">	MOVQ	AX, (m_morebuf+gobuf_sp)(BX)</span><br><span class="line">	get_tls(CX)</span><br><span class="line">	MOVQ	g(CX), SI</span><br><span class="line">	MOVQ	SI, (m_morebuf+gobuf_g)(BX)</span><br><span class="line"></span><br><span class="line">  /* 将当前函数的 pc sp g 等信息保存在 g 的 shecd 中 */</span><br><span class="line">	// Set g-&gt;sched to context in f.</span><br><span class="line">	MOVQ	0(SP), AX // f&#x27;s PC</span><br><span class="line">	MOVQ	AX, (g_sched+gobuf_pc)(SI)</span><br><span class="line">	LEAQ	8(SP), AX // f&#x27;s SP</span><br><span class="line">	MOVQ	AX, (g_sched+gobuf_sp)(SI)</span><br><span class="line">	MOVQ	BP, (g_sched+gobuf_bp)(SI)</span><br><span class="line">	MOVQ	DX, (g_sched+gobuf_ctxt)(SI)</span><br><span class="line"></span><br><span class="line">  /* 切换到 g0 运行 newstack */</span><br><span class="line">	// Call newstack on m-&gt;g0&#x27;s stack.</span><br><span class="line">	MOVQ	m_g0(BX), BX</span><br><span class="line">	MOVQ	BX, g(CX)</span><br><span class="line">	MOVQ	(g_sched+gobuf_sp)(BX), SP</span><br><span class="line">	CALL	runtime·newstack(SB)</span><br><span class="line">	/* newstack 会直接调用 gogo 跳转到原 goroutine 执行，因此不会返回 */</span><br><span class="line">	CALL	runtime·abort(SB)	// crash if newstack returns</span><br><span class="line">	RET</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**************** [stack.go] ****************/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newstack</span><span class="params">()</span></span> &#123;</span><br><span class="line">	thisg := getg()</span><br><span class="line">  </span><br><span class="line">  ... ...</span><br><span class="line"></span><br><span class="line">	gp := thisg.m.curg</span><br><span class="line"></span><br><span class="line">  ... ...</span><br><span class="line">  </span><br><span class="line">	morebuf := thisg.m.morebuf</span><br><span class="line">	thisg.m.morebuf.pc = <span class="number">0</span></span><br><span class="line">	thisg.m.morebuf.lr = <span class="number">0</span></span><br><span class="line">	thisg.m.morebuf.sp = <span class="number">0</span></span><br><span class="line">	thisg.m.morebuf.g = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 这里略过了抢占相关的逻辑，当下只关心栈扩容 */</span></span><br><span class="line">	... ...</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 新栈空间是旧栈的两倍 */</span></span><br><span class="line">	<span class="comment">// Allocate a bigger segment and move the stack.</span></span><br><span class="line">	oldsize := gp.stack.hi - gp.stack.lo</span><br><span class="line">	newsize := oldsize * <span class="number">2</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 通过 PCDATA 计算出函数所需的栈帧空间，如果新栈所扩张的空间仍然不够函数所需，则对他再次乘 2 */</span></span><br><span class="line">	<span class="comment">// Make sure we grow at least as much as needed to fit the new frame.</span></span><br><span class="line">	<span class="comment">// (This is just an optimization - the caller of morestack will</span></span><br><span class="line">	<span class="comment">// recheck the bounds on return.)</span></span><br><span class="line">	<span class="keyword">if</span> f := findfunc(gp.sched.pc); f.valid() &#123;</span><br><span class="line">		max := <span class="type">uintptr</span>(funcMaxSPDelta(f))</span><br><span class="line">		needed := max + _StackGuard</span><br><span class="line">		used := gp.stack.hi - gp.sched.sp</span><br><span class="line">		<span class="keyword">for</span> newsize-used &lt; needed &#123;</span><br><span class="line">			newsize *= <span class="number">2</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	... ...</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 假如扩容后的栈空间超过了最大容量，抛出栈溢出错误，maxstacksize 会在 main goroutine 中被设置为 1 GiB */</span></span><br><span class="line">	<span class="keyword">if</span> newsize &gt; maxstacksize || newsize &gt; maxstackceiling &#123;</span><br><span class="line">		<span class="keyword">if</span> maxstacksize &lt; maxstackceiling &#123;</span><br><span class="line">			<span class="built_in">print</span>(<span class="string">&quot;runtime: goroutine stack exceeds &quot;</span>, maxstacksize, <span class="string">&quot;-byte limit\n&quot;</span>)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="built_in">print</span>(<span class="string">&quot;runtime: goroutine stack exceeds &quot;</span>, maxstackceiling, <span class="string">&quot;-byte limit\n&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;runtime: sp=&quot;</span>, hex(sp), <span class="string">&quot; stack=[&quot;</span>, hex(gp.stack.lo), <span class="string">&quot;, &quot;</span>, hex(gp.stack.hi), <span class="string">&quot;]\n&quot;</span>)</span><br><span class="line">		throw(<span class="string">&quot;stack overflow&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// The goroutine must be executing in order to call newstack,</span></span><br><span class="line">	<span class="comment">// so it must be Grunning (or Gscanrunning).</span></span><br><span class="line">	casgstatus(gp, _Grunning, _Gcopystack)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// The concurrent GC will not scan the stack while we are doing the copy since</span></span><br><span class="line">	<span class="comment">// the gp is in a Gcopystack status.</span></span><br><span class="line">	copystack(gp, newsize)</span><br><span class="line">	</span><br><span class="line">  <span class="keyword">if</span> stackDebug &gt;= <span class="number">1</span> &#123;</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;stack grow done\n&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	casgstatus(gp, _Gcopystack, _Grunning)</span><br><span class="line">	gogo(&amp;gp.sched)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 扩容实际上是分配新空间，并将旧栈内容复制进去 */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">copystack</span><span class="params">(gp *g, newsize <span class="type">uintptr</span>)</span></span> &#123;</span><br><span class="line">  ... ...</span><br><span class="line">	old := gp.stack</span><br><span class="line">  ... ...</span><br><span class="line">	used := old.hi - gp.sched.sp</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 用 stackalloc 分配新空间 */</span></span><br><span class="line">	<span class="comment">// allocate new stack</span></span><br><span class="line">	<span class="built_in">new</span> := stackalloc(<span class="type">uint32</span>(newsize))</span><br><span class="line">	... ...</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 计算新旧栈空间之间的距离，便于后续 copy 的时候定位 */</span></span><br><span class="line">	<span class="comment">// Compute adjustment.</span></span><br><span class="line">	<span class="keyword">var</span> adjinfo adjustinfo</span><br><span class="line">	adjinfo.old = old</span><br><span class="line">	adjinfo.delta = <span class="built_in">new</span>.hi - old.hi</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Adjust sudogs, synchronizing with channel ops if necessary.</span></span><br><span class="line">	ncopy := used</span><br><span class="line">  <span class="comment">/* 对于没有非阻塞 channel 指向当前 g 的 stack，直接调整其每一个 sudog 指向的 stack 位置</span></span><br><span class="line"><span class="comment">   * （sudog 即 pseudo g，sudog 代表 g 在等待某个对象，g.waiting 是当前 g 的等待队列）</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">	<span class="keyword">if</span> !gp.activeStackChans &#123;</span><br><span class="line">		<span class="keyword">if</span> newsize &lt; old.hi-old.lo &amp;&amp; atomic.Load8(&amp;gp.parkingOnChan) != <span class="number">0</span> &#123;</span><br><span class="line">			<span class="comment">// It&#x27;s not safe for someone to shrink this stack while we&#x27;re actively</span></span><br><span class="line">			<span class="comment">// parking on a channel, but it is safe to grow since we do that</span></span><br><span class="line">			<span class="comment">// ourselves and explicitly don&#x27;t want to synchronize with channels</span></span><br><span class="line">			<span class="comment">// since we could self-deadlock.</span></span><br><span class="line">			throw(<span class="string">&quot;racy sudog adjustment due to parking on channel&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		adjustsudogs(gp, &amp;adjinfo)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">/* 否则，需要将 channel lock 之后再移动 */</span></span><br><span class="line">		<span class="comment">// sudogs may be pointing in to the stack and gp has</span></span><br><span class="line">		<span class="comment">// released channel locks, so other goroutines could</span></span><br><span class="line">		<span class="comment">// be writing to gp&#x27;s stack. Find the highest such</span></span><br><span class="line">		<span class="comment">// pointer so we can handle everything there and below</span></span><br><span class="line">		<span class="comment">// carefully. (This shouldn&#x27;t be far from the bottom</span></span><br><span class="line">		<span class="comment">// of the stack, so there&#x27;s little cost in handling</span></span><br><span class="line">		<span class="comment">// everything below it carefully.)</span></span><br><span class="line">		adjinfo.sghi = findsghi(gp, old)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Synchronize with channel ops and copy the part of</span></span><br><span class="line">		<span class="comment">// the stack they may interact with.</span></span><br><span class="line">		ncopy -= syncadjustsudogs(gp, used, &amp;adjinfo)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* memmove 位于 memmove_amd64.s ，实现中有非常多优化 */</span></span><br><span class="line">	<span class="comment">// Copy the stack (or the rest of it) to the new location</span></span><br><span class="line">	memmove(unsafe.Pointer(<span class="built_in">new</span>.hi-ncopy), unsafe.Pointer(old.hi-ncopy), ncopy)</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 在 sched、defer、panic 中与 stack 相关的全都要调整 */</span></span><br><span class="line">	<span class="comment">// Adjust remaining structures that have pointers into stacks.</span></span><br><span class="line">	<span class="comment">// We have to do most of these before we traceback the new</span></span><br><span class="line">	<span class="comment">// stack because gentraceback uses them.</span></span><br><span class="line">	adjustctxt(gp, &amp;adjinfo)</span><br><span class="line">	adjustdefers(gp, &amp;adjinfo)</span><br><span class="line">	adjustpanics(gp, &amp;adjinfo)</span><br><span class="line">	<span class="keyword">if</span> adjinfo.sghi != <span class="number">0</span> &#123;</span><br><span class="line">		adjinfo.sghi += adjinfo.delta</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 将 g.stack 切换 */</span></span><br><span class="line">	<span class="comment">// Swap out old stack for new one</span></span><br><span class="line">	gp.stack = <span class="built_in">new</span></span><br><span class="line">	gp.stackguard0 = <span class="built_in">new</span>.lo + _StackGuard <span class="comment">// <span class="doctag">NOTE:</span> might clobber a preempt request</span></span><br><span class="line">	gp.sched.sp = <span class="built_in">new</span>.hi - used</span><br><span class="line">	gp.stktopsp += adjinfo.delta</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Adjust pointers in the new stack.</span></span><br><span class="line">	gentraceback(^<span class="type">uintptr</span>(<span class="number">0</span>), ^<span class="type">uintptr</span>(<span class="number">0</span>), <span class="number">0</span>, gp, <span class="number">0</span>, <span class="literal">nil</span>, <span class="number">0x7fffffff</span>, adjustframe, noescape(unsafe.Pointer(&amp;adjinfo)), <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 最后把旧空间释放 */</span></span><br><span class="line">	<span class="comment">// free old stack</span></span><br><span class="line">	<span class="keyword">if</span> stackPoisonCopy != <span class="number">0</span> &#123;</span><br><span class="line">		fillstack(old, <span class="number">0xfc</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	stackfree(old)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 缩小栈 */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">shrinkstack</span><span class="params">(gp *g)</span></span> &#123;</span><br><span class="line">	... ...</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 准备将栈空间缩小为原来的一半，但必须大于 _FixedStack，否则不缩小 */</span></span><br><span class="line">	oldsize := gp.stack.hi - gp.stack.lo</span><br><span class="line">	newsize := oldsize / <span class="number">2</span></span><br><span class="line">	<span class="comment">// Don&#x27;t shrink the allocation below the minimum-sized stack</span></span><br><span class="line">	<span class="comment">// allocation.</span></span><br><span class="line">	<span class="keyword">if</span> newsize &lt; _FixedStack &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 如果已使用的栈空间大于总空间的四分之一，也不缩小 */</span></span><br><span class="line">	<span class="comment">// Compute how much of the stack is currently in use and only</span></span><br><span class="line">	<span class="comment">// shrink the stack if gp is using less than a quarter of its</span></span><br><span class="line">	<span class="comment">// current stack. The currently used stack includes everything</span></span><br><span class="line">	<span class="comment">// down to the SP plus the stack guard space that ensures</span></span><br><span class="line">	<span class="comment">// there&#x27;s room for nosplit functions.</span></span><br><span class="line">	avail := gp.stack.hi - gp.stack.lo</span><br><span class="line">	<span class="keyword">if</span> used := gp.stack.hi - gp.sched.sp + _StackLimit; used &gt;= avail/<span class="number">4</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> stackDebug &gt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&quot;shrinking stack &quot;</span>, oldsize, <span class="string">&quot;-&gt;&quot;</span>, newsize, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 缩小的逻辑还是通过将栈内容复制到一个更小的空间内完成的 */</span></span><br><span class="line">	copystack(gp, newsize)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="堆">4. 堆</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**************** [malloc.go] ****************/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newobject</span><span class="params">(typ *_type)</span></span> unsafe.Pointer &#123;</span><br><span class="line">	<span class="keyword">return</span> mallocgc(typ.size, typ, <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mallocgc</span><span class="params">(size <span class="type">uintptr</span>, typ *_type, needzero <span class="type">bool</span>)</span></span> unsafe.Pointer &#123;</span><br><span class="line">	<span class="comment">/* 这里略过了 GODEBUG = sbrk，gcAssist 协助标记等逻辑，当下只关心堆内存分配 */</span></span><br><span class="line">  ... ...</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Set mp.mallocing to keep from being preempted by GC.</span></span><br><span class="line">	mp := acquirem()</span><br><span class="line">	... ...</span><br><span class="line">	mp.mallocing = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">	shouldhelpgc := <span class="literal">false</span></span><br><span class="line">	dataSize := size</span><br><span class="line">	c := getMCache()</span><br><span class="line">  ... ...</span><br><span class="line">  </span><br><span class="line">	<span class="keyword">var</span> span *mspan</span><br><span class="line">	<span class="keyword">var</span> x unsafe.Pointer</span><br><span class="line">	noscan := typ == <span class="literal">nil</span> || typ.ptrdata == <span class="number">0</span></span><br><span class="line">	<span class="comment">// In some cases block zeroing can profitably (for latency reduction purposes)</span></span><br><span class="line">	<span class="comment">// be delayed till preemption is possible; isZeroed tracks that state.</span></span><br><span class="line">	isZeroed := <span class="literal">true</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 首先判断需要分配的空间是否大于 maxSmallSize（=32KiB），大对象会进入专门的分配逻辑 */</span></span><br><span class="line">	<span class="keyword">if</span> size &lt;= maxSmallSize &#123;</span><br><span class="line">    <span class="comment">/* 当传入的 type 为 nil 或者不是指针类型（typ.ptrdata == 0），且所需容量小于 maxTinySize（16 byte）时，</span></span><br><span class="line"><span class="comment">     * 使用 tiny allocator </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">		<span class="keyword">if</span> noscan &amp;&amp; size &lt; maxTinySize &#123;</span><br><span class="line">      <span class="comment">/* Tiny Allocator</span></span><br><span class="line"><span class="comment">       * 将许多小对象组合起来，共同分配一块空间（maxTinySize）。</span></span><br><span class="line"><span class="comment">       * maxTinySize 目前是 16 bytes，最多可能浪费一倍的空间。</span></span><br><span class="line"><span class="comment">       * tiny allocator 主要用于分配小字符串和单个逃逸的变量，tiny allocator 的空间在 mcache 中分配。</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">			off := c.tinyoffset</span><br><span class="line">			<span class="comment">/* 先对当前 tiny block 的 offset 按照所需的 size 进行对齐 */</span></span><br><span class="line">			<span class="keyword">if</span> size&amp;<span class="number">7</span> == <span class="number">0</span> &#123;</span><br><span class="line">				off = alignUp(off, <span class="number">8</span>)</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> sys.PtrSize == <span class="number">4</span> &amp;&amp; size == <span class="number">12</span> &#123;</span><br><span class="line">				off = alignUp(off, <span class="number">8</span>)</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> size&amp;<span class="number">3</span> == <span class="number">0</span> &#123;</span><br><span class="line">				off = alignUp(off, <span class="number">4</span>)</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> size&amp;<span class="number">1</span> == <span class="number">0</span> &#123;</span><br><span class="line">				off = alignUp(off, <span class="number">2</span>)</span><br><span class="line">			&#125;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">/* 对齐后的 offset + size 仍旧小于 maxTinySize，说明可以直接在当前块分配 */</span></span><br><span class="line">			<span class="keyword">if</span> off+size &lt;= maxTinySize &amp;&amp; c.tiny != <span class="number">0</span> &#123;</span><br><span class="line">				<span class="comment">// The object fits into existing tiny block.</span></span><br><span class="line">				x = unsafe.Pointer(c.tiny + off)</span><br><span class="line">				c.tinyoffset = off + size</span><br><span class="line">        <span class="comment">/* 记录了总分配数 */</span></span><br><span class="line">				c.tinyAllocs++</span><br><span class="line">				mp.mallocing = <span class="number">0</span></span><br><span class="line">				releasem(mp)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* 返回内存块起始地址，结束 */</span></span><br><span class="line">				<span class="keyword">return</span> x</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">      <span class="comment">/* 若当前块不能满足所需空间，就需要新创建一个 maxTinySize 大的新块（旧块中的剩余空间浪费掉了） */</span></span><br><span class="line">			span = c.alloc[tinySpanClass]</span><br><span class="line">      <span class="comment">/* 先看看在 mcache 里面有没有空闲内存 */</span></span><br><span class="line">			v := nextFreeFast(span)</span><br><span class="line">			<span class="keyword">if</span> v == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">/* 如果没有了，就需要分配一个新的 span（具体见内存管理部分） */</span></span><br><span class="line">				v, span, shouldhelpgc = c.nextFree(tinySpanClass)</span><br><span class="line">			&#125;</span><br><span class="line">			x = unsafe.Pointer(v)</span><br><span class="line">      <span class="comment">/* maxTinySize = 16 bytes，清空 */</span></span><br><span class="line">			(*[<span class="number">2</span>]<span class="type">uint64</span>)(x)[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">			(*[<span class="number">2</span>]<span class="type">uint64</span>)(x)[<span class="number">1</span>] = <span class="number">0</span></span><br><span class="line">			<span class="comment">// See if we need to replace the existing tiny block with the new one</span></span><br><span class="line">			<span class="comment">// based on amount of remaining free space.</span></span><br><span class="line">			<span class="keyword">if</span> !raceenabled &amp;&amp; (size &lt; c.tinyoffset || c.tiny == <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="comment">// Note: disabled when race detector is on, see comment near end of this function.</span></span><br><span class="line">				c.tiny = <span class="type">uintptr</span>(x)</span><br><span class="line">				c.tinyoffset = size</span><br><span class="line">			&#125;</span><br><span class="line">			size = maxTinySize</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">/* 大于 16 bytes 或者是指针类型 */</span></span><br><span class="line">			<span class="keyword">var</span> sizeclass <span class="type">uint8</span></span><br><span class="line">			<span class="keyword">if</span> size &lt;= smallSizeMax<span class="number">-8</span> &#123;</span><br><span class="line">				sizeclass = size_to_class8[divRoundUp(size, smallSizeDiv)]</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				sizeclass = size_to_class128[divRoundUp(size-smallSizeMax, largeSizeDiv)]</span><br><span class="line">			&#125;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">/* 根据计算过的 sizeclass 来选择分配的空间大小（而不是直接分配实际需要的容量） */</span></span><br><span class="line">			size = <span class="type">uintptr</span>(class_to_size[sizeclass])</span><br><span class="line">			spc := makeSpanClass(sizeclass, noscan)</span><br><span class="line">			span = c.alloc[spc]</span><br><span class="line">      </span><br><span class="line">      <span class="comment">/* 一样，有空闲就在 mcache 找，没有就再分配 */</span></span><br><span class="line">			v := nextFreeFast(span)</span><br><span class="line">			<span class="keyword">if</span> v == <span class="number">0</span> &#123;</span><br><span class="line">				v, span, shouldhelpgc = c.nextFree(spc)</span><br><span class="line">			&#125;</span><br><span class="line">			x = unsafe.Pointer(v)</span><br><span class="line">			<span class="keyword">if</span> needzero &amp;&amp; span.needzero != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">/* 若需要，对分配的空间进行清空 */</span></span><br><span class="line">				memclrNoHeapPointers(unsafe.Pointer(v), size)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">/* 大对象，直接在堆上分配 */</span></span><br><span class="line">		shouldhelpgc = <span class="literal">true</span></span><br><span class="line">		<span class="comment">// For large allocations, keep track of zeroed state so that</span></span><br><span class="line">		<span class="comment">// bulk zeroing can be happen later in a preemptible context.</span></span><br><span class="line">		span, isZeroed = c.allocLarge(size, needzero &amp;&amp; !noscan, noscan)</span><br><span class="line">		span.freeindex = <span class="number">1</span></span><br><span class="line">		span.allocCount = <span class="number">1</span></span><br><span class="line">		x = unsafe.Pointer(span.base())</span><br><span class="line">		size = span.elemsize</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 省略了 GC、调试等等逻辑 */</span></span><br><span class="line">	... ...</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="内存管理">5. 内存管理</h3>
<h4 id="内存分配">5.1 内存分配</h4>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">     ┌────────────────┐</span><br><span class="line">     │     mcache     │</span><br><span class="line">     ├────────────────┤</span><br><span class="line">     │    mcentral    │</span><br><span class="line">     ├────────────────┤</span><br><span class="line">     │     mheap      │</span><br><span class="line">  ┌──┴──┬─────┬─────┬─┴───┐</span><br><span class="line">  │ <span class="selector-tag">span</span>│ <span class="selector-tag">span</span>│ <span class="selector-tag">span</span>│ <span class="selector-tag">span</span>│</span><br><span class="line">┌─┼─┬─┬─┼─────┴────┬┴┬─┬─┬┴┬─┐</span><br><span class="line">│ │ │ │ │ heapArena│ │ │ │ │ │</span><br><span class="line">├─┴─┴─┴─┴──────────┴─┴─┴─┴─┴─┤</span><br><span class="line">│         os memory          │</span><br><span class="line">└────────────────────────────┘</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**************** [mcache.go] ****************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 前面提到过的 mcache，由每个 p 持有，避免了内存操作的锁竞争 */</span></span><br><span class="line"><span class="keyword">type</span> mcache <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">/* 主要用与 mem profile */</span></span><br><span class="line">	nextSample <span class="type">uintptr</span> <span class="comment">// trigger heap sample after allocating this many bytes</span></span><br><span class="line">  <span class="comment">/* mcache alloc 申请的内存部分需要 gc scan，这里是容量计数 */</span></span><br><span class="line">	scanAlloc  <span class="type">uintptr</span> <span class="comment">// bytes of scannable heap allocated</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 前文分配堆内存中讲到的 Tiny Allocator</span></span><br><span class="line"><span class="comment">   * tiny = 起始地址</span></span><br><span class="line"><span class="comment">   * tinyoffset = 当前 span 的空闲位置</span></span><br><span class="line"><span class="comment">   * tinyAllocs = 已分配对象计数</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">	tiny       <span class="type">uintptr</span></span><br><span class="line">	tinyoffset <span class="type">uintptr</span></span><br><span class="line">	tinyAllocs <span class="type">uintptr</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 小于 _MaxSmallSize = 32768 的对象都在这里分配</span></span><br><span class="line"><span class="comment">   * numSpanClasses = 68 &lt;&lt; 1 分别包含 68 个 scan 的 span 和 68 个 noscan 的 span</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">	alloc [numSpanClasses]*mspan <span class="comment">// spans to allocate from, indexed by spanClass</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 栈空间在这里分配，按照 _NumStackOrders，分配栈的大小分别是 2K 4K 8K 16K  */</span></span><br><span class="line">	stackcache [_NumStackOrders]stackfreelist</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 当前 mcache 最后一次 GC flush 时的 sweep generation*/</span></span><br><span class="line">	flushGen <span class="type">uint32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* mcache 本身也需要内存空间来存放，这里在 g0 栈上给 mcache 分配空间，并创造 mcache */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">allocmcache</span><span class="params">()</span></span> *mcache &#123;</span><br><span class="line">	<span class="keyword">var</span> c *mcache</span><br><span class="line">	systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		lock(&amp;mheap_.lock)</span><br><span class="line">    <span class="comment">/* 主要逻辑是通过 mheap_.cachealloc 来分配，见后文 */</span></span><br><span class="line">		c = (*mcache)(mheap_.cachealloc.alloc())</span><br><span class="line">		c.flushGen = mheap_.sweepgen</span><br><span class="line">		unlock(&amp;mheap_.lock)</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> c.alloc &#123;</span><br><span class="line">		c.alloc[i] = &amp;emptymspan</span><br><span class="line">	&#125;</span><br><span class="line">	c.nextSample = nextSample()</span><br><span class="line">	<span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 释放逻辑类似 */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">freemcache</span><span class="params">(c *mcache)</span></span> &#123;</span><br><span class="line">	systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		c.releaseAll()</span><br><span class="line">		stackcache_clear(c)</span><br><span class="line"></span><br><span class="line">		lock(&amp;mheap_.lock)</span><br><span class="line">		mheap_.cachealloc.free(unsafe.Pointer(c))</span><br><span class="line">		unlock(&amp;mheap_.lock)</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 分配新的 span */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *mcache)</span></span> nextFree(spc spanClass) (v gclinkptr, s *mspan, shouldhelpgc <span class="type">bool</span>) &#123;</span><br><span class="line">	<span class="comment">/* 根据 spanClass 选取合适的 span */</span></span><br><span class="line">  s = c.alloc[spc]</span><br><span class="line">	shouldhelpgc = <span class="literal">false</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 获取当前 span 的空闲对象位置 */</span></span><br><span class="line">	freeIndex := s.nextFreeIndex()</span><br><span class="line">  <span class="comment">/* 若没有空闲对象了，需要分配新的 */</span></span><br><span class="line">	<span class="keyword">if</span> freeIndex == s.nelems &#123;</span><br><span class="line">    ... ...</span><br><span class="line">    <span class="comment">/* 从 mcentral 中申请新的 span */</span></span><br><span class="line">		c.refill(spc)</span><br><span class="line">		shouldhelpgc = <span class="literal">true</span></span><br><span class="line">		s = c.alloc[spc]</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 获取新 span 的 freeIndex */</span></span><br><span class="line">		freeIndex = s.nextFreeIndex()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">  ... ...</span><br><span class="line"></span><br><span class="line">	v = gclinkptr(freeIndex*s.elemsize + s.base())</span><br><span class="line">	s.allocCount++</span><br><span class="line">  </span><br><span class="line">	... ...</span><br><span class="line">  </span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *mcache)</span></span> refill(spc spanClass) &#123;</span><br><span class="line">	<span class="comment">// Return the current cached span to the central lists.</span></span><br><span class="line">	s := c.alloc[spc]</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> <span class="type">uintptr</span>(s.allocCount) != s.nelems &#123;</span><br><span class="line">		throw(<span class="string">&quot;refill of span with free space remaining&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 刚初始化的 span 都是 emptymspan，如果当前获取到的 span 不是 emptymspan，就把他先还回 mcentral */</span></span><br><span class="line">	<span class="keyword">if</span> s != &amp;emptymspan &#123;</span><br><span class="line">		<span class="comment">// Mark this span as no longer cached.</span></span><br><span class="line">		<span class="keyword">if</span> s.sweepgen != mheap_.sweepgen+<span class="number">3</span> &#123;</span><br><span class="line">			throw(<span class="string">&quot;bad sweepgen in refill&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		mheap_.central[spc].mcentral.uncacheSpan(s)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 从 mcentral 获取新的 span，从这里能看出，每一个 span class 对应了一个 mcantral */</span></span><br><span class="line">	s = mheap_.central[spc].mcentral.cacheSpan()</span><br><span class="line">	</span><br><span class="line">  ... ...</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 对获取到的 span 进行处理 */</span></span><br><span class="line">	<span class="comment">// Indicate that this span is cached and prevent asynchronous</span></span><br><span class="line">	<span class="comment">// sweeping in the next sweep phase.</span></span><br><span class="line">	s.sweepgen = mheap_.sweepgen + <span class="number">3</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Assume all objects from this span will be allocated in the</span></span><br><span class="line">	<span class="comment">// mcache. If it gets uncached, we&#x27;ll adjust this.</span></span><br><span class="line">	stats := memstats.heapStats.acquire()</span><br><span class="line">	atomic.Xadduintptr(&amp;stats.smallAllocCount[spc.sizeclass()], <span class="type">uintptr</span>(s.nelems)-<span class="type">uintptr</span>(s.allocCount))</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Flush tinyAllocs.</span></span><br><span class="line">	<span class="keyword">if</span> spc == tinySpanClass &#123;</span><br><span class="line">		atomic.Xadduintptr(&amp;stats.tinyAllocCount, c.tinyAllocs)</span><br><span class="line">		c.tinyAllocs = <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">	memstats.heapStats.release()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Update gcController.heapLive with the same assumption.</span></span><br><span class="line">	usedBytes := <span class="type">uintptr</span>(s.allocCount) * s.elemsize</span><br><span class="line">	atomic.Xadd64(&amp;gcController.heapLive, <span class="type">int64</span>(s.npages*pageSize)-<span class="type">int64</span>(usedBytes))</span><br><span class="line"></span><br><span class="line">	<span class="comment">// While we&#x27;re here, flush scanAlloc, since we have to call</span></span><br><span class="line">	<span class="comment">// revise anyway.</span></span><br><span class="line">	atomic.Xadd64(&amp;gcController.heapScan, <span class="type">int64</span>(c.scanAlloc))</span><br><span class="line">	c.scanAlloc = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> trace.enabled &#123;</span><br><span class="line">		<span class="comment">// gcController.heapLive changed.</span></span><br><span class="line">		traceHeapAlloc()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> gcBlackenEnabled != <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// gcController.heapLive and heapScan changed.</span></span><br><span class="line">		gcController.revise()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 最后加入对应位置 */</span></span><br><span class="line">	c.alloc[spc] = s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 大对象直接进入此方法分配 */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *mcache)</span></span> allocLarge(size <span class="type">uintptr</span>, needzero <span class="type">bool</span>, noscan <span class="type">bool</span>) (*mspan, <span class="type">bool</span>) &#123;</span><br><span class="line">	<span class="comment">/* 距离到达地址指针最大值不足一页 */</span></span><br><span class="line">  <span class="keyword">if</span> size+_PageSize &lt; size &#123;</span><br><span class="line">		throw(<span class="string">&quot;out of memory&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 计算需要的整数页 */</span></span><br><span class="line">	npages := size &gt;&gt; _PageShift</span><br><span class="line">	<span class="keyword">if</span> size&amp;_PageMask != <span class="number">0</span> &#123;</span><br><span class="line">		npages++</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Deduct credit for this span allocation and sweep if</span></span><br><span class="line">	<span class="comment">// necessary. mHeap_Alloc will also sweep npages, so this only</span></span><br><span class="line">	<span class="comment">// pays the debt down to npage pages.</span></span><br><span class="line">	deductSweepCredit(npages*_PageSize, npages)</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 根据是否 noscan 获取正确的 span class，注意此处的 size class 是 0，代表分配的是大于 32k 的大内存 */</span></span><br><span class="line">	spc := makeSpanClass(<span class="number">0</span>, noscan)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 直接从堆分配 npages 页内存，由于 size class = 0，因此不受 class_to_size 和 class_to_allocnpages 的限制 */</span></span><br><span class="line">	s, isZeroed := mheap_.alloc(npages, spc, needzero)</span><br><span class="line">	<span class="keyword">if</span> s == <span class="literal">nil</span> &#123;</span><br><span class="line">		throw(<span class="string">&quot;out of memory&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	stats := memstats.heapStats.acquire()</span><br><span class="line">	atomic.Xadduintptr(&amp;stats.largeAlloc, npages*pageSize)</span><br><span class="line">	atomic.Xadduintptr(&amp;stats.largeAllocCount, <span class="number">1</span>)</span><br><span class="line">	memstats.heapStats.release()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Update gcController.heapLive and revise pacing if needed.</span></span><br><span class="line">	atomic.Xadd64(&amp;gcController.heapLive, <span class="type">int64</span>(npages*pageSize))</span><br><span class="line">	<span class="keyword">if</span> trace.enabled &#123;</span><br><span class="line">		<span class="comment">// Trace that a heap alloc occurred because gcController.heapLive changed.</span></span><br><span class="line">		traceHeapAlloc()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> gcBlackenEnabled != <span class="number">0</span> &#123;</span><br><span class="line">		gcController.revise()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Put the large span in the mcentral swept list so that it&#x27;s</span></span><br><span class="line">	<span class="comment">// visible to the background sweeper.</span></span><br><span class="line">	mheap_.central[spc].mcentral.fullSwept(mheap_.sweepgen).push(s)</span><br><span class="line">	s.limit = s.base() + size</span><br><span class="line">	heapBitsForAddr(s.base()).initSpan(s)</span><br><span class="line">	<span class="keyword">return</span> s, isZeroed</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**************** [mcentral.go] ****************/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> mcentral <span class="keyword">struct</span> &#123;</span><br><span class="line">  <span class="comment">/* 当前 mcentral 所属的 span class */</span></span><br><span class="line">	spanclass spanClass</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * partial 和 full 各包含两个 mspan set：一个是已经清理的 span，另一个是未清理的 span。</span></span><br><span class="line"><span class="comment">   * 每次 GC 后，已清理的和未清理的 spanSet 会互换。未清理的 spanSet 会被内存分配器或是 GC 后台清理器抽取。</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   * 每次 GC，sweepgen 会被 +2，所以已清理的 spanSet = partial[sweepgen/2%2]，</span></span><br><span class="line"><span class="comment">   * 未清理的 spanSet = partial[1 - sweepgen/2%2]</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">	partial [<span class="number">2</span>]spanSet <span class="comment">// list of spans with a free object</span></span><br><span class="line">	full    [<span class="number">2</span>]spanSet <span class="comment">// list of spans with no free objects</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 向 mcache 提供 span 的具体方法 */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *mcentral)</span></span> cacheSpan() *mspan &#123;</span><br><span class="line">	... ...</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 不论是在部分空闲还是无空闲列表中尝试超过 spanBudget 次，还没有找到合适的 span，</span></span><br><span class="line"><span class="comment">   * 就直接分配一个新的 span，以此减小对小对象清理的开销 </span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">	spanBudget := <span class="number">100</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> s *mspan</span><br><span class="line">	sl := newSweepLocker()</span><br><span class="line">	sg := sl.sweepGen</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 先尝试从已清理的部分空闲集合中获取 span */</span></span><br><span class="line">	<span class="keyword">if</span> s = c.partialSwept(sg).pop(); s != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">goto</span> havespan</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 如果没有，就从未清理部分空闲集合中获取 span */</span></span><br><span class="line">	<span class="keyword">for</span> ; spanBudget &gt;= <span class="number">0</span>; spanBudget-- &#123;</span><br><span class="line">		s = c.partialUnswept(sg).pop()</span><br><span class="line">		<span class="keyword">if</span> s == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> s, ok := sl.tryAcquire(s); ok &#123;</span><br><span class="line">			<span class="comment">/* 锁定了一个未清理的 span，将其清理后使用 */</span></span><br><span class="line">			s.sweep(<span class="literal">true</span>)</span><br><span class="line">			sl.dispose()</span><br><span class="line">			<span class="keyword">goto</span> havespan</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/* 假如没能锁定当前的未清理 span，说明它已经被后台异步清理器锁定了，但还没有来得及将其处理完并移除出未清理列表，找下一个 */</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">  <span class="comment">/* 如果还是没有，尝试从未清理无空闲列表中获取 span */</span></span><br><span class="line">	<span class="keyword">for</span> ; spanBudget &gt;= <span class="number">0</span>; spanBudget-- &#123;</span><br><span class="line">		s = c.fullUnswept(sg).pop()</span><br><span class="line">		<span class="keyword">if</span> s == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> s, ok := sl.tryAcquire(s); ok &#123;</span><br><span class="line">			<span class="comment">/* 还是先清理 */</span></span><br><span class="line">			s.sweep(<span class="literal">true</span>)</span><br><span class="line">			<span class="comment">/* 之后看看是不是空出了空闲位置 */</span></span><br><span class="line">			freeIndex := s.nextFreeIndex()</span><br><span class="line">			<span class="keyword">if</span> freeIndex != s.nelems &#123;</span><br><span class="line">				s.freeindex = freeIndex</span><br><span class="line">				sl.dispose()</span><br><span class="line">				<span class="keyword">goto</span> havespan</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">/* 若没找到任何空闲位置，把它放入已扫描无空闲列表中，重试下一个 */</span></span><br><span class="line">			c.fullSwept(sg).push(s.mspan)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// See comment for partial unswept spans.</span></span><br><span class="line">	&#125;</span><br><span class="line">	sl.dispose()</span><br><span class="line">	<span class="keyword">if</span> trace.enabled &#123;</span><br><span class="line">		traceGCSweepDone()</span><br><span class="line">		traceDone = <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 实在找不到可使用的现存 span 了，向 heap 申请新的，假如还申请不到就只好 OOM */</span></span><br><span class="line">	s = c.grow()</span><br><span class="line">	<span class="keyword">if</span> s == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 程序执行到此处，证明一定找到一个有空闲的 span 了 */</span></span><br><span class="line">havespan:</span><br><span class="line">	<span class="keyword">if</span> trace.enabled &amp;&amp; !traceDone &#123;</span><br><span class="line">		traceGCSweepDone()</span><br><span class="line">	&#125;</span><br><span class="line">	n := <span class="type">int</span>(s.nelems) - <span class="type">int</span>(s.allocCount)</span><br><span class="line">	<span class="keyword">if</span> n == <span class="number">0</span> || s.freeindex == s.nelems || <span class="type">uintptr</span>(s.allocCount) == s.nelems &#123;</span><br><span class="line">		throw(<span class="string">&quot;span has no free objects&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	freeByteBase := s.freeindex &amp;^ (<span class="number">64</span> - <span class="number">1</span>)</span><br><span class="line">	whichByte := freeByteBase / <span class="number">8</span></span><br><span class="line">	<span class="comment">// Init alloc bits cache.</span></span><br><span class="line">	s.refillAllocCache(whichByte)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Adjust the allocCache so that s.freeindex corresponds to the low bit in</span></span><br><span class="line">	<span class="comment">// s.allocCache.</span></span><br><span class="line">	s.allocCache &gt;&gt;= s.freeindex % <span class="number">64</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 从 heap 中申请新 span */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *mcentral)</span></span> grow() *mspan &#123;</span><br><span class="line">	npages := <span class="type">uintptr</span>(class_to_allocnpages[c.spanclass.sizeclass()])</span><br><span class="line">	size := <span class="type">uintptr</span>(class_to_size[c.spanclass.sizeclass()])</span><br><span class="line"></span><br><span class="line">	s, _ := mheap_.alloc(npages, c.spanclass, <span class="literal">true</span>)</span><br><span class="line">	<span class="keyword">if</span> s == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Use division by multiplication and shifts to quickly compute:</span></span><br><span class="line">	<span class="comment">// n := (npages &lt;&lt; _PageShift) / size</span></span><br><span class="line">	n := s.divideByElemSize(npages &lt;&lt; _PageShift)</span><br><span class="line">	s.limit = s.base() + size*n</span><br><span class="line">	heapBitsForAddr(s.base()).initSpan(s)</span><br><span class="line">	<span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 从 mcache 回收 span </span></span><br><span class="line"><span class="comment"> * span 的 sweepgen 与全局 sweepgen 的关系：</span></span><br><span class="line"><span class="comment"> * span sweepgen == 全局 sweepgen - 2：需要清理</span></span><br><span class="line"><span class="comment"> * span sweepgen == 全局 sweepgen - 1：正被清理</span></span><br><span class="line"><span class="comment"> * span sweepgen == 全局 sweepgen：清理完成，且可用</span></span><br><span class="line"><span class="comment"> * span sweepgen == 全局 sweepgen + 1：在清理前就被 cache 了，需要清理</span></span><br><span class="line"><span class="comment"> * span sweepgen == 全局 sweepgen + 3：清理完成且仍旧是 cache 状态</span></span><br><span class="line"><span class="comment"> * 全局 sweepgen 每次 GC 自动 +2</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *mcentral)</span></span> uncacheSpan(s *mspan) &#123;</span><br><span class="line">	<span class="keyword">if</span> s.allocCount == <span class="number">0</span> &#123;</span><br><span class="line">		throw(<span class="string">&quot;uncaching span but s.allocCount == 0&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	sg := mheap_.sweepgen</span><br><span class="line">  <span class="comment">/* 若等于 sg+1 代表需要清理 */</span></span><br><span class="line">	stale := s.sweepgen == sg+<span class="number">1</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Fix up sweepgen.</span></span><br><span class="line">	<span class="keyword">if</span> stale &#123;</span><br><span class="line">		<span class="comment">/* 去除 cache 状态，且正在清理 */</span></span><br><span class="line">		atomic.Store(&amp;s.sweepgen, sg<span class="number">-1</span>)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">/* 去除 cache 状态 */</span></span><br><span class="line">		atomic.Store(&amp;s.sweepgen, sg)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Put the span in the appropriate place.</span></span><br><span class="line">	<span class="keyword">if</span> stale &#123;</span><br><span class="line">    <span class="comment">/* stale 的 span 不在全局清理列表中，可以直接锁定 */</span></span><br><span class="line">		ss := sweepLocked&#123;s&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 清理，由于传入参数 preserve == false，所以清理完后就归还给 heap 或 spanSet */</span></span><br><span class="line">		ss.sweep(<span class="literal">false</span>)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> <span class="type">int</span>(s.nelems)-<span class="type">int</span>(s.allocCount) &gt; <span class="number">0</span> &#123;</span><br><span class="line">			<span class="comment">/* 还有空余，归还到已清理部分空闲列表 */</span></span><br><span class="line">			c.partialSwept(sg).push(s)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">/* 没有空余了，归还到已清理无空闲列表 */</span></span><br><span class="line">			c.fullSwept(sg).push(s)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**************** [mheap.go] ****************/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> mheap <span class="keyword">struct</span> &#123;</span><br><span class="line">	lock  mutex</span><br><span class="line">  <span class="comment">/* 页分配器 */</span></span><br><span class="line">	pages pageAlloc <span class="comment">// page allocation data structure</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 清理相关 */</span></span><br><span class="line">	sweepgen     <span class="type">uint32</span> <span class="comment">// sweep generation, see comment in mspan; written during STW</span></span><br><span class="line">	sweepDrained <span class="type">uint32</span> <span class="comment">// all spans are swept or are being swept</span></span><br><span class="line">	sweepers     <span class="type">uint32</span> <span class="comment">// number of active sweepone calls</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 所有被创建出来的 span */</span></span><br><span class="line">	allspans []*mspan <span class="comment">// all spans out there</span></span><br><span class="line"></span><br><span class="line">	_ <span class="type">uint32</span> <span class="comment">// align uint64 fields on 32-bit for atomics</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 扫描清理相关参数 */</span></span><br><span class="line">	pagesInUse         <span class="type">uint64</span>  <span class="comment">// pages of spans in stats mSpanInUse; updated atomically</span></span><br><span class="line">	pagesSwept         <span class="type">uint64</span>  <span class="comment">// pages swept this cycle; updated atomically</span></span><br><span class="line">	pagesSweptBasis    <span class="type">uint64</span>  <span class="comment">// pagesSwept to use as the origin of the sweep ratio; updated atomically</span></span><br><span class="line">	sweepHeapLiveBasis <span class="type">uint64</span>  <span class="comment">// value of gcController.heapLive to use as the origin of sweep ratio; written with lock, read without</span></span><br><span class="line">	sweepPagesPerByte  <span class="type">float64</span> <span class="comment">// proportional sweep ratio; written with lock, read without</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* runtime 保留的将要还给 os 的内存数量 */</span></span><br><span class="line">	scavengeGoal <span class="type">uint64</span></span><br><span class="line">  </span><br><span class="line">	<span class="comment">// This is accessed atomically.</span></span><br><span class="line">  <span class="comment">/* 页回收状态</span></span><br><span class="line"><span class="comment">   * reclaimIndex：指向 allArenas 中下一个待回收的页</span></span><br><span class="line"><span class="comment">   * reclaimCredit：清理出的比所需空间更多的空间，计数并放入 reclaimCredit</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">	reclaimIndex <span class="type">uint64</span></span><br><span class="line">	reclaimCredit <span class="type">uintptr</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* arena map，每个 arena 帧管理着一块虚拟地址空间</span></span><br><span class="line"><span class="comment">   * heap 中未分配的空间，arena 指向 nil</span></span><br><span class="line"><span class="comment">   * 为了节省 arena 帧的数量，可能会存在多级 arena map，但在多数的 64 位平台上，只有一级</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">	arenas [<span class="number">1</span> &lt;&lt; arenaL1Bits]*[<span class="number">1</span> &lt;&lt; arenaL2Bits]*heapArena</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 用于存放 heapArena map，防止与 heap 本身产生交错 */</span></span><br><span class="line">	heapArenaAlloc linearAlloc</span><br><span class="line">  </span><br><span class="line">	arenaHints *arenaHint</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 用于存放 arena 本身 */</span></span><br><span class="line">	arena linearAlloc</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 所有已经分配的 arena index，用做基于地址空间迭代 */</span></span><br><span class="line">	allArenas []arenaIdx</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 在清理周期开始前对 allArenas 的快照 */</span></span><br><span class="line">	sweepArenas []arenaIdx</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 在标记周期开始前对 allArenas 的快照 */</span></span><br><span class="line">	markArenas []arenaIdx</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 当前 heap 生长到的 arena */</span></span><br><span class="line">	curArena <span class="keyword">struct</span> &#123;</span><br><span class="line">		base, end <span class="type">uintptr</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	_ <span class="type">uint32</span> <span class="comment">// ensure 64-bit alignment of central</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* mcentral 列表，68*2，分别包含 scan 与 noscan 两类 */</span></span><br><span class="line">	central [numSpanClasses]<span class="keyword">struct</span> &#123;</span><br><span class="line">		mcentral mcentral</span><br><span class="line">		pad      [cpu.CacheLinePadSize - unsafe.Sizeof(mcentral&#123;&#125;)%cpu.CacheLinePadSize]<span class="type">byte</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 各种固定大小对象内存分配器 */</span></span><br><span class="line">	spanalloc             fixalloc <span class="comment">// allocator for span*</span></span><br><span class="line">	cachealloc            fixalloc <span class="comment">// allocator for mcache*</span></span><br><span class="line">	specialfinalizeralloc fixalloc <span class="comment">// allocator for specialfinalizer*</span></span><br><span class="line">	specialprofilealloc   fixalloc <span class="comment">// allocator for specialprofile*</span></span><br><span class="line">	specialReachableAlloc fixalloc <span class="comment">// allocator for specialReachable</span></span><br><span class="line">	speciallock           mutex    <span class="comment">// lock for special record allocators.</span></span><br><span class="line">	arenaHintAlloc        fixalloc <span class="comment">// allocator for arenaHints</span></span><br><span class="line"></span><br><span class="line">	unused *specialfinalizer <span class="comment">// never set, just here to force the specialfinalizer type into DWARF</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始化 heap */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *mheap)</span></span> init() &#123;</span><br><span class="line">  ... ...</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 初始化各种 Fixed Size 对象分配器，init 中的 first 是钩子函数，会在每一次分配时调用*/</span></span><br><span class="line">	h.spanalloc.init(unsafe.Sizeof(mspan&#123;&#125;), recordspan, unsafe.Pointer(h), &amp;memstats.mspan_sys)</span><br><span class="line">	h.cachealloc.init(unsafe.Sizeof(mcache&#123;&#125;), <span class="literal">nil</span>, <span class="literal">nil</span>, &amp;memstats.mcache_sys)</span><br><span class="line">	h.specialfinalizeralloc.init(unsafe.Sizeof(specialfinalizer&#123;&#125;), <span class="literal">nil</span>, <span class="literal">nil</span>, &amp;memstats.other_sys)</span><br><span class="line">	h.specialprofilealloc.init(unsafe.Sizeof(specialprofile&#123;&#125;), <span class="literal">nil</span>, <span class="literal">nil</span>, &amp;memstats.other_sys)</span><br><span class="line">	h.specialReachableAlloc.init(unsafe.Sizeof(specialReachable&#123;&#125;), <span class="literal">nil</span>, <span class="literal">nil</span>, &amp;memstats.other_sys)</span><br><span class="line">	h.arenaHintAlloc.init(unsafe.Sizeof(arenaHint&#123;&#125;), <span class="literal">nil</span>, <span class="literal">nil</span>, &amp;memstats.other_sys)</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 分配的 span 不需要 0 初始化 */</span></span><br><span class="line">	h.spanalloc.zero = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 初始化 mcentral */</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> h.central &#123;</span><br><span class="line">		h.central[i].mcentral.init(spanClass(i))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 初始化页分配器 */</span></span><br><span class="line">	h.pages.init(&amp;h.lock, &amp;memstats.gcMiscSys)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 堆内存分配入口 */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *mheap)</span></span> alloc(npages <span class="type">uintptr</span>, spanclass spanClass, needzero <span class="type">bool</span>) (*mspan, <span class="type">bool</span>) &#123;</span><br><span class="line">	<span class="keyword">var</span> s *mspan</span><br><span class="line">  <span class="comment">/* 必须在系统栈上操作 heap，否则可能会触发栈扩容，而栈扩容本身可能会导致调用本方法 */</span></span><br><span class="line">	systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="comment">/* 为了防止 heap 过多的被分配，在分配空间之前，先尝试回收至少 npages 空间</span></span><br><span class="line"><span class="comment">		 *（如果 isSweepDone == true 证明所有 span 都扫描过了，也就不需要再尝试回收） </span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">		<span class="keyword">if</span> !isSweepDone() &#123;</span><br><span class="line">      <span class="comment">/* 尝试回收 npages 页内存 */</span></span><br><span class="line">			h.reclaim(npages)</span><br><span class="line">		&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 按需要分配 span */</span></span><br><span class="line">		s = h.allocSpan(npages, spanAllocHeap, spanclass)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> s == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	isZeroed := s.needzero == <span class="number">0</span></span><br><span class="line">	<span class="keyword">if</span> needzero &amp;&amp; !isZeroed &#123;</span><br><span class="line">    <span class="comment">/* 内存清零 */</span></span><br><span class="line">		memclrNoHeapPointers(unsafe.Pointer(s.base()), s.npages&lt;&lt;_PageShift)</span><br><span class="line">		isZeroed = <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">	s.needzero = <span class="number">0</span></span><br><span class="line">	<span class="keyword">return</span> s, isZeroed</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 回收内存 */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *mheap)</span></span> reclaim(npage <span class="type">uintptr</span>) &#123;</span><br><span class="line">	... ...</span><br><span class="line"></span><br><span class="line">	arenas := h.sweepArenas</span><br><span class="line">	locked := <span class="literal">false</span></span><br><span class="line">	<span class="keyword">for</span> npage &gt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">/* 前文提到 reclaimCredit 代表每次回收内存时多回收的页数，因此此处先从 reclaimCredit 中扣减 */</span></span><br><span class="line">		<span class="keyword">if</span> credit := atomic.Loaduintptr(&amp;h.reclaimCredit); credit &gt; <span class="number">0</span> &#123;</span><br><span class="line">			take := credit</span><br><span class="line">			<span class="keyword">if</span> take &gt; npage &#123;</span><br><span class="line">				<span class="comment">// Take only what we need.</span></span><br><span class="line">				take = npage</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> atomic.Casuintptr(&amp;h.reclaimCredit, credit, credit-take) &#123;</span><br><span class="line">				npage -= take</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 从 reclaimIndex 获取需要回收的 chunk（512 个页大小的块） 的起始 id*/</span></span><br><span class="line">		<span class="comment">// Claim a chunk of work.</span></span><br><span class="line">		idx := <span class="type">uintptr</span>(atomic.Xadd64(&amp;h.reclaimIndex, pagesPerReclaimerChunk) - pagesPerReclaimerChunk)</span><br><span class="line">		<span class="keyword">if</span> idx/pagesPerArena &gt;= <span class="type">uintptr</span>(<span class="built_in">len</span>(arenas)) &#123;</span><br><span class="line">			<span class="comment">// Page reclaiming is done.</span></span><br><span class="line">			atomic.Store64(&amp;h.reclaimIndex, <span class="number">1</span>&lt;&lt;<span class="number">63</span>)</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> !locked &#123;</span><br><span class="line">			<span class="comment">// Lock the heap for reclaimChunk.</span></span><br><span class="line">			lock(&amp;h.lock)</span><br><span class="line">			locked = <span class="literal">true</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 扫描并回收，范围是 pagesPerReclaimerChunk 个页 */</span></span><br><span class="line">		nfound := h.reclaimChunk(arenas, idx, pagesPerReclaimerChunk)</span><br><span class="line">		<span class="keyword">if</span> nfound &lt;= npage &#123;</span><br><span class="line">			npage -= nfound</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">/* 若回收了多于 npages 的页，将其计数累加到 reclaimCredit */</span></span><br><span class="line">			atomic.Xadduintptr(&amp;h.reclaimCredit, nfound-npage)</span><br><span class="line">			npage = <span class="number">0</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">  ... ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 扫描并回收 */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *mheap)</span></span> reclaimChunk(arenas []arenaIdx, pageIdx, n <span class="type">uintptr</span>) <span class="type">uintptr</span> &#123;</span><br><span class="line">	... ...</span><br><span class="line">  </span><br><span class="line">	<span class="keyword">for</span> n &gt; <span class="number">0</span> &#123;</span><br><span class="line">		ai := arenas[pageIdx/pagesPerArena]</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 找到管理起始页的 arena */</span></span><br><span class="line">		ha := h.arenas[ai.l1()][ai.l2()]</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 获取起始页在当前 arena 内的相对位置（位图） */</span></span><br><span class="line">		arenaPage := <span class="type">uint</span>(pageIdx % pagesPerArena)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 计算从起始页位开始的所有 pageInUse 和 pageMarks 位，过长则截断 */</span></span><br><span class="line">		inUse := ha.pageInUse[arenaPage/<span class="number">8</span>:]</span><br><span class="line">		marked := ha.pageMarks[arenaPage/<span class="number">8</span>:]</span><br><span class="line">		<span class="keyword">if</span> <span class="type">uintptr</span>(<span class="built_in">len</span>(inUse)) &gt; n/<span class="number">8</span> &#123;</span><br><span class="line">			inUse = inUse[:n/<span class="number">8</span>]</span><br><span class="line">			marked = marked[:n/<span class="number">8</span>]</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 查找这个 chunk 内正在使用且没有被标记对象（inUseUnmarked）的 span */</span></span><br><span class="line">		<span class="keyword">for</span> i := <span class="keyword">range</span> inUse &#123;</span><br><span class="line">			<span class="comment">/* 当前 inUse[i] 所指示的 8 个 span，都不符合要求 */</span></span><br><span class="line">      inUseUnmarked := atomic.Load8(&amp;inUse[i]) &amp;^ marked[i]</span><br><span class="line">			<span class="keyword">if</span> inUseUnmarked == <span class="number">0</span> &#123;</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">for</span> j := <span class="type">uint</span>(<span class="number">0</span>); j &lt; <span class="number">8</span>; j++ &#123;</span><br><span class="line">				<span class="keyword">if</span> inUseUnmarked&amp;(<span class="number">1</span>&lt;&lt;j) != <span class="number">0</span> &#123;</span><br><span class="line">					s := ha.spans[arenaPage+<span class="type">uint</span>(i)*<span class="number">8</span>+j]</span><br><span class="line">					<span class="keyword">if</span> s, ok := sl.tryAcquire(s); ok &#123;</span><br><span class="line">						npages := s.npages</span><br><span class="line">						unlock(&amp;h.lock)</span><br><span class="line">            <span class="comment">/* 找到当前指示的 span，尝试清除 */</span></span><br><span class="line">						<span class="keyword">if</span> s.sweep(<span class="literal">false</span>) &#123;</span><br><span class="line">							nFreed += npages</span><br><span class="line">						&#125;</span><br><span class="line">						lock(&amp;h.lock)</span><br><span class="line">						<span class="comment">// Reload inUse. It&#x27;s possible nearby</span></span><br><span class="line">						<span class="comment">// spans were freed when we dropped the</span></span><br><span class="line">						<span class="comment">// lock and we don&#x27;t want to get stale</span></span><br><span class="line">						<span class="comment">// pointers from the spans array.</span></span><br><span class="line">						inUseUnmarked = atomic.Load8(&amp;inUse[i]) &amp;^ marked[i]</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Advance.</span></span><br><span class="line">		pageIdx += <span class="type">uintptr</span>(<span class="built_in">len</span>(inUse) * <span class="number">8</span>)</span><br><span class="line">		n -= <span class="type">uintptr</span>(<span class="built_in">len</span>(inUse) * <span class="number">8</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	sl.dispose()</span><br><span class="line">	... ...</span><br><span class="line">	<span class="keyword">return</span> nFreed</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 分配 span */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *mheap)</span></span> allocSpan(npages <span class="type">uintptr</span>, typ spanAllocType, spanclass spanClass) (s *mspan) &#123;</span><br><span class="line">	... ...</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 对于小于四分之一 pageCachePages 的分配请求，优先从每一个 p 的 pageCache 中分配</span></span><br><span class="line"><span class="comment">   * pageCachePages = 8 * unsafe.Sizeof(pageCache&#123;&#125;.cache) = 64，cache 是 uint64 类型的 bitmap</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">	pp := gp.m.p.ptr()</span><br><span class="line">	<span class="keyword">if</span> !needPhysPageAlign &amp;&amp; pp != <span class="literal">nil</span> &amp;&amp; npages &lt; pageCachePages/<span class="number">4</span> &#123;</span><br><span class="line">		c := &amp;pp.pcache</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 若没有任何空闲空间了，则重新给 pageCache 分配空间，注意如果页分配器发现没有空闲空间了，会返回一个空的 pageCache 结构 */</span></span><br><span class="line">		<span class="keyword">if</span> c.empty() &#123;</span><br><span class="line">			lock(&amp;h.lock)</span><br><span class="line">			*c = h.pages.allocToCache()</span><br><span class="line">			unlock(&amp;h.lock)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 从 pageCache 中尝试寻找空闲空间 */</span></span><br><span class="line">		base, scav = c.alloc(npages)</span><br><span class="line">    <span class="comment">/* base 不为零，说明成功找到了空间 */</span></span><br><span class="line">		<span class="keyword">if</span> base != <span class="number">0</span> &#123;</span><br><span class="line">      <span class="comment">/* 尝试从 p 的 mspan cache 中获取 span 结构 */</span></span><br><span class="line">			s = h.tryAllocMSpan()</span><br><span class="line">			<span class="keyword">if</span> s != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">goto</span> HaveSpan</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* p 中的 pageCache 可以并发获取，但逻辑走到这里，就必须锁整个 heap */</span></span><br><span class="line">  lock(&amp;h.lock)</span><br><span class="line">  </span><br><span class="line">	... ...</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 从上面可以看到，如果是页分配器没有空间了，base 为零，因此需要新分配 */</span></span><br><span class="line">	<span class="keyword">if</span> base == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">/* 尝试直接从页分配器中寻找 npages 空间 */</span></span><br><span class="line">		base, scav = h.pages.alloc(npages)</span><br><span class="line">		<span class="keyword">if</span> base == <span class="number">0</span> &#123;</span><br><span class="line">      <span class="comment">/* 还是没空间，这时候必须要从 os 真正的申请新内存了 */</span></span><br><span class="line">			<span class="keyword">if</span> !h.grow(npages) &#123;</span><br><span class="line">				unlock(&amp;h.lock)</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">			&#125;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">/* 现在再次查找，一定能找到，否则就是 os 内存不足 */</span></span><br><span class="line">			base, scav = h.pages.alloc(npages)</span><br><span class="line">			<span class="keyword">if</span> base == <span class="number">0</span> &#123;</span><br><span class="line">				throw(<span class="string">&quot;grew heap, but no adequate free space found&quot;</span>)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">  </span><br><span class="line">	<span class="keyword">if</span> s == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">/* 没有 span，就创建一个新的来（创建的同时也放入了 p 的 spancache） */</span></span><br><span class="line">		s = h.allocMSpanLocked()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	... ...</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 与 heap 相关的操作结束了，释放锁 */</span></span><br><span class="line">	unlock(&amp;h.lock)</span><br><span class="line"></span><br><span class="line">HaveSpan:</span><br><span class="line">	<span class="comment">/* 下面是将 span 进行初始化，包括 base 地址等等 */</span></span><br><span class="line">	s.init(base, npages)</span><br><span class="line">	<span class="keyword">if</span> h.allocNeedsZero(base, npages) &#123;</span><br><span class="line">		s.needzero = <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line">	nbytes := npages * pageSize</span><br><span class="line">	<span class="keyword">if</span> typ.manual() &#123;</span><br><span class="line">    <span class="comment">/* 栈空间分配与 span class 无关 */</span></span><br><span class="line">		s.manualFreeList = <span class="number">0</span></span><br><span class="line">		s.nelems = <span class="number">0</span></span><br><span class="line">		s.limit = s.base() + s.npages*pageSize</span><br><span class="line">		s.state.set(mSpanManual)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">/* 按照 span class 初始化其他相关属性 */</span></span><br><span class="line">		s.spanclass = spanclass</span><br><span class="line">		<span class="keyword">if</span> sizeclass := spanclass.sizeclass(); sizeclass == <span class="number">0</span> &#123;</span><br><span class="line">			s.elemsize = nbytes</span><br><span class="line">			s.nelems = <span class="number">1</span></span><br><span class="line">			s.divMul = <span class="number">0</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			s.elemsize = <span class="type">uintptr</span>(class_to_size[sizeclass])</span><br><span class="line">			s.nelems = nbytes / s.elemsize</span><br><span class="line">			s.divMul = class_to_divmagic[sizeclass]</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Initialize mark and allocation structures.</span></span><br><span class="line">		s.freeindex = <span class="number">0</span></span><br><span class="line">		s.allocCache = ^<span class="type">uint64</span>(<span class="number">0</span>) <span class="comment">// all 1s indicating all free.</span></span><br><span class="line">		s.gcmarkBits = newMarkBits(s.nelems)</span><br><span class="line">		s.allocBits = newAllocBits(s.nelems)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// It&#x27;s safe to access h.sweepgen without the heap lock because it&#x27;s</span></span><br><span class="line">		<span class="comment">// only ever updated with the world stopped and we run on the</span></span><br><span class="line">		<span class="comment">// systemstack which blocks a STW transition.</span></span><br><span class="line">		atomic.Store(&amp;s.sweepgen, h.sweepgen)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Now that the span is filled in, set its state. This</span></span><br><span class="line">		<span class="comment">// is a publication barrier for the other fields in</span></span><br><span class="line">		<span class="comment">// the span. While valid pointers into this span</span></span><br><span class="line">		<span class="comment">// should never be visible until the span is returned,</span></span><br><span class="line">		<span class="comment">// if the garbage collector finds an invalid pointer,</span></span><br><span class="line">		<span class="comment">// access to the span may race with initialization of</span></span><br><span class="line">		<span class="comment">// the span. We resolve this race by atomically</span></span><br><span class="line">		<span class="comment">// setting the state after the span is fully</span></span><br><span class="line">		<span class="comment">// initialized, and atomically checking the state in</span></span><br><span class="line">		<span class="comment">// any situation where a pointer is suspect.</span></span><br><span class="line">		s.state.set(mSpanInUse)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Commit and account for any scavenged memory that the span now owns.</span></span><br><span class="line">	<span class="keyword">if</span> scav != <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// sysUsed all the pages that are actually available</span></span><br><span class="line">		<span class="comment">// in the span since some of them might be scavenged.</span></span><br><span class="line">		sysUsed(unsafe.Pointer(base), nbytes)</span><br><span class="line">		atomic.Xadd64(&amp;memstats.heap_released, -<span class="type">int64</span>(scav))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Update stats.</span></span><br><span class="line">	<span class="keyword">if</span> typ == spanAllocHeap &#123;</span><br><span class="line">		atomic.Xadd64(&amp;memstats.heap_inuse, <span class="type">int64</span>(nbytes))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> typ.manual() &#123;</span><br><span class="line">		<span class="comment">// Manually managed memory doesn&#x27;t count toward heap_sys.</span></span><br><span class="line">		memstats.heap_sys.add(-<span class="type">int64</span>(nbytes))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Update consistent stats.</span></span><br><span class="line">	stats := memstats.heapStats.acquire()</span><br><span class="line">	atomic.Xaddint64(&amp;stats.committed, <span class="type">int64</span>(scav))</span><br><span class="line">	atomic.Xaddint64(&amp;stats.released, -<span class="type">int64</span>(scav))</span><br><span class="line">	<span class="keyword">switch</span> typ &#123;</span><br><span class="line">	<span class="keyword">case</span> spanAllocHeap:</span><br><span class="line">		atomic.Xaddint64(&amp;stats.inHeap, <span class="type">int64</span>(nbytes))</span><br><span class="line">	<span class="keyword">case</span> spanAllocStack:</span><br><span class="line">		atomic.Xaddint64(&amp;stats.inStacks, <span class="type">int64</span>(nbytes))</span><br><span class="line">	<span class="keyword">case</span> spanAllocPtrScalarBits:</span><br><span class="line">		atomic.Xaddint64(&amp;stats.inPtrScalarBits, <span class="type">int64</span>(nbytes))</span><br><span class="line">	<span class="keyword">case</span> spanAllocWorkBuf:</span><br><span class="line">		atomic.Xaddint64(&amp;stats.inWorkBufs, <span class="type">int64</span>(nbytes))</span><br><span class="line">	&#125;</span><br><span class="line">	memstats.heapStats.release()</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 将 span 加入对应的 arena */</span></span><br><span class="line">	h.setSpans(s.base(), npages, s)</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 将 span 加入对应的 pageInUse 中 */</span></span><br><span class="line">	<span class="keyword">if</span> !typ.manual() &#123;</span><br><span class="line">		<span class="comment">// Mark in-use span in arena page bitmap.</span></span><br><span class="line">		<span class="comment">//</span></span><br><span class="line">		<span class="comment">// This publishes the span to the page sweeper, so</span></span><br><span class="line">		<span class="comment">// it&#x27;s imperative that the span be completely initialized</span></span><br><span class="line">		<span class="comment">// prior to this line.</span></span><br><span class="line">		arena, pageIdx, pageMask := pageIndexOf(s.base())</span><br><span class="line">		atomic.Or8(&amp;arena.pageInUse[pageIdx], pageMask)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Update related page sweeper stats.</span></span><br><span class="line">		atomic.Xadd64(&amp;h.pagesInUse, <span class="type">int64</span>(npages))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Make sure the newly allocated span will be observed</span></span><br><span class="line">	<span class="comment">// by the GC before pointers into the span are published.</span></span><br><span class="line">	publicationBarrier()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 释放 span */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *mheap)</span></span> freeSpanLocked(s *mspan, typ spanAllocType) &#123;</span><br><span class="line">	... ...</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 在页分配器处标记空闲 */</span></span><br><span class="line">	h.pages.free(s.base(), s.npages)</span><br><span class="line"></span><br><span class="line">	... ...</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* span 结构也释放掉 */</span></span><br><span class="line">	h.freeMSpanLocked(s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 尝试扩张新内存 */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *mheap)</span></span> grow(npage <span class="type">uintptr</span>) <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="comment">/* grow 需要在加锁状态 */</span></span><br><span class="line">  assertLockHeld(&amp;h.lock)</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 按 chunk 所管理的页数整数对齐 */</span></span><br><span class="line">	ask := alignUp(npage, pallocChunkPages) * pageSize</span><br><span class="line"></span><br><span class="line">	totalGrowth := <span class="type">uintptr</span>(<span class="number">0</span>)</span><br><span class="line">	<span class="comment">// This may overflow because ask could be very large</span></span><br><span class="line">	<span class="comment">// and is otherwise unrelated to h.curArena.base.</span></span><br><span class="line">	end := h.curArena.base + ask</span><br><span class="line">	nBase := alignUp(end, physPageSize)</span><br><span class="line">	<span class="keyword">if</span> nBase &gt; h.curArena.end || <span class="comment">/* overflow */</span> end &lt; h.curArena.base &#123;</span><br><span class="line">		<span class="comment">/* 当前的 arena 放不下需要扩张的空间，因此必须重新申请新的 arena */</span></span><br><span class="line">		av, asize := h.sysAlloc(ask)</span><br><span class="line">		<span class="keyword">if</span> av == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="built_in">print</span>(<span class="string">&quot;runtime: out of memory: cannot allocate &quot;</span>, ask, <span class="string">&quot;-byte block (&quot;</span>, memstats.heap_sys, <span class="string">&quot; in use)\n&quot;</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> <span class="type">uintptr</span>(av) == h.curArena.end &#123;</span><br><span class="line">			<span class="comment">/* 如果新分配的空间起始地址等于 curArena 的结束地址，说明分配了连续内存，直接扩展 curArena */</span></span><br><span class="line">			h.curArena.end = <span class="type">uintptr</span>(av) + asize</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">/* 若不连续，需要把 curArena 切到新申请的空间，而原 arena 空间需要释放给 */</span></span><br><span class="line">			<span class="keyword">if</span> size := h.curArena.end - h.curArena.base; size != <span class="number">0</span> &#123;</span><br><span class="line">				<span class="comment">/* Reserved -&gt; Prepared 以备后用 */</span></span><br><span class="line">				sysMap(unsafe.Pointer(h.curArena.base), size, &amp;memstats.heap_sys)</span><br><span class="line">				... ...</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* 把这段空间发布给页分配器 */</span></span><br><span class="line">				h.pages.grow(h.curArena.base, size)</span><br><span class="line">				totalGrowth += size</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">/* 切到新的 arean 上 */</span></span><br><span class="line">			h.curArena.base = <span class="type">uintptr</span>(av)</span><br><span class="line">			h.curArena.end = <span class="type">uintptr</span>(av) + asize</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		... ...</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Grow into the current arena.</span></span><br><span class="line">	v := h.curArena.base</span><br><span class="line">	h.curArena.base = nBase</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 新空间 Reserved -&gt; Prepared.</span></span><br><span class="line">	sysMap(unsafe.Pointer(v), nBase-v, &amp;memstats.heap_sys)</span><br><span class="line">  </span><br><span class="line">	... ...</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 实际占用的空间是从 v 开始，大小为 nBase-v 的空间区域，更新页分配器使这部分空间可被分配 */</span></span><br><span class="line">	h.pages.grow(v, nBase-v)</span><br><span class="line">	totalGrowth += nBase - v</span><br><span class="line"></span><br><span class="line">	<span class="comment">// We just caused a heap growth, so scavenge down what will soon be used.</span></span><br><span class="line">	<span class="comment">// By scavenging inline we deal with the failure to allocate out of</span></span><br><span class="line">	<span class="comment">// memory fragments by scavenging the memory fragments that are least</span></span><br><span class="line">	<span class="comment">// likely to be re-used.</span></span><br><span class="line">	<span class="keyword">if</span> retained := heapRetained(); retained+<span class="type">uint64</span>(totalGrowth) &gt; h.scavengeGoal &#123;</span><br><span class="line">		todo := totalGrowth</span><br><span class="line">		<span class="keyword">if</span> overage := <span class="type">uintptr</span>(retained + <span class="type">uint64</span>(totalGrowth) - h.scavengeGoal); todo &gt; overage &#123;</span><br><span class="line">			todo = overage</span><br><span class="line">		&#125;</span><br><span class="line">		h.pages.scavenge(todo, <span class="literal">false</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *mheap)</span></span> sysAlloc(n <span class="type">uintptr</span>) (v unsafe.Pointer, size <span class="type">uintptr</span>) &#123;</span><br><span class="line">	... ...</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 只在 32 位平台生效：先从预留空间中尝试分配，预留空间 arena 会在 mallocinit 时被初始化 */</span></span><br><span class="line">	v = h.arena.alloc(n, heapArenaBytes, &amp;memstats.heap_sys)</span><br><span class="line">	<span class="keyword">if</span> v != <span class="literal">nil</span> &#123;</span><br><span class="line">		size = n</span><br><span class="line">		<span class="keyword">goto</span> mapped</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 通过 arenaHint 申请 os 内存 */</span></span><br><span class="line">	<span class="keyword">for</span> h.arenaHints != <span class="literal">nil</span> &#123;</span><br><span class="line">		hint := h.arenaHints</span><br><span class="line">		p := hint.addr</span><br><span class="line">		<span class="keyword">if</span> hint.down &#123;</span><br><span class="line">			p -= n</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> p+n &lt; p &#123;</span><br><span class="line">			<span class="comment">// We can&#x27;t use this, so don&#x27;t ask.</span></span><br><span class="line">			v = <span class="literal">nil</span></span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> arenaIndex(p+n<span class="number">-1</span>) &gt;= <span class="number">1</span>&lt;&lt;arenaBits &#123;</span><br><span class="line">			<span class="comment">// Outside addressable heap. Can&#x27;t use.</span></span><br><span class="line">			v = <span class="literal">nil</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			v = sysReserve(unsafe.Pointer(p), n)</span><br><span class="line">		&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 如果 os 返回的内存地址与 hint 中计算出的一致，申请成功 */</span></span><br><span class="line">		<span class="keyword">if</span> p == <span class="type">uintptr</span>(v) &#123;</span><br><span class="line">			<span class="comment">// Success. Update the hint.</span></span><br><span class="line">			<span class="keyword">if</span> !hint.down &#123;</span><br><span class="line">				p += n</span><br><span class="line">			&#125;</span><br><span class="line">			hint.addr = p</span><br><span class="line">			size = n</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">    </span><br><span class="line">		<span class="comment">/* 申请不成功则尝试下一个 hint，并释放当前 hint */</span></span><br><span class="line">		<span class="keyword">if</span> v != <span class="literal">nil</span> &#123;</span><br><span class="line">			sysFree(v, n, <span class="literal">nil</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		h.arenaHints = hint.next</span><br><span class="line">		h.arenaHintAlloc.free(unsafe.Pointer(hint))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 所有的 hint 都不管用了，直接向 os 申请新空间，并创建新的 hint */</span></span><br><span class="line">	<span class="keyword">if</span> size == <span class="number">0</span> &#123;</span><br><span class="line">		... ...</span><br><span class="line">    </span><br><span class="line">		v, size = sysReserveAligned(<span class="literal">nil</span>, n, heapArenaBytes)</span><br><span class="line">		<span class="keyword">if</span> v == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, <span class="number">0</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		hint := (*arenaHint)(h.arenaHintAlloc.alloc())</span><br><span class="line">		hint.addr, hint.down = <span class="type">uintptr</span>(v), <span class="literal">true</span></span><br><span class="line">		hint.next, mheap_.arenaHints = mheap_.arenaHints, hint</span><br><span class="line">		hint = (*arenaHint)(h.arenaHintAlloc.alloc())</span><br><span class="line">		hint.addr = <span class="type">uintptr</span>(v) + size</span><br><span class="line">		hint.next, mheap_.arenaHints = mheap_.arenaHints, hint</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	... ...</span><br><span class="line">  </span><br><span class="line">mapped:</span><br><span class="line">	<span class="comment">/* 对分配的内存创建 arena */</span></span><br><span class="line">	<span class="keyword">for</span> ri := arenaIndex(<span class="type">uintptr</span>(v)); ri &lt;= arenaIndex(<span class="type">uintptr</span>(v)+size<span class="number">-1</span>); ri++ &#123;</span><br><span class="line">		l2 := h.arenas[ri.l1()]</span><br><span class="line">		<span class="keyword">if</span> l2 == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="comment">/* 除了 64bit Windows 平台外，L1 都等于 1，L2 不存在则说明整个 arena map 未创建，因此创建之  */</span></span><br><span class="line">			l2 = (*[<span class="number">1</span> &lt;&lt; arenaL2Bits]*heapArena)(persistentalloc(unsafe.Sizeof(*l2), sys.PtrSize, <span class="literal">nil</span>))</span><br><span class="line">			<span class="keyword">if</span> l2 == <span class="literal">nil</span> &#123;</span><br><span class="line">				throw(<span class="string">&quot;out of memory allocating heap arena map&quot;</span>)</span><br><span class="line">			&#125;</span><br><span class="line">			atomic.StorepNoWB(unsafe.Pointer(&amp;h.arenas[ri.l1()]), unsafe.Pointer(l2))</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 上层 caller 在未找到 arean 时才会调用本方法，因此 arena 一定不存在 */</span></span><br><span class="line">		<span class="keyword">if</span> l2[ri.l2()] != <span class="literal">nil</span> &#123;</span><br><span class="line">			throw(<span class="string">&quot;arena already initialized&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 创建 arena */</span></span><br><span class="line">		<span class="keyword">var</span> r *heapArena</span><br><span class="line">		r = (*heapArena)(h.heapArenaAlloc.alloc(unsafe.Sizeof(*r), sys.PtrSize, &amp;memstats.gcMiscSys))</span><br><span class="line">		<span class="keyword">if</span> r == <span class="literal">nil</span> &#123;</span><br><span class="line">			r = (*heapArena)(persistentalloc(unsafe.Sizeof(*r), sys.PtrSize, &amp;memstats.gcMiscSys))</span><br><span class="line">			<span class="keyword">if</span> r == <span class="literal">nil</span> &#123;</span><br><span class="line">				throw(<span class="string">&quot;out of memory allocating heap arena metadata&quot;</span>)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 将新的 arena 加到 allArena 列表后面 */</span></span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(h.allArenas) == <span class="built_in">cap</span>(h.allArenas) &#123;</span><br><span class="line">			size := <span class="number">2</span> * <span class="type">uintptr</span>(<span class="built_in">cap</span>(h.allArenas)) * sys.PtrSize</span><br><span class="line">			<span class="keyword">if</span> size == <span class="number">0</span> &#123;</span><br><span class="line">				size = physPageSize</span><br><span class="line">			&#125;</span><br><span class="line">			newArray := (*notInHeap)(persistentalloc(size, sys.PtrSize, &amp;memstats.gcMiscSys))</span><br><span class="line">			<span class="keyword">if</span> newArray == <span class="literal">nil</span> &#123;</span><br><span class="line">				throw(<span class="string">&quot;out of memory allocating allArenas&quot;</span>)</span><br><span class="line">			&#125;</span><br><span class="line">			oldSlice := h.allArenas</span><br><span class="line">			*(*notInHeapSlice)(unsafe.Pointer(&amp;h.allArenas)) = notInHeapSlice&#123;newArray, <span class="built_in">len</span>(h.allArenas), <span class="type">int</span>(size / sys.PtrSize)&#125;</span><br><span class="line">			<span class="built_in">copy</span>(h.allArenas, oldSlice)</span><br><span class="line">			<span class="comment">// Do not free the old backing array because</span></span><br><span class="line">			<span class="comment">// there may be concurrent readers. Since we</span></span><br><span class="line">			<span class="comment">// double the array each time, this can lead</span></span><br><span class="line">			<span class="comment">// to at most 2x waste.</span></span><br><span class="line">		&#125;</span><br><span class="line">		h.allArenas = h.allArenas[:<span class="built_in">len</span>(h.allArenas)+<span class="number">1</span>]</span><br><span class="line">		h.allArenas[<span class="built_in">len</span>(h.allArenas)<span class="number">-1</span>] = ri</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Store atomically just in case an object from the</span></span><br><span class="line">		<span class="comment">// new heap arena becomes visible before the heap lock</span></span><br><span class="line">		<span class="comment">// is released (which shouldn&#x27;t happen, but there&#x27;s</span></span><br><span class="line">		<span class="comment">// little downside to this).</span></span><br><span class="line">		atomic.StorepNoWB(unsafe.Pointer(&amp;l2[ri.l2()]), unsafe.Pointer(r))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	... ...</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 内存管理单元 */</span></span><br><span class="line"><span class="keyword">type</span> mspan <span class="keyword">struct</span> &#123;</span><br><span class="line">	next *mspan     <span class="comment">// next span in list, or nil if none</span></span><br><span class="line">	prev *mspan     <span class="comment">// previous span in list, or nil if none</span></span><br><span class="line">	list *mSpanList <span class="comment">// For debugging. <span class="doctag">TODO:</span> Remove.</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 起始地址与管理页数 */</span></span><br><span class="line">	startAddr <span class="type">uintptr</span> <span class="comment">// address of first byte of span aka s.base()</span></span><br><span class="line">	npages    <span class="type">uintptr</span> <span class="comment">// number of pages in span</span></span><br><span class="line"></span><br><span class="line">	manualFreeList gclinkptr <span class="comment">// list of free objects in mSpanManual spans</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 根据 span class，每一种 span 的容量以及可分配对象数是固定的，因此：</span></span><br><span class="line"><span class="comment">   * freeindex：下一个空闲对象槽位</span></span><br><span class="line"><span class="comment">   * nelems：总对象数，如果 freeindex == nelems 则证明 span 已满</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">	freeindex <span class="type">uintptr</span></span><br><span class="line">	nelems <span class="type">uintptr</span> <span class="comment">// number of object in the span.</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* allocBits 的补码，方便快速通过 ctz (count trailing zero) 方法快速查找空闲位置 */</span></span><br><span class="line">	allocCache <span class="type">uint64</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 内存占用和 gc 的位图标记 */</span></span><br><span class="line">	allocBits  *gcBits</span><br><span class="line">	gcmarkBits *gcBits</span><br><span class="line"></span><br><span class="line">	<span class="comment">// sweep generation:</span></span><br><span class="line">	<span class="comment">// if sweepgen == h-&gt;sweepgen - 2, the span needs sweeping</span></span><br><span class="line">	<span class="comment">// if sweepgen == h-&gt;sweepgen - 1, the span is currently being swept</span></span><br><span class="line">	<span class="comment">// if sweepgen == h-&gt;sweepgen, the span is swept and ready to use</span></span><br><span class="line">	<span class="comment">// if sweepgen == h-&gt;sweepgen + 1, the span was cached before sweep began and is still cached, and needs sweeping</span></span><br><span class="line">	<span class="comment">// if sweepgen == h-&gt;sweepgen + 3, the span was swept and then cached and is still cached</span></span><br><span class="line">	<span class="comment">// h-&gt;sweepgen is incremented by 2 after every GC</span></span><br><span class="line"></span><br><span class="line">	sweepgen    <span class="type">uint32</span></span><br><span class="line">	divMul      <span class="type">uint32</span>        <span class="comment">// for divide by elemsize</span></span><br><span class="line">	allocCount  <span class="type">uint16</span>        <span class="comment">// number of allocated objects</span></span><br><span class="line">	spanclass   spanClass     <span class="comment">// size class and noscan (uint8)</span></span><br><span class="line">	state       mSpanStateBox <span class="comment">// mSpanInUse etc; accessed atomically (get/set methods)</span></span><br><span class="line">	needzero    <span class="type">uint8</span>         <span class="comment">// needs to be zeroed before allocation</span></span><br><span class="line">	elemsize    <span class="type">uintptr</span>       <span class="comment">// computed from sizeclass or from npages</span></span><br><span class="line">	limit       <span class="type">uintptr</span>       <span class="comment">// end of data in span</span></span><br><span class="line">	speciallock mutex         <span class="comment">// guards specials list</span></span><br><span class="line">	specials    *special      <span class="comment">// linked list of special records sorted by offset.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">操作系统内存管理抽象层：</span><br><span class="line"><span class="number">1</span>) None - Unreserved and unmapped, the default state of any region.</span><br><span class="line"><span class="number">2</span>) <span class="keyword">Reserved</span> - Owned <span class="built_in">by</span> the runtime, but accessing it would cause a fault.</span><br><span class="line">              Does not count against the process&#x27; memory footprint.</span><br><span class="line"><span class="number">3</span>) Prepared - <span class="keyword">Reserved</span>, intended not to be backed <span class="built_in">by</span> physical memory (though</span><br><span class="line">              an OS may implement this lazily). Can transition efficiently to</span><br><span class="line">              Ready. Accessing memory <span class="built_in">in</span> such a region is undefined (may</span><br><span class="line">              fault, may give back unexpected zeroes, etc.).</span><br><span class="line"><span class="number">4</span>) Ready - may be accessed safely.</span><br><span class="line"></span><br><span class="line">sysAlloc:   None -&gt; Ready</span><br><span class="line">sysFree:    * -&gt; None</span><br><span class="line">sysReserve: None -&gt; <span class="keyword">Reserved</span></span><br><span class="line">sysMap:     <span class="keyword">Reserved</span> -&gt; Prepared</span><br><span class="line">sysUsed:    Prepared -&gt; Ready</span><br><span class="line">sysUnused:  Ready -&gt; Prepared</span><br><span class="line">sysFault:   Ready/Prepared -&gt; <span class="keyword">Reserved</span> (only runtime debugging)</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**************** [mem_linux.go] ****************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * mmap:</span></span><br><span class="line"><span class="comment"> * PROT_READ - 可读</span></span><br><span class="line"><span class="comment"> * PROT_WRITE - 可写</span></span><br><span class="line"><span class="comment"> * MAP_ANON - 非文件映射，fd 可忽略（或设置为 -1），offset 必须为 0</span></span><br><span class="line"><span class="comment"> * MAP_PRIVATE - 私有空间，不与其他进程共享（常用于内存分配）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sysAlloc</span><span class="params">(n <span class="type">uintptr</span>, sysStat *sysMemStat)</span></span> unsafe.Pointer &#123;</span><br><span class="line">	p, err := mmap(<span class="literal">nil</span>, n, _PROT_READ|_PROT_WRITE, _MAP_ANON|_MAP_PRIVATE, <span class="number">-1</span>, <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> err == _EACCES &#123;</span><br><span class="line">			<span class="built_in">print</span>(<span class="string">&quot;runtime: mmap: access denied\n&quot;</span>)</span><br><span class="line">			exit(<span class="number">2</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> err == _EAGAIN &#123;</span><br><span class="line">			<span class="built_in">print</span>(<span class="string">&quot;runtime: mmap: too much locked memory (check &#x27;ulimit -l&#x27;).\n&quot;</span>)</span><br><span class="line">			exit(<span class="number">2</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	sysStat.add(<span class="type">int64</span>(n))</span><br><span class="line">	<span class="keyword">return</span> p</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 直接调用 munmap */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sysFree</span><span class="params">(v unsafe.Pointer, n <span class="type">uintptr</span>, sysStat *sysMemStat)</span></span> &#123;</span><br><span class="line">	sysStat.add(-<span class="type">int64</span>(n))</span><br><span class="line">	munmap(v, n)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * mmap:</span></span><br><span class="line"><span class="comment"> * PROT_NONE - 不可访问</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sysReserve</span><span class="params">(v unsafe.Pointer, n <span class="type">uintptr</span>)</span></span> unsafe.Pointer &#123;</span><br><span class="line">	p, err := mmap(v, n, _PROT_NONE, _MAP_ANON|_MAP_PRIVATE, <span class="number">-1</span>, <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> p</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * mmap:</span></span><br><span class="line"><span class="comment"> * MAP_FIXED - 传入地址不作为提示（hint），而是必须指定为该地址，如果地址不可用则失败</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sysMap</span><span class="params">(v unsafe.Pointer, n <span class="type">uintptr</span>, sysStat *sysMemStat)</span></span> &#123;</span><br><span class="line">	sysStat.add(<span class="type">int64</span>(n))</span><br><span class="line"></span><br><span class="line">	p, err := mmap(v, n, _PROT_READ|_PROT_WRITE, _MAP_ANON|_MAP_FIXED|_MAP_PRIVATE, <span class="number">-1</span>, <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">if</span> err == _ENOMEM &#123;</span><br><span class="line">		throw(<span class="string">&quot;runtime: out of memory&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> p != v || err != <span class="number">0</span> &#123;</span><br><span class="line">		throw(<span class="string">&quot;runtime: cannot map pages in arena address space&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sysUsed</span><span class="params">(v unsafe.Pointer, n <span class="type">uintptr</span>)</span></span> &#123;</span><br><span class="line">	<span class="comment">// Partially undo the NOHUGEPAGE marks from sysUnused</span></span><br><span class="line">	<span class="comment">// for whole huge pages between v and v+n. This may</span></span><br><span class="line">	<span class="comment">// leave huge pages off at the end points v and v+n</span></span><br><span class="line">	<span class="comment">// even though allocations may cover these entire huge</span></span><br><span class="line">	<span class="comment">// pages. We could detect this and undo NOHUGEPAGE on</span></span><br><span class="line">	<span class="comment">// the end points as well, but it&#x27;s probably not worth</span></span><br><span class="line">	<span class="comment">// the cost because when neighboring allocations are</span></span><br><span class="line">	<span class="comment">// freed sysUnused will just set NOHUGEPAGE again.</span></span><br><span class="line">	sysHugePage(v, n)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * madvise:</span></span><br><span class="line"><span class="comment"> * MADV_HUGEPAGE - 在给定范围内开启透明大页（THP），主要用于使用大块内存的场景</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sysHugePage</span><span class="params">(v unsafe.Pointer, n <span class="type">uintptr</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> physHugePageSize != <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// Round v up to a huge page boundary.</span></span><br><span class="line">		beg := alignUp(<span class="type">uintptr</span>(v), physHugePageSize)</span><br><span class="line">		<span class="comment">// Round v+n down to a huge page boundary.</span></span><br><span class="line">		end := alignDown(<span class="type">uintptr</span>(v)+n, physHugePageSize)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> beg &lt; end &#123;</span><br><span class="line">			madvise(unsafe.Pointer(beg), end-beg, _MADV_HUGEPAGE)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * madvise:</span></span><br><span class="line"><span class="comment"> * MADV_NOHUGEPAGE - 取消透明大页</span></span><br><span class="line"><span class="comment"> * MADV_DONTNEED - 在将来不再访问该空间</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sysUnused</span><span class="params">(v unsafe.Pointer, n <span class="type">uintptr</span>)</span></span> &#123;</span><br><span class="line">	<span class="comment">// By default, Linux&#x27;s &quot;transparent huge page&quot; support will</span></span><br><span class="line">	<span class="comment">// merge pages into a huge page if there&#x27;s even a single</span></span><br><span class="line">	<span class="comment">// present regular page, undoing the effects of madvise(adviseUnused)</span></span><br><span class="line">	<span class="comment">// below. On amd64, that means khugepaged can turn a single</span></span><br><span class="line">	<span class="comment">// 4KB page to 2MB, bloating the process&#x27;s RSS by as much as</span></span><br><span class="line">	<span class="comment">// 512X. (See issue #8832 and Linux kernel bug</span></span><br><span class="line">	<span class="comment">// https://bugzilla.kernel.org/show_bug.cgi?id=93111)</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// To work around this, we explicitly disable transparent huge</span></span><br><span class="line">	<span class="comment">// pages when we release pages of the heap. However, we have</span></span><br><span class="line">	<span class="comment">// to do this carefully because changing this flag tends to</span></span><br><span class="line">	<span class="comment">// split the VMA (memory mapping) containing v in to three</span></span><br><span class="line">	<span class="comment">// VMAs in order to track the different values of the</span></span><br><span class="line">	<span class="comment">// MADV_NOHUGEPAGE flag in the different regions. There&#x27;s a</span></span><br><span class="line">	<span class="comment">// default limit of 65530 VMAs per address space (sysctl</span></span><br><span class="line">	<span class="comment">// vm.max_map_count), so we must be careful not to create too</span></span><br><span class="line">	<span class="comment">// many VMAs (see issue #12233).</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// Since huge pages are huge, there&#x27;s little use in adjusting</span></span><br><span class="line">	<span class="comment">// the MADV_NOHUGEPAGE flag on a fine granularity, so we avoid</span></span><br><span class="line">	<span class="comment">// exploding the number of VMAs by only adjusting the</span></span><br><span class="line">	<span class="comment">// MADV_NOHUGEPAGE flag on a large granularity. This still</span></span><br><span class="line">	<span class="comment">// gets most of the benefit of huge pages while keeping the</span></span><br><span class="line">	<span class="comment">// number of VMAs under control. With hugePageSize = 2MB, even</span></span><br><span class="line">	<span class="comment">// a pessimal heap can reach 128GB before running out of VMAs.</span></span><br><span class="line">	<span class="keyword">if</span> physHugePageSize != <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// If it&#x27;s a large allocation, we want to leave huge</span></span><br><span class="line">		<span class="comment">// pages enabled. Hence, we only adjust the huge page</span></span><br><span class="line">		<span class="comment">// flag on the huge pages containing v and v+n-1, and</span></span><br><span class="line">		<span class="comment">// only if those aren&#x27;t aligned.</span></span><br><span class="line">		<span class="keyword">var</span> head, tail <span class="type">uintptr</span></span><br><span class="line">		<span class="keyword">if</span> <span class="type">uintptr</span>(v)&amp;(physHugePageSize<span class="number">-1</span>) != <span class="number">0</span> &#123;</span><br><span class="line">			<span class="comment">// Compute huge page containing v.</span></span><br><span class="line">			head = alignDown(<span class="type">uintptr</span>(v), physHugePageSize)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (<span class="type">uintptr</span>(v)+n)&amp;(physHugePageSize<span class="number">-1</span>) != <span class="number">0</span> &#123;</span><br><span class="line">			<span class="comment">// Compute huge page containing v+n-1.</span></span><br><span class="line">			tail = alignDown(<span class="type">uintptr</span>(v)+n<span class="number">-1</span>, physHugePageSize)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Note that madvise will return EINVAL if the flag is</span></span><br><span class="line">		<span class="comment">// already set, which is quite likely. We ignore</span></span><br><span class="line">		<span class="comment">// errors.</span></span><br><span class="line">		<span class="keyword">if</span> head != <span class="number">0</span> &amp;&amp; head+physHugePageSize == tail &#123;</span><br><span class="line">			<span class="comment">// head and tail are different but adjacent,</span></span><br><span class="line">			<span class="comment">// so do this in one call.</span></span><br><span class="line">			madvise(unsafe.Pointer(head), <span class="number">2</span>*physHugePageSize, _MADV_NOHUGEPAGE)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// Advise the huge pages containing v and v+n-1.</span></span><br><span class="line">			<span class="keyword">if</span> head != <span class="number">0</span> &#123;</span><br><span class="line">				madvise(unsafe.Pointer(head), physHugePageSize, _MADV_NOHUGEPAGE)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> tail != <span class="number">0</span> &amp;&amp; tail != head &#123;</span><br><span class="line">				madvise(unsafe.Pointer(tail), physHugePageSize, _MADV_NOHUGEPAGE)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> <span class="type">uintptr</span>(v)&amp;(physPageSize<span class="number">-1</span>) != <span class="number">0</span> || n&amp;(physPageSize<span class="number">-1</span>) != <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// madvise will round this to any physical page</span></span><br><span class="line">		<span class="comment">// *covered* by this range, so an unaligned madvise</span></span><br><span class="line">		<span class="comment">// will release more memory than intended.</span></span><br><span class="line">		throw(<span class="string">&quot;unaligned sysUnused&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> advise <span class="type">uint32</span></span><br><span class="line">	<span class="keyword">if</span> debug.madvdontneed != <span class="number">0</span> &#123;</span><br><span class="line">		advise = _MADV_DONTNEED</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		advise = atomic.Load(&amp;adviseUnused)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> errno := madvise(v, n, <span class="type">int32</span>(advise)); advise == _MADV_FREE &amp;&amp; errno != <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// MADV_FREE was added in Linux 4.5. Fall back to MADV_DONTNEED if it is</span></span><br><span class="line">		<span class="comment">// not supported.</span></span><br><span class="line">		atomic.Store(&amp;adviseUnused, _MADV_DONTNEED)</span><br><span class="line">		madvise(v, n, _MADV_DONTNEED)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sysFault</span><span class="params">(v unsafe.Pointer, n <span class="type">uintptr</span>)</span></span> &#123;</span><br><span class="line">	mmap(v, n, _PROT_NONE, _MAP_ANON|_MAP_PRIVATE|_MAP_FIXED, <span class="number">-1</span>, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="内存回收gc">5.2 内存回收（GC）</h4>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**************** [mgc.go] ****************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 垃圾收集器 (GC)。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 定义 GC：</span></span><br><span class="line"><span class="comment">// 1. 与赋值器（mutator）线程并行运行；</span></span><br><span class="line"><span class="comment">// 2. 类型准确；</span></span><br><span class="line"><span class="comment">// 3. 允许多 GC 线程并发运行；</span></span><br><span class="line"><span class="comment">// 4. 在并发标记和清除时使用写屏障；</span></span><br><span class="line"><span class="comment">// 5. 非分代，非整理；</span></span><br><span class="line"><span class="comment">// 6. 内存分配通过每个 P 的分配区按大小进行分段来最小化碎片，同时还能消除加锁。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 整个 GC 算法被拆解为多个阶段和步骤。如下是对如何该算法使用的高层次描述。如果想了解 GC，</span></span><br><span class="line"><span class="comment">// Richard Jones 的 gchandbook.org 是个好地方</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 算法思想继承自包括 Dijkstra 的即时（on-the-fly）算法，见 Edsger W. Dijkstra, Leslie Lamport, </span></span><br><span class="line"><span class="comment">// A. J. Martin, C. S. Scholten, and E. F. M. Steffens. 1978. On-the-fly garbage collection: </span></span><br><span class="line"><span class="comment">// an exercise in cooperation. Commun. ACM 21, 11 (November 1978), 966-975.</span></span><br><span class="line"><span class="comment">// 有关这些步骤的完整性、正确性和终止性的期刊级别的证明，请参阅 Hudson, R., and Moss, J.E.B. Copying </span></span><br><span class="line"><span class="comment">// Garbage Collection without stopping the world. Concurrency and Computation: Practice and </span></span><br><span class="line"><span class="comment">// Experience 15(3-5), 2003.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 1. sweep termination 阶段</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    a. STW，让所有的 P 都到达 GC safe-point。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    b. 扫描所有未扫描过的 span。 只有在当前 GC cycle 在预期时间之前被执行时，才可能存在未扫描的 span。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 2. mark 阶段</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    a. 在准备进入标记阶段之前，将 gcphase 从 _GCoff 设置为 _GCmark，开启写屏障，开启赋值器协助，并将根标</span></span><br><span class="line"><span class="comment">//    记任务（root mark job）入队。直到所有的 P 都通过 STW 开启了写屏障后，才会开始扫描对象。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    b. 取消 STW。从这时开始，GC 的工作就由标记 worker（通过调度器启动）和在分配空间时可能发生的协助共同完成。</span></span><br><span class="line"><span class="comment">//    对于所有被覆写的指针和由写指针导致创建的新指针，写屏障将其标记为灰色（详情见 mbarrier.go）。新分配的对象</span></span><br><span class="line"><span class="comment">//    被立即标记为黑色。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    c. GC 开始执行根标记任务。该任务包含了扫描所有栈，置灰所有全局变量，置灰所有堆外运行时数据结构所持有的的堆</span></span><br><span class="line"><span class="comment">//    内指针。扫描栈会停止 goroutine，并将栈上所有指针置灰，之后再恢复该 goroutine。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    d. GC 从工作队列中取出所有灰色对象，将之置黑后，扫描并置灰其对象持有的指针（这会反过来将灰指针又送回工作队列）。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    e. 因 GC 的工作横跨所有本地缓存，因此 GC 使用一种分布式终止算法来检测不再有根标记任务和灰色对象的时刻。当到</span></span><br><span class="line"><span class="comment">//    达该时刻后，GC 过渡到 mark termination 阶段。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 3. mark termination 阶段</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    a. STW。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    b. 将 gcphase 设置为 _GCmarktermination，禁用 worker 和 GC 协助。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    c. 执行类似清洗 mcaches 等的打扫工作。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 4. sweep 阶段</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    a. 在准备进入清扫阶段之前，将 gcphase 设置为 _GCoff，设置清扫状态并关闭写屏障。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    b. 取消 STW。 从这时起，新分配的对象都是白色，且在使用 span 前按需进行清扫。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    c. GC 在后台进行并发清扫，并响应内存分配。见下述。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 5. 当发生了足量的内存分配后，重复上述步骤。对于 GC rate 的讨论，见下述。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 并发清扫：</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// sweep 阶段与正常执行的程序并发运行。</span></span><br><span class="line"><span class="comment">// 后台 goroutine 被动地（当一个 goroutine 需要另一个 span 时）、并发地（对 CPU 约束型程序友好）将堆按照一个个</span></span><br><span class="line"><span class="comment">// 的 span 逐步清扫。当 mark termination 阶段的 STW 结束后，所有的 span 都被标记为 ”需要清扫“。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 后台清扫 goroutine 简单的将 span 挨个清扫。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 当一个 goroutine 需要一个 span，而当前还存在未清扫的 span 时，为了减少向操作系统申请过多的内存，程序会先进行</span></span><br><span class="line"><span class="comment">// 清扫来尝试回收所需容量的内存。当一个 goroutine 需要分配一个新的小对象 span 时，它先尝试清扫所有放置同等大小对</span></span><br><span class="line"><span class="comment">// 象的 span，直到至少释放了一个这样的 span。而当一个 goroutine 需要从堆中直接分配一个新的大对象 span 时，它会</span></span><br><span class="line"><span class="comment">// 先尝试清扫所有 span 直到释放出了同等空间的内存页为止。只有一种情况不满足：当一个 goroutine 清扫并释放了两个不</span></span><br><span class="line"><span class="comment">// 邻接的单页 span 后，它会直接分配一个新的双页 span，但仍然可能存在未扫描的单页 span 能合并组成双页 span。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 确保不对未扫描的 span 做任何操作十分关键（操作可能会破坏 GC 位图中的标记位）。在 GC 期间，所有的 mcaches 都被</span></span><br><span class="line"><span class="comment">// flush 到 central cache 中，故 mcache 是空的。当一个 goroutine 将一个新的 span 抓取到 mcache 后，它先清</span></span><br><span class="line"><span class="comment">// 扫该 span。当一个 goroutine 显式的释放一个对象或设置一个 finalizer，它会确保该 span 被清扫过（或者主动清扫，</span></span><br><span class="line"><span class="comment">// 或者等待并发清扫完成）。只有当所有的 span 都被清扫后，finalizer goroutine 才会启动。</span></span><br><span class="line"><span class="comment">// 当下一次 GC 启动后，它会清扫所有未完成清扫的 span（如果有的话）。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// GC rate:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 当我们分配了与已使用容量成比例的新容量后，会开启下一次 GC。该比例由 GOGC 环境变量控制（默认 100）。如果当前我们</span></span><br><span class="line"><span class="comment">// 试用了 4M 空间，且 GOGC = 100，那么当使用容量达到 8M 时，会再次 GC（该标记由 gcController.heapGoal 变量追</span></span><br><span class="line"><span class="comment">// 踪）。这使得 GC 成本与分配成本成线性比例。调节 GOGC 只会改变这种线性常数（和额外的内存使用容量）。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Oblets</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 为了避免扫描大对象时的长停顿，以及改善并行度，GC 将扫描超过 maxObletBytes 的大对象的任务拆分为一个个最大为 </span></span><br><span class="line"><span class="comment">// maxObletBytes 容量的 oblets 中，每次只扫描第一个 oblet，之后入队，将剩余的 oblet 交给新的扫描任务去处理。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* gc 初始化 */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcinit</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> unsafe.Sizeof(workbuf&#123;&#125;) != _WorkbufSize &#123;</span><br><span class="line">		throw(<span class="string">&quot;size of Workbuf is suboptimal&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// No sweep on the first cycle.</span></span><br><span class="line">	mheap_.sweepDrained = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* GOGC 是 golang 唯一的 GC 参数（也即 gcPercent），默认值 = 100 </span></span><br><span class="line"><span class="comment">   * 从 gcController.init() 中可以看到：</span></span><br><span class="line"><span class="comment">   * 1. heap 的初始大小是 4&lt;&lt;20 = 4MiB，而在调用 setGCPercent() 时，heapMinimum 会被设置为4MiB * GOGC / 100</span></span><br><span class="line"><span class="comment">   * 2. triggerRatio 默认值为 7/8</span></span><br><span class="line"><span class="comment">   * 3. heapMarked 被设置为 heapMinimum / (1 + triggerRatio)，由于刚刚启动，还没有过 gc，因此目前的 heapMarked 是假定值</span></span><br><span class="line"><span class="comment">   * 3. heapGoal 设置算法为 heapGoal = heapMarked * (1 + GOGC/100)</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   * 上述几个参数的值，是影响 GC 开始与停止时机的关键。</span></span><br><span class="line"><span class="comment">   * 1. heapMarked 是前一次 GC 后被标记的总容量（即 GC 结束后的存活容量）</span></span><br><span class="line"><span class="comment">   * 2. heapGoal 是下一次 GC 结束后期望的目标 heap 容量门限。按照 gcPercent 算法，计算得出。</span></span><br><span class="line"><span class="comment">   * 3. trigger 是下一次 GC 开始的容量门限。由 triggerRatio 计算得出。</span></span><br><span class="line"><span class="comment">   *    a. trigger = heapMarked * (1 + triggerRatio)</span></span><br><span class="line"><span class="comment">   *    b. 由于是并发 GC，因此 GC 期间依然会分配新内存，故 trigger 通常要小于 heapGoal</span></span><br><span class="line"><span class="comment">   *    c. triggerRatio 的范围极限是 0.6 * GOGC/100 ~ 0.95 * GOGC/100</span></span><br><span class="line"><span class="comment">   *    d. 除了初始设置 triggerRatio = 7/8，每次 GC 结束后会重新设置 triggerRatio，具体算法略</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">	gcController.init(readGOGC())</span><br><span class="line"></span><br><span class="line">	work.startSema = <span class="number">1</span></span><br><span class="line">	work.markDoneSema = <span class="number">1</span></span><br><span class="line">	lockInit(&amp;work.sweepWaiters.lock, lockRankSweepWaiters)</span><br><span class="line">	lockInit(&amp;work.assistQueue.lock, lockRankAssistQueue)</span><br><span class="line">	lockInit(&amp;work.wbufSpans.lock, lockRankWbufSpans)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**************** [mallocgc.go] ****************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * GC phase:</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 触发 GC 的入口：</span></span><br><span class="line"><span class="comment"> * 1. 显示调用 runtime.GC()</span></span><br><span class="line"><span class="comment"> * 2. runtime.mallocgc()，当 shouldhelpgc == true 时</span></span><br><span class="line"><span class="comment"> * 3. 在 proc.go 的 init() 中，启动了 forcegchelper()，在其内部等待由 sysmon 唤醒后执行</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mallocgc</span><span class="params">(size <span class="type">uintptr</span>, typ *_type, needzero <span class="type">bool</span>)</span></span> unsafe.Pointer &#123;</span><br><span class="line">  ... ...</span><br><span class="line">  <span class="keyword">if</span> size &lt;= maxSmallSize &#123;</span><br><span class="line">    <span class="comment">/* 对于小对象，当按照 span class 查找 mcache 中的 span 已满时，会分配新的 span，这时设置 shouldhelpgc = true */</span></span><br><span class="line">    <span class="keyword">if</span> noscan &amp;&amp; size &lt; maxTinySize &#123;</span><br><span class="line">      ... ...</span><br><span class="line">      v, span, shouldhelpgc = c.nextFree(tinySpanClass)</span><br><span class="line">      ... ...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      ... ...</span><br><span class="line">      v, span, shouldhelpgc = c.nextFree(spc)</span><br><span class="line">      ... ...</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">/* 大对象直接在 heap 分配 class == 0 的特殊 span，每次都设置 shouldhelpgc = true */</span></span><br><span class="line">    shouldhelpgc = <span class="literal">true</span></span><br><span class="line">    ... ...</span><br><span class="line">  &#125;</span><br><span class="line">  ... ...</span><br><span class="line">  <span class="keyword">if</span> shouldhelpgc &#123;</span><br><span class="line">    <span class="keyword">if</span> t := (gcTrigger&#123;kind: gcTriggerHeap&#125;); t.test() &#123;</span><br><span class="line">      gcStart(t)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ... ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**************** [proc.go] ****************/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">forcegchelper</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">/* 保存 forcegchelper 线程到全局变量 forcegc.g */</span></span><br><span class="line">  forcegc.g = getg()</span><br><span class="line">	... ...</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		... ...</span><br><span class="line">    <span class="comment">/* 调用 gopark 让当前 goroutine 陷入休眠，被唤醒后再执行下一行 gcStart */</span></span><br><span class="line">		goparkunlock(&amp;forcegc.lock, waitReasonForceGCIdle, traceEvGoBlock, <span class="number">1</span>)</span><br><span class="line">		... ...</span><br><span class="line">		gcStart(gcTrigger&#123;kind: gcTriggerTime, now: nanotime()&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sysmon</span><span class="params">()</span></span> &#123;</span><br><span class="line">	... ...</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		... ...</span><br><span class="line">		<span class="comment">/* 若需要 gc， */</span></span><br><span class="line">		<span class="keyword">if</span> t := (gcTrigger&#123;kind: gcTriggerTime, now: now&#125;); t.test() &amp;&amp; atomic.Load(&amp;forcegc.idle) != <span class="number">0</span> &#123;</span><br><span class="line">			... ...</span><br><span class="line">			<span class="keyword">var</span> list gList</span><br><span class="line">			list.push(forcegc.g)</span><br><span class="line">      <span class="comment">/*  */</span></span><br><span class="line">			injectglist(&amp;list)</span><br><span class="line">			... ...</span><br><span class="line">		&#125;</span><br><span class="line">		... ...</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**************** [mgc.go] ****************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 根据 gcTrgger 类型进入不同的判断分支，判断是否要 gc */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t gcTrigger)</span></span> test() <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> !memstats.enablegc || panicking != <span class="number">0</span> || gcphase != _GCoff &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">switch</span> t.kind &#123;</span><br><span class="line">	<span class="keyword">case</span> gcTriggerHeap:</span><br><span class="line">    <span class="comment">/* 当前容量到达 trigger 点时 */</span></span><br><span class="line">		<span class="keyword">return</span> gcController.heapLive &gt;= gcController.trigger</span><br><span class="line">	<span class="keyword">case</span> gcTriggerTime:</span><br><span class="line">		<span class="keyword">if</span> gcController.gcPercent &lt; <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">		lastgc := <span class="type">int64</span>(atomic.Load64(&amp;memstats.last_gc_nanotime))</span><br><span class="line">    <span class="comment">/* 距离上一次 GC 超过 forcegcperiod 时间，forcegcperiod = 2 * 60 * 1e9 即 120 秒 */</span></span><br><span class="line">		<span class="keyword">return</span> lastgc != <span class="number">0</span> &amp;&amp; t.now-lastgc &gt; forcegcperiod</span><br><span class="line">	<span class="keyword">case</span> gcTriggerCycle:</span><br><span class="line">    <span class="comment">// 由 runtime.GC() 强制调用时，传入的 n = work.cycles + 1，故会立即触发</span></span><br><span class="line">		<span class="keyword">return</span> <span class="type">int32</span>(t.n-work.cycles) &gt; <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br><span class="line">754</span><br><span class="line">755</span><br><span class="line">756</span><br><span class="line">757</span><br><span class="line">758</span><br><span class="line">759</span><br><span class="line">760</span><br><span class="line">761</span><br><span class="line">762</span><br><span class="line">763</span><br><span class="line">764</span><br><span class="line">765</span><br><span class="line">766</span><br><span class="line">767</span><br><span class="line">768</span><br><span class="line">769</span><br><span class="line">770</span><br><span class="line">771</span><br><span class="line">772</span><br><span class="line">773</span><br><span class="line">774</span><br><span class="line">775</span><br><span class="line">776</span><br><span class="line">777</span><br><span class="line">778</span><br><span class="line">779</span><br><span class="line">780</span><br><span class="line">781</span><br><span class="line">782</span><br><span class="line">783</span><br><span class="line">784</span><br><span class="line">785</span><br><span class="line">786</span><br><span class="line">787</span><br><span class="line">788</span><br><span class="line">789</span><br><span class="line">790</span><br><span class="line">791</span><br><span class="line">792</span><br><span class="line">793</span><br><span class="line">794</span><br><span class="line">795</span><br><span class="line">796</span><br><span class="line">797</span><br><span class="line">798</span><br><span class="line">799</span><br><span class="line">800</span><br><span class="line">801</span><br><span class="line">802</span><br><span class="line">803</span><br><span class="line">804</span><br><span class="line">805</span><br><span class="line">806</span><br><span class="line">807</span><br><span class="line">808</span><br><span class="line">809</span><br><span class="line">810</span><br><span class="line">811</span><br><span class="line">812</span><br><span class="line">813</span><br><span class="line">814</span><br><span class="line">815</span><br><span class="line">816</span><br><span class="line">817</span><br><span class="line">818</span><br><span class="line">819</span><br><span class="line">820</span><br><span class="line">821</span><br><span class="line">822</span><br><span class="line">823</span><br><span class="line">824</span><br><span class="line">825</span><br><span class="line">826</span><br><span class="line">827</span><br><span class="line">828</span><br><span class="line">829</span><br><span class="line">830</span><br><span class="line">831</span><br><span class="line">832</span><br><span class="line">833</span><br><span class="line">834</span><br><span class="line">835</span><br><span class="line">836</span><br><span class="line">837</span><br><span class="line">838</span><br><span class="line">839</span><br><span class="line">840</span><br><span class="line">841</span><br><span class="line">842</span><br><span class="line">843</span><br><span class="line">844</span><br><span class="line">845</span><br><span class="line">846</span><br><span class="line">847</span><br><span class="line">848</span><br><span class="line">849</span><br><span class="line">850</span><br><span class="line">851</span><br><span class="line">852</span><br><span class="line">853</span><br><span class="line">854</span><br><span class="line">855</span><br><span class="line">856</span><br><span class="line">857</span><br><span class="line">858</span><br><span class="line">859</span><br><span class="line">860</span><br><span class="line">861</span><br><span class="line">862</span><br><span class="line">863</span><br><span class="line">864</span><br><span class="line">865</span><br><span class="line">866</span><br><span class="line">867</span><br><span class="line">868</span><br><span class="line">869</span><br><span class="line">870</span><br><span class="line">871</span><br><span class="line">872</span><br><span class="line">873</span><br><span class="line">874</span><br><span class="line">875</span><br><span class="line">876</span><br><span class="line">877</span><br><span class="line">878</span><br><span class="line">879</span><br><span class="line">880</span><br><span class="line">881</span><br><span class="line">882</span><br><span class="line">883</span><br><span class="line">884</span><br><span class="line">885</span><br><span class="line">886</span><br><span class="line">887</span><br><span class="line">888</span><br><span class="line">889</span><br><span class="line">890</span><br><span class="line">891</span><br><span class="line">892</span><br><span class="line">893</span><br><span class="line">894</span><br><span class="line">895</span><br><span class="line">896</span><br><span class="line">897</span><br><span class="line">898</span><br><span class="line">899</span><br><span class="line">900</span><br><span class="line">901</span><br><span class="line">902</span><br><span class="line">903</span><br><span class="line">904</span><br><span class="line">905</span><br><span class="line">906</span><br><span class="line">907</span><br><span class="line">908</span><br><span class="line">909</span><br><span class="line">910</span><br><span class="line">911</span><br><span class="line">912</span><br><span class="line">913</span><br><span class="line">914</span><br><span class="line">915</span><br><span class="line">916</span><br><span class="line">917</span><br><span class="line">918</span><br><span class="line">919</span><br><span class="line">920</span><br><span class="line">921</span><br><span class="line">922</span><br><span class="line">923</span><br><span class="line">924</span><br><span class="line">925</span><br><span class="line">926</span><br><span class="line">927</span><br><span class="line">928</span><br><span class="line">929</span><br><span class="line">930</span><br><span class="line">931</span><br><span class="line">932</span><br><span class="line">933</span><br><span class="line">934</span><br><span class="line">935</span><br><span class="line">936</span><br><span class="line">937</span><br><span class="line">938</span><br><span class="line">939</span><br><span class="line">940</span><br><span class="line">941</span><br><span class="line">942</span><br><span class="line">943</span><br><span class="line">944</span><br><span class="line">945</span><br><span class="line">946</span><br><span class="line">947</span><br><span class="line">948</span><br><span class="line">949</span><br><span class="line">950</span><br><span class="line">951</span><br><span class="line">952</span><br><span class="line">953</span><br><span class="line">954</span><br><span class="line">955</span><br><span class="line">956</span><br><span class="line">957</span><br><span class="line">958</span><br><span class="line">959</span><br><span class="line">960</span><br><span class="line">961</span><br><span class="line">962</span><br><span class="line">963</span><br><span class="line">964</span><br><span class="line">965</span><br><span class="line">966</span><br><span class="line">967</span><br><span class="line">968</span><br><span class="line">969</span><br><span class="line">970</span><br><span class="line">971</span><br><span class="line">972</span><br><span class="line">973</span><br><span class="line">974</span><br><span class="line">975</span><br><span class="line">976</span><br><span class="line">977</span><br><span class="line">978</span><br><span class="line">979</span><br><span class="line">980</span><br><span class="line">981</span><br><span class="line">982</span><br><span class="line">983</span><br><span class="line">984</span><br><span class="line">985</span><br><span class="line">986</span><br><span class="line">987</span><br><span class="line">988</span><br><span class="line">989</span><br><span class="line">990</span><br><span class="line">991</span><br><span class="line">992</span><br><span class="line">993</span><br><span class="line">994</span><br><span class="line">995</span><br><span class="line">996</span><br><span class="line">997</span><br><span class="line">998</span><br><span class="line">999</span><br><span class="line">1000</span><br><span class="line">1001</span><br><span class="line">1002</span><br><span class="line">1003</span><br><span class="line">1004</span><br><span class="line">1005</span><br><span class="line">1006</span><br><span class="line">1007</span><br><span class="line">1008</span><br><span class="line">1009</span><br><span class="line">1010</span><br><span class="line">1011</span><br><span class="line">1012</span><br><span class="line">1013</span><br><span class="line">1014</span><br><span class="line">1015</span><br><span class="line">1016</span><br><span class="line">1017</span><br><span class="line">1018</span><br><span class="line">1019</span><br><span class="line">1020</span><br><span class="line">1021</span><br><span class="line">1022</span><br><span class="line">1023</span><br><span class="line">1024</span><br><span class="line">1025</span><br><span class="line">1026</span><br><span class="line">1027</span><br><span class="line">1028</span><br><span class="line">1029</span><br><span class="line">1030</span><br><span class="line">1031</span><br><span class="line">1032</span><br><span class="line">1033</span><br><span class="line">1034</span><br><span class="line">1035</span><br><span class="line">1036</span><br><span class="line">1037</span><br><span class="line">1038</span><br><span class="line">1039</span><br><span class="line">1040</span><br><span class="line">1041</span><br><span class="line">1042</span><br><span class="line">1043</span><br><span class="line">1044</span><br><span class="line">1045</span><br><span class="line">1046</span><br><span class="line">1047</span><br><span class="line">1048</span><br><span class="line">1049</span><br><span class="line">1050</span><br><span class="line">1051</span><br><span class="line">1052</span><br><span class="line">1053</span><br><span class="line">1054</span><br><span class="line">1055</span><br><span class="line">1056</span><br><span class="line">1057</span><br><span class="line">1058</span><br><span class="line">1059</span><br><span class="line">1060</span><br><span class="line">1061</span><br><span class="line">1062</span><br><span class="line">1063</span><br><span class="line">1064</span><br><span class="line">1065</span><br><span class="line">1066</span><br><span class="line">1067</span><br><span class="line">1068</span><br><span class="line">1069</span><br><span class="line">1070</span><br><span class="line">1071</span><br><span class="line">1072</span><br><span class="line">1073</span><br><span class="line">1074</span><br><span class="line">1075</span><br><span class="line">1076</span><br><span class="line">1077</span><br><span class="line">1078</span><br><span class="line">1079</span><br><span class="line">1080</span><br><span class="line">1081</span><br><span class="line">1082</span><br><span class="line">1083</span><br><span class="line">1084</span><br><span class="line">1085</span><br><span class="line">1086</span><br><span class="line">1087</span><br><span class="line">1088</span><br><span class="line">1089</span><br><span class="line">1090</span><br><span class="line">1091</span><br><span class="line">1092</span><br><span class="line">1093</span><br><span class="line">1094</span><br><span class="line">1095</span><br><span class="line">1096</span><br><span class="line">1097</span><br><span class="line">1098</span><br><span class="line">1099</span><br><span class="line">1100</span><br><span class="line">1101</span><br><span class="line">1102</span><br><span class="line">1103</span><br><span class="line">1104</span><br><span class="line">1105</span><br><span class="line">1106</span><br><span class="line">1107</span><br><span class="line">1108</span><br><span class="line">1109</span><br><span class="line">1110</span><br><span class="line">1111</span><br><span class="line">1112</span><br><span class="line">1113</span><br><span class="line">1114</span><br><span class="line">1115</span><br><span class="line">1116</span><br><span class="line">1117</span><br><span class="line">1118</span><br><span class="line">1119</span><br><span class="line">1120</span><br><span class="line">1121</span><br><span class="line">1122</span><br><span class="line">1123</span><br><span class="line">1124</span><br><span class="line">1125</span><br><span class="line">1126</span><br><span class="line">1127</span><br><span class="line">1128</span><br><span class="line">1129</span><br><span class="line">1130</span><br><span class="line">1131</span><br><span class="line">1132</span><br><span class="line">1133</span><br><span class="line">1134</span><br><span class="line">1135</span><br><span class="line">1136</span><br><span class="line">1137</span><br><span class="line">1138</span><br><span class="line">1139</span><br><span class="line">1140</span><br><span class="line">1141</span><br><span class="line">1142</span><br><span class="line">1143</span><br><span class="line">1144</span><br><span class="line">1145</span><br><span class="line">1146</span><br><span class="line">1147</span><br><span class="line">1148</span><br><span class="line">1149</span><br><span class="line">1150</span><br><span class="line">1151</span><br><span class="line">1152</span><br><span class="line">1153</span><br><span class="line">1154</span><br><span class="line">1155</span><br><span class="line">1156</span><br><span class="line">1157</span><br><span class="line">1158</span><br><span class="line">1159</span><br><span class="line">1160</span><br><span class="line">1161</span><br><span class="line">1162</span><br><span class="line">1163</span><br><span class="line">1164</span><br><span class="line">1165</span><br><span class="line">1166</span><br><span class="line">1167</span><br><span class="line">1168</span><br><span class="line">1169</span><br><span class="line">1170</span><br><span class="line">1171</span><br><span class="line">1172</span><br><span class="line">1173</span><br><span class="line">1174</span><br><span class="line">1175</span><br><span class="line">1176</span><br><span class="line">1177</span><br><span class="line">1178</span><br><span class="line">1179</span><br><span class="line">1180</span><br><span class="line">1181</span><br><span class="line">1182</span><br><span class="line">1183</span><br><span class="line">1184</span><br><span class="line">1185</span><br><span class="line">1186</span><br><span class="line">1187</span><br><span class="line">1188</span><br><span class="line">1189</span><br><span class="line">1190</span><br><span class="line">1191</span><br><span class="line">1192</span><br><span class="line">1193</span><br><span class="line">1194</span><br><span class="line">1195</span><br><span class="line">1196</span><br><span class="line">1197</span><br><span class="line">1198</span><br><span class="line">1199</span><br><span class="line">1200</span><br><span class="line">1201</span><br><span class="line">1202</span><br><span class="line">1203</span><br><span class="line">1204</span><br><span class="line">1205</span><br><span class="line">1206</span><br><span class="line">1207</span><br><span class="line">1208</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**************** [mgc.go] ****************/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcStart</span><span class="params">(trigger gcTrigger)</span></span> &#123;</span><br><span class="line">	... ...</span><br><span class="line">  <span class="comment">/* 尝试先清扫一个 unswept span，如果是通常的后台启动 gc，一般不会存在 unswept span，</span></span><br><span class="line"><span class="comment">   * 因为在 span 分配、归还的时候都会进行 sweep。而如果是强制调用 GC 就可能存在 unswept span</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">	<span class="keyword">for</span> trigger.test() &amp;&amp; sweepone() != ^<span class="type">uintptr</span>(<span class="number">0</span>) &#123;</span><br><span class="line">		sweep.nbgsweep++</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* startSema 用来保护 _GCoff 到其他状态的逻辑，如果有其他 goroutine 已经获取了锁，则休眠等待 */</span></span><br><span class="line">	semacquire(&amp;work.startSema)</span><br><span class="line">	<span class="comment">/* 也许从休眠醒来后发现已经不再需要做 GC 了 */</span></span><br><span class="line">	<span class="keyword">if</span> !trigger.test() &#123;</span><br><span class="line">		semrelease(&amp;work.startSema)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 当触发类型是 gcTriggerCycle 时，设置用户强制 flag</span></span><br><span class="line">	work.userForced = trigger.kind == gcTriggerCycle</span><br><span class="line"></span><br><span class="line">	... ...</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 拿锁，</span></span><br><span class="line"><span class="comment">	 * 持有 gcsema 允许 m 阻塞其他 GC 过程，同时也能防止并发调用 gomaxprocs </span></span><br><span class="line"><span class="comment">	 * 持有 worldsema 允许 STW</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	semacquire(&amp;gcsema)</span><br><span class="line">	semacquire(&amp;worldsema)</span><br><span class="line"></span><br><span class="line">	... ...</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 启动并发标记 goroutine，通过休眠当前 os 线程并不断地把当前 p 换出，实现每个 p 中都有一个 worker goroutine */</span></span><br><span class="line">	gcBgMarkStartWorkers()</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 设置一些初始值，包括清空所有 g 的 gcscandone、gcAssistBytes，清空所有 arena 的 pageMarks 等 */</span></span><br><span class="line">	systemstack(gcResetMarkState)</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 省略设置各种 work 信息，work 全局变量中记录了与本次 GC 相关的各种信息 */</span></span><br><span class="line">	... ...</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* STW */</span></span><br><span class="line">	systemstack(stopTheWorldWithSema)</span><br><span class="line">	</span><br><span class="line">  <span class="comment">/* 将所有 unswpt span 全部 sweep，由于在 STW 中，因此不会有新的 unswpt，确保上一轮 span 全部 swept 后再开始新一轮  */</span></span><br><span class="line">	systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		finishsweep_m()</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	... ...</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 重置 gcController */</span></span><br><span class="line">	gcController.startCycle()</span><br><span class="line">	work.heapGoal = gcController.heapGoal</span><br><span class="line"></span><br><span class="line">	... ...</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 正式进入标记阶段，开启写屏障 */</span></span><br><span class="line">	setGCPhase(_GCmark)</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 设置 nproc 和 nwait，并将所有根扫描任务入队 */</span></span><br><span class="line">	gcBgMarkPrepare() <span class="comment">// Must happen before assist enable.</span></span><br><span class="line">	gcMarkRootPrepare()</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 标记所有活跃的 tiny alloc block 为黑色（tiny alloc 中都是 noscan 的对象，可以直接 blacken） */</span></span><br><span class="line">	gcMarkTinyAllocs()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// At this point all Ps have enabled the write</span></span><br><span class="line">	<span class="comment">// barrier, thus maintaining the no white to</span></span><br><span class="line">	<span class="comment">// black invariant. Enable mutator assists to</span></span><br><span class="line">	<span class="comment">// put back-pressure on fast allocating</span></span><br><span class="line">	<span class="comment">// mutators.</span></span><br><span class="line">	atomic.Store(&amp;gcBlackenEnabled, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Assists and workers can start the moment we start</span></span><br><span class="line">	<span class="comment">// the world.</span></span><br><span class="line">	gcController.markStartTime = now</span><br><span class="line"></span><br><span class="line">	<span class="comment">// In STW mode, we could block the instant systemstack</span></span><br><span class="line">	<span class="comment">// returns, so make sure we&#x27;re not preemptible.</span></span><br><span class="line">	mp = acquirem()</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 取消 STW，正式开始并发标记（并发标记的工作由 gcMarkWorker 执行） */</span></span><br><span class="line">	systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		now = startTheWorldWithSema(trace.enabled)</span><br><span class="line">		work.pauseNS += now - work.pauseStart</span><br><span class="line">		work.tMark = now</span><br><span class="line">		memstats.gcPauseDist.record(now - work.pauseStart)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 省略释放各种锁 */</span></span><br><span class="line">  ... ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 创建 gcBgMarkWorker */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcBgMarkStartWorkers</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">/* 最多创建 gomaxprocs 个 worker */</span></span><br><span class="line">	<span class="keyword">for</span> gcBgMarkWorkerCount &lt; gomaxprocs &#123;</span><br><span class="line">    <span class="comment">/* worker function，其内部实现与下面的 work.bgMarkReady 有交互 */</span></span><br><span class="line">		<span class="keyword">go</span> gcBgMarkWorker()</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* notetsleepg 配置当前 m 进入 syscall，这会导致 curg 被保存，</span></span><br><span class="line"><span class="comment">     * p 被换出（重新指派一个 m 来运行该 p），随后当前 m 休眠等待 work.bgMarkReady</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">		notetsleepg(&amp;work.bgMarkReady, <span class="number">-1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 从休眠中被唤醒后，m 会将 curg 恢复，并放入 idlep（或 globrunq）中，之后调用 schedule() 重新调度。</span></span><br><span class="line"><span class="comment">     * 由于 schedule() 每次执行时都会先检查当前是否存在 gcBgMarkWorker，因此不论是 curg 被放到 idlep</span></span><br><span class="line"><span class="comment">     * 还是 glbrunq，最终都会被一个未执行 gcBgMarkWorker 的 p 来执行，这就确保了每个 p 都有 gcBgMarkWorker</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">		noteclear(&amp;work.bgMarkReady)</span><br><span class="line"></span><br><span class="line">		gcBgMarkWorkerCount++</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 创建根扫描任务，根包括栈、全局变量、其他杂项等，要完整扫描堆和栈，因此必须 STW */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcMarkRootPrepare</span><span class="params">()</span></span> &#123;</span><br><span class="line">  ... ...</span><br><span class="line">	<span class="comment">/* 计算传入的 bytes 等于多少个 root block，rootBlockBytes = 256KiB */</span></span><br><span class="line">	nBlocks := <span class="function"><span class="keyword">func</span><span class="params">(bytes <span class="type">uintptr</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="type">int</span>(divRoundUp(bytes, rootBlockBytes))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	work.nDataRoots = <span class="number">0</span></span><br><span class="line">	work.nBSSRoots = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 全局变量由编译器放在 moduleData 中，data 部分是以初始的全局变量 */</span></span><br><span class="line">	<span class="keyword">for</span> _, datap := <span class="keyword">range</span> activeModules() &#123;</span><br><span class="line">		nDataRoots := nBlocks(datap.edata - datap.data)</span><br><span class="line">		<span class="keyword">if</span> nDataRoots &gt; work.nDataRoots &#123;</span><br><span class="line">			work.nDataRoots = nDataRoots</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* bss 部分是未初始的全局变量*/</span></span><br><span class="line">	<span class="keyword">for</span> _, datap := <span class="keyword">range</span> activeModules() &#123;</span><br><span class="line">		nBSSRoots := nBlocks(datap.ebss - datap.bss)</span><br><span class="line">		<span class="keyword">if</span> nBSSRoots &gt; work.nBSSRoots &#123;</span><br><span class="line">			work.nBSSRoots = nBSSRoots</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* markArenas 设置为 allArenas 的镜像，并计算整个堆的 root blocks */</span></span><br><span class="line">	mheap_.markArenas = mheap_.allArenas[:<span class="built_in">len</span>(mheap_.allArenas):<span class="built_in">len</span>(mheap_.allArenas)]</span><br><span class="line">	work.nSpanRoots = <span class="built_in">len</span>(mheap_.markArenas) * (pagesPerArena / pagesPerSpanRoot)</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 这里的 nStackRoots 是当前所有 g 数量 */</span></span><br><span class="line">	work.nStackRoots = <span class="type">int</span>(atomic.Loaduintptr(&amp;allglen))</span><br><span class="line"></span><br><span class="line">	work.markrootNext = <span class="number">0</span></span><br><span class="line">  <span class="comment">/* 所有的根扫描任务就是刚才计算的总额 +fixedRootCount */</span></span><br><span class="line">	work.markrootJobs = <span class="type">uint32</span>(fixedRootCount + work.nDataRoots + work.nBSSRoots + work.nSpanRoots + work.nStackRoots)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Calculate base indexes of each root type</span></span><br><span class="line">	work.baseData = <span class="type">uint32</span>(fixedRootCount)</span><br><span class="line">	work.baseBSS = work.baseData + <span class="type">uint32</span>(work.nDataRoots)</span><br><span class="line">	work.baseSpans = work.baseBSS + <span class="type">uint32</span>(work.nBSSRoots)</span><br><span class="line">	work.baseStacks = work.baseSpans + <span class="type">uint32</span>(work.nSpanRoots)</span><br><span class="line">	work.baseEnd = work.baseStacks + <span class="type">uint32</span>(work.nStackRoots)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 对 mcache 中的所有 tiny allocs 进行标记，为什么认为 tiny 中的对象都是活跃的？</span></span><br><span class="line"><span class="comment"> * 我认为是 tiny span 本身很小，活跃的 span 还未满，不如直接标记黑色，等到后面满了变成普通的 central span，再一起 gc </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcMarkTinyAllocs</span><span class="params">()</span></span> &#123;</span><br><span class="line">  ... ...</span><br><span class="line">	<span class="keyword">for</span> _, p := <span class="keyword">range</span> allp &#123;</span><br><span class="line">		c := p.mcache</span><br><span class="line">		<span class="keyword">if</span> c == <span class="literal">nil</span> || c.tiny == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">    <span class="comment">/* tiny 指向当前的 tiny alloc span，因此 objIndex == 0 */</span></span><br><span class="line">		_, span, objIndex := findObject(c.tiny, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">		gcw := &amp;p.gcw</span><br><span class="line">    <span class="comment">/* tiny alloc 中只存放 noscan 对象，直接 blacken */</span></span><br><span class="line">		greyobject(c.tiny, <span class="number">0</span>, <span class="number">0</span>, span, gcw, objIndex)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* gc 后台标记主逻辑 */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcBgMarkWorker</span><span class="params">()</span></span> &#123;</span><br><span class="line">	gp := getg()</span><br><span class="line">	... ...</span><br><span class="line">	node.gp.set(gp)</span><br><span class="line"></span><br><span class="line">	node.m.set(acquirem())</span><br><span class="line">  <span class="comment">/* 这里唤醒了 work.bgMarkReady，也就唤醒了前面的 worker 创建 forloop */</span></span><br><span class="line">	notewakeup(&amp;work.bgMarkReady)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="comment">/* 执行完 func 后将 g park，并等待 node 唤醒 */</span></span><br><span class="line">		gopark(<span class="function"><span class="keyword">func</span><span class="params">(g *g, nodep unsafe.Pointer)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">			node := (*gcBgMarkWorkerNode)(nodep)</span><br><span class="line">      ... ...</span><br><span class="line">			<span class="comment">/* 将 worker 放入 pool */</span></span><br><span class="line">			gcBgMarkWorkerPool.push(&amp;node.node)</span><br><span class="line">      </span><br><span class="line">      <span class="comment">/* 返回 true 后执行 schedule()，curg 被出让 */</span></span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">		&#125;, unsafe.Pointer(node), waitReasonGCWorkerIdle, traceEvGoBlock, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 能执行到这里说明此时 gcBlackenEnabled 已经等于 1（否则 schedule() 不会调用 findRunnableGCWorker），</span></span><br><span class="line"><span class="comment">		 * 因此根扫描任务已经入队，且活跃的 tiny alloc block 已经被标记为灰色</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">		node.m.set(acquirem())</span><br><span class="line">		pp := gp.m.p.ptr() <span class="comment">// P can&#x27;t change with preemption disabled.</span></span><br><span class="line">    ... ...</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* gcDrain() 是扫描核心逻辑，几种 worker 模式：</span></span><br><span class="line"><span class="comment">     * 1. gcMarkWorkerDedicatedMode: 当前运行该 worker 的 p，专用于运行 gc mark worker，且不可被抢占，</span></span><br><span class="line"><span class="comment">     *    当前 p 的其他 g 会被挪到 globrunq</span></span><br><span class="line"><span class="comment">     * 2. gcMarkWorkerFractionalMode: 可被其他的普通 g 抢占，抢占后强制结束工作</span></span><br><span class="line"><span class="comment">     * 3. gcMarkWorkerIdleMode: 在 p 空闲的时候工作，可被抢占，通常在 findrunnable() 找不到活干的时候触发</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">		systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="comment">// Mark our goroutine preemptible so its stack</span></span><br><span class="line">			<span class="comment">// can be scanned. This lets two mark workers</span></span><br><span class="line">			<span class="comment">// scan each other (otherwise, they would</span></span><br><span class="line">			<span class="comment">// deadlock). We must not modify anything on</span></span><br><span class="line">			<span class="comment">// the G stack. However, stack shrinking is</span></span><br><span class="line">			<span class="comment">// disabled for mark workers, so it is safe to</span></span><br><span class="line">			<span class="comment">// read from the G stack.</span></span><br><span class="line">			casgstatus(gp, _Grunning, _Gwaiting)</span><br><span class="line">			<span class="keyword">switch</span> pp.gcMarkWorkerMode &#123;</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				throw(<span class="string">&quot;gcBgMarkWorker: unexpected gcMarkWorkerMode&quot;</span>)</span><br><span class="line">			<span class="keyword">case</span> gcMarkWorkerDedicatedMode:</span><br><span class="line">				gcDrain(&amp;pp.gcw, gcDrainUntilPreempt|gcDrainFlushBgCredit)</span><br><span class="line">				<span class="keyword">if</span> gp.preempt &#123;</span><br><span class="line">					<span class="comment">// We were preempted. This is</span></span><br><span class="line">					<span class="comment">// a useful signal to kick</span></span><br><span class="line">					<span class="comment">// everything out of the run</span></span><br><span class="line">					<span class="comment">// queue so it can run</span></span><br><span class="line">					<span class="comment">// somewhere else.</span></span><br><span class="line">					<span class="keyword">if</span> drainQ, n := runqdrain(pp); n &gt; <span class="number">0</span> &#123;</span><br><span class="line">						lock(&amp;sched.lock)</span><br><span class="line">						globrunqputbatch(&amp;drainQ, <span class="type">int32</span>(n))</span><br><span class="line">						unlock(&amp;sched.lock)</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// Go back to draining, this time</span></span><br><span class="line">				<span class="comment">// without preemption.</span></span><br><span class="line">				gcDrain(&amp;pp.gcw, gcDrainFlushBgCredit)</span><br><span class="line">			<span class="keyword">case</span> gcMarkWorkerFractionalMode:</span><br><span class="line">				gcDrain(&amp;pp.gcw, gcDrainFractional|gcDrainUntilPreempt|gcDrainFlushBgCredit)</span><br><span class="line">			<span class="keyword">case</span> gcMarkWorkerIdleMode:</span><br><span class="line">				gcDrain(&amp;pp.gcw, gcDrainIdle|gcDrainUntilPreempt|gcDrainFlushBgCredit)</span><br><span class="line">			&#125;</span><br><span class="line">			casgstatus(gp, _Gwaiting, _Grunning)</span><br><span class="line">		&#125;)</span><br><span class="line"></span><br><span class="line">		... ...</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 没有新的工作要做了，标记阶段结束 */</span></span><br><span class="line">		<span class="keyword">if</span> incnwait == work.nproc &amp;&amp; !gcMarkWorkAvailable(<span class="literal">nil</span>) &#123;</span><br><span class="line">      ... ...</span><br><span class="line">			gcMarkDone()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 执行根扫描任务 */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcDrain</span><span class="params">(gcw *gcWork, flags gcDrainFlags)</span></span> &#123;</span><br><span class="line">	... ...</span><br><span class="line">	gp := getg().m.curg</span><br><span class="line">	preemptible := flags&amp;gcDrainUntilPreempt != <span class="number">0</span></span><br><span class="line">	flushBgCredit := flags&amp;gcDrainFlushBgCredit != <span class="number">0</span></span><br><span class="line">	idle := flags&amp;gcDrainIdle != <span class="number">0</span></span><br><span class="line"></span><br><span class="line">	initScanWork := gcw.scanWork</span><br><span class="line"></span><br><span class="line">	<span class="comment">// checkWork is the scan work before performing the next</span></span><br><span class="line">	<span class="comment">// self-preempt check.</span></span><br><span class="line">	checkWork := <span class="type">int64</span>(<span class="number">1</span>&lt;&lt;<span class="number">63</span> - <span class="number">1</span>)</span><br><span class="line">  <span class="comment">/* check() 用于返回当前 fraction 或 idle 任务是否需要立即结束 */</span></span><br><span class="line">	<span class="keyword">var</span> check <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">bool</span></span><br><span class="line">	<span class="keyword">if</span> flags&amp;(gcDrainIdle|gcDrainFractional) != <span class="number">0</span> &#123;</span><br><span class="line">		checkWork = initScanWork + drainCheckThreshold</span><br><span class="line">		<span class="keyword">if</span> idle &#123;</span><br><span class="line">      <span class="comment">/* 对于 idle worker，当存在新的 g 可执行后，check 返回 true*/</span></span><br><span class="line">			check = pollWork</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> flags&amp;gcDrainFractional != <span class="number">0</span> &#123;</span><br><span class="line">      <span class="comment">/* 对于 fraction worker，当 worker 在当前 p 执行时长与总 gc 标记时长占比超过 </span></span><br><span class="line"><span class="comment">       * 1.2*gcController.fractionalUtilizationGoal 时，check 返回 true</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">			check = pollFractionalWorkerExit</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Drain root marking jobs.</span></span><br><span class="line">	<span class="keyword">if</span> work.markrootNext &lt; work.markrootJobs &#123;</span><br><span class="line">		<span class="comment">// Stop if we&#x27;re preemptible or if someone wants to STW.</span></span><br><span class="line">		<span class="keyword">for</span> !(gp.preempt &amp;&amp; (preemptible || atomic.Load(&amp;sched.gcwaiting) != <span class="number">0</span>)) &#123;</span><br><span class="line">			job := atomic.Xadd(&amp;work.markrootNext, +<span class="number">1</span>) - <span class="number">1</span></span><br><span class="line">			<span class="keyword">if</span> job &gt;= work.markrootJobs &#123;</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">      <span class="comment">/* 标记根任务 */</span></span><br><span class="line">			markroot(gcw, job)</span><br><span class="line">			<span class="keyword">if</span> check != <span class="literal">nil</span> &amp;&amp; check() &#123;</span><br><span class="line">				<span class="keyword">goto</span> done</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Drain heap marking jobs.</span></span><br><span class="line">	<span class="comment">// Stop if we&#x27;re preemptible or if someone wants to STW.</span></span><br><span class="line">	<span class="keyword">for</span> !(gp.preempt &amp;&amp; (preemptible || atomic.Load(&amp;sched.gcwaiting) != <span class="number">0</span>)) &#123;</span><br><span class="line">    <span class="comment">/* 如果没有全局 work 了，尝试从当前 p 的 workbuf 中窃取一部分给到全局（而不是让空闲的 worker 等待） */</span></span><br><span class="line">		<span class="keyword">if</span> work.full == <span class="number">0</span> &#123;</span><br><span class="line">			gcw.balance()</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取一个需要扫描的对象（前面从 root 开始的对象已经全部扫描完毕，这时获取的对象主要从 </span></span><br><span class="line"><span class="comment">     * 1. root 对象被置灰后，进入 gcw（noscan 会直接置黑，就不再需要进入 gcw 了）</span></span><br><span class="line"><span class="comment">     * 2. write barrier</span></span><br><span class="line"><span class="comment">     * 而来）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">		b := gcw.tryGetFast()</span><br><span class="line">		<span class="keyword">if</span> b == <span class="number">0</span> &#123;</span><br><span class="line">			b = gcw.tryGet()</span><br><span class="line">			<span class="keyword">if</span> b == <span class="number">0</span> &#123;</span><br><span class="line">				<span class="comment">// Flush the write barrier</span></span><br><span class="line">				<span class="comment">// buffer; this may create</span></span><br><span class="line">				<span class="comment">// more work.</span></span><br><span class="line">				wbBufFlush(<span class="literal">nil</span>, <span class="number">0</span>)</span><br><span class="line">				b = gcw.tryGet()</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> b == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="comment">// Unable to get work.</span></span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 扫描该对象 */</span></span><br><span class="line">		scanobject(b, gcw)</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 将本次扫描成果累积到 gcController.bgScanCredit，bgScanCredit 作为一种积分，</span></span><br><span class="line"><span class="comment">     * 可以在 mallocgc() 需要 gcAssistAlloc() 的时候扣减，如果扣减足够，就不再 assist 了</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">		<span class="keyword">if</span> gcw.scanWork &gt;= gcCreditSlack &#123;</span><br><span class="line">			atomic.Xaddint64(&amp;gcController.scanWork, gcw.scanWork)</span><br><span class="line">			<span class="keyword">if</span> flushBgCredit &#123;</span><br><span class="line">				gcFlushBgCredit(gcw.scanWork - initScanWork)</span><br><span class="line">				initScanWork = <span class="number">0</span></span><br><span class="line">			&#125;</span><br><span class="line">			checkWork -= gcw.scanWork</span><br><span class="line">			gcw.scanWork = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 再次检查是否需要终止 */</span></span><br><span class="line">			<span class="keyword">if</span> checkWork &lt;= <span class="number">0</span> &#123;</span><br><span class="line">				checkWork += drainCheckThreshold</span><br><span class="line">				<span class="keyword">if</span> check != <span class="literal">nil</span> &amp;&amp; check() &#123;</span><br><span class="line">					<span class="keyword">break</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">done:</span><br><span class="line">	<span class="comment">// Flush remaining scan work credit.</span></span><br><span class="line">	<span class="keyword">if</span> gcw.scanWork &gt; <span class="number">0</span> &#123;</span><br><span class="line">		atomic.Xaddint64(&amp;gcController.scanWork, gcw.scanWork)</span><br><span class="line">		<span class="keyword">if</span> flushBgCredit &#123;</span><br><span class="line">			gcFlushBgCredit(gcw.scanWork - initScanWork)</span><br><span class="line">		&#125;</span><br><span class="line">		gcw.scanWork = <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 扫描根 */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">markroot</span><span class="params">(gcw *gcWork, i <span class="type">uint32</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">switch</span> &#123;</span><br><span class="line">  <span class="comment">/* 标记 data 区 */</span>  </span><br><span class="line">	<span class="keyword">case</span> work.baseData &lt;= i &amp;&amp; i &lt; work.baseBSS:</span><br><span class="line">		<span class="keyword">for</span> _, datap := <span class="keyword">range</span> activeModules() &#123;</span><br><span class="line">			markrootBlock(datap.data, datap.edata-datap.data, datap.gcdatamask.bytedata, gcw, <span class="type">int</span>(i-work.baseData))</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 标记 bss 区 */</span>  </span><br><span class="line">	<span class="keyword">case</span> work.baseBSS &lt;= i &amp;&amp; i &lt; work.baseSpans:</span><br><span class="line">		<span class="keyword">for</span> _, datap := <span class="keyword">range</span> activeModules() &#123;</span><br><span class="line">			markrootBlock(datap.bss, datap.ebss-datap.bss, datap.gcbssmask.bytedata, gcw, <span class="type">int</span>(i-work.baseBSS))</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 标记所有 finalizer */</span>  </span><br><span class="line">	<span class="keyword">case</span> i == fixedRootFinalizers:</span><br><span class="line">		<span class="keyword">for</span> fb := allfin; fb != <span class="literal">nil</span>; fb = fb.alllink &#123;</span><br><span class="line">			cnt := <span class="type">uintptr</span>(atomic.Load(&amp;fb.cnt))</span><br><span class="line">			scanblock(<span class="type">uintptr</span>(unsafe.Pointer(&amp;fb.fin[<span class="number">0</span>])), cnt*unsafe.Sizeof(fb.fin[<span class="number">0</span>]), &amp;finptrmask[<span class="number">0</span>], gcw, <span class="literal">nil</span>)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 直接释放所有 dead g，将 sched.gFree.stack 中的 g 取出，释放其 stack，然后将之转移到 sched.gFree.noStack */</span></span><br><span class="line">	<span class="keyword">case</span> i == fixedRootFreeGStacks:</span><br><span class="line">		<span class="comment">// Switch to the system stack so we can call</span></span><br><span class="line">		<span class="comment">// stackfree.</span></span><br><span class="line">		systemstack(markrootFreeGStacks)</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 标记所有 span 中的 special（finalizer） */</span>  </span><br><span class="line">	<span class="keyword">case</span> work.baseSpans &lt;= i &amp;&amp; i &lt; work.baseStacks:</span><br><span class="line">		<span class="comment">// mark mspan.specials</span></span><br><span class="line">		markrootSpans(gcw, <span class="type">int</span>(i-work.baseSpans))</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 最后扫描所有 g 的栈 */</span>  </span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="comment">// the rest is scanning goroutine stacks</span></span><br><span class="line">		<span class="keyword">var</span> gp *g</span><br><span class="line">		<span class="keyword">if</span> work.baseStacks &lt;= i &amp;&amp; i &lt; work.baseEnd &#123;</span><br><span class="line">			<span class="comment">/* 从 allgs 中获取一个 g */</span></span><br><span class="line">			gp = allgs[i-work.baseStacks]</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			throw(<span class="string">&quot;markroot: bad index&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// remember when we&#x27;ve first observed the G blocked</span></span><br><span class="line">		<span class="comment">// needed only to output in traceback</span></span><br><span class="line">		status := readgstatus(gp) <span class="comment">// We are not in a scan state</span></span><br><span class="line">		<span class="keyword">if</span> (status == _Gwaiting || status == _Gsyscall) &amp;&amp; gp.waitsince == <span class="number">0</span> &#123;</span><br><span class="line">			gp.waitsince = work.tstart</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// scanstack must be done on the system stack in case</span></span><br><span class="line">		<span class="comment">// we&#x27;re trying to scan our own stack.</span></span><br><span class="line">		systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="comment">// If this is a self-scan, put the user G in</span></span><br><span class="line">			<span class="comment">// _Gwaiting to prevent self-deadlock. It may</span></span><br><span class="line">			<span class="comment">// already be in _Gwaiting if this is a mark</span></span><br><span class="line">			<span class="comment">// worker or we&#x27;re in mark termination.</span></span><br><span class="line">			userG := getg().m.curg</span><br><span class="line">			selfScan := gp == userG &amp;&amp; readgstatus(userG) == _Grunning</span><br><span class="line">			<span class="keyword">if</span> selfScan &#123;</span><br><span class="line">				casgstatus(userG, _Grunning, _Gwaiting)</span><br><span class="line">				userG.waitreason = waitReasonGarbageCollectionScan</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* 将 gp 挂起，该函数主要用于抢占 */</span></span><br><span class="line">			stopped := suspendG(gp)</span><br><span class="line">      <span class="comment">/* dead g 在前面已经处理过了 */</span></span><br><span class="line">			<span class="keyword">if</span> stopped.dead &#123;</span><br><span class="line">				gp.gcscandone = <span class="literal">true</span></span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> gp.gcscandone &#123;</span><br><span class="line">				throw(<span class="string">&quot;g already scanned&quot;</span>)</span><br><span class="line">			&#125;</span><br><span class="line">      <span class="comment">/* scanstack 将 g 中所有可能的地址全部进行扫描，并加入 gcw */</span></span><br><span class="line">			scanstack(gp, gcw)</span><br><span class="line">      </span><br><span class="line">			gp.gcscandone = <span class="literal">true</span></span><br><span class="line">      <span class="comment">/* 恢复 gp */</span></span><br><span class="line">			resumeG(stopped)</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> selfScan &#123;</span><br><span class="line">				casgstatus(userG, _Gwaiting, _Grunning)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 扫描 stack */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">scanstack</span><span class="params">(gp *g, gcw *gcWork)</span></span> &#123;</span><br><span class="line">	... ...</span><br><span class="line">	<span class="keyword">if</span> isShrinkStackSafe(gp) &#123;</span><br><span class="line">		<span class="comment">// Shrink the stack if not much of it is being used.</span></span><br><span class="line">		shrinkstack(gp)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// Otherwise, shrink the stack at the next sync safe point.</span></span><br><span class="line">		gp.preemptShrink = <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> state stackScanState</span><br><span class="line">	state.stack = gp.stack</span><br><span class="line">  ... ...</span><br><span class="line">	<span class="comment">/* 扫描 gp.sched.ctxt 中保存的寄存器上下文 */</span></span><br><span class="line">	<span class="keyword">if</span> gp.sched.ctxt != <span class="literal">nil</span> &#123;</span><br><span class="line">		scanblock(<span class="type">uintptr</span>(unsafe.Pointer(&amp;gp.sched.ctxt)), sys.PtrSize, &amp;oneptrmask[<span class="number">0</span>], gcw, &amp;state)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 采用 gentraceback 和 tracebackdefers 生成 stkframe 后调用 */</span></span><br><span class="line">	scanframe := <span class="function"><span class="keyword">func</span><span class="params">(frame *stkframe, unused unsafe.Pointer)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="comment">/* 将栈帧中的局部变量、传参等进行扫描 */</span></span><br><span class="line">		scanframeworker(frame, &amp;state, gcw)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">	gentraceback(^<span class="type">uintptr</span>(<span class="number">0</span>), ^<span class="type">uintptr</span>(<span class="number">0</span>), <span class="number">0</span>, gp, <span class="number">0</span>, <span class="literal">nil</span>, <span class="number">0x7fffffff</span>, scanframe, <span class="literal">nil</span>, <span class="number">0</span>)</span><br><span class="line">	tracebackdefers(gp, scanframe, <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 扫描 defer 调用链 */</span></span><br><span class="line">	<span class="keyword">for</span> d := gp._defer; d != <span class="literal">nil</span>; d = d.link &#123;</span><br><span class="line">		<span class="keyword">if</span> d.fn != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="comment">// tracebackdefers above does not scan the func value, which could</span></span><br><span class="line">			<span class="comment">// be a stack allocated closure. See issue 30453.</span></span><br><span class="line">			scanblock(<span class="type">uintptr</span>(unsafe.Pointer(&amp;d.fn)), sys.PtrSize, &amp;oneptrmask[<span class="number">0</span>], gcw, &amp;state)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> d.link != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="comment">// The link field of a stack-allocated defer record might point</span></span><br><span class="line">			<span class="comment">// to a heap-allocated defer record. Keep that heap record live.</span></span><br><span class="line">			scanblock(<span class="type">uintptr</span>(unsafe.Pointer(&amp;d.link)), sys.PtrSize, &amp;oneptrmask[<span class="number">0</span>], gcw, &amp;state)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// Retain defers records themselves.</span></span><br><span class="line">		<span class="comment">// Defer records might not be reachable from the G through regular heap</span></span><br><span class="line">		<span class="comment">// tracing because the defer linked list might weave between the stack and the heap.</span></span><br><span class="line">		<span class="keyword">if</span> d.heap &#123;</span><br><span class="line">			scanblock(<span class="type">uintptr</span>(unsafe.Pointer(&amp;d)), sys.PtrSize, &amp;oneptrmask[<span class="number">0</span>], gcw, &amp;state)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">  <span class="comment">/* panic 也加入扫描队列 */</span></span><br><span class="line">	<span class="keyword">if</span> gp._panic != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// Panics are always stack allocated.</span></span><br><span class="line">		state.putPtr(<span class="type">uintptr</span>(unsafe.Pointer(gp._panic)), <span class="literal">false</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 扫描所有栈对象 */</span></span><br><span class="line">	state.buildIndex()</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		p, conservative := state.getPtr()</span><br><span class="line">		... ...</span><br><span class="line">		obj := state.findObject(p)</span><br><span class="line">		... ...</span><br><span class="line">		b := state.stack.lo + <span class="type">uintptr</span>(obj.off)</span><br><span class="line">		<span class="keyword">if</span> conservative &#123;</span><br><span class="line">			scanConservative(b, r.ptrdata(), gcdata, gcw, &amp;state)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			scanblock(b, r.ptrdata(), gcdata, gcw, &amp;state)</span><br><span class="line">		&#125;</span><br><span class="line">    ... ...</span><br><span class="line">	&#125;</span><br><span class="line">  ... ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 按对象扫描 */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">scanobject</span><span class="params">(b <span class="type">uintptr</span>, gcw *gcWork)</span></span> &#123;</span><br><span class="line">	<span class="comment">// Find the bits for b and the size of the object at b.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// b is either the beginning of an object, in which case this</span></span><br><span class="line">	<span class="comment">// is the size of the object to scan, or it points to an</span></span><br><span class="line">	<span class="comment">// oblet, in which case we compute the size to scan below.</span></span><br><span class="line">	hbits := heapBitsForAddr(b)</span><br><span class="line">	s := spanOfUnchecked(b)</span><br><span class="line">	n := s.elemsize</span><br><span class="line">	<span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">		throw(<span class="string">&quot;scanobject n == 0&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 大对象拆分成 oblets 分别扫描以提升并行度 */</span></span><br><span class="line">	<span class="keyword">if</span> n &gt; maxObletBytes &#123;</span><br><span class="line">		<span class="keyword">if</span> b == s.base() &#123;</span><br><span class="line">			<span class="comment">// It&#x27;s possible this is a noscan object (not</span></span><br><span class="line">			<span class="comment">// from greyobject, but from other code</span></span><br><span class="line">			<span class="comment">// paths), in which case we must *not* enqueue</span></span><br><span class="line">			<span class="comment">// oblets since their bitmaps will be</span></span><br><span class="line">			<span class="comment">// uninitialized.</span></span><br><span class="line">			<span class="keyword">if</span> s.spanclass.noscan() &#123;</span><br><span class="line">				<span class="comment">// Bypass the whole scan.</span></span><br><span class="line">				gcw.bytesMarked += <span class="type">uint64</span>(n)</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Enqueue the other oblets to scan later.</span></span><br><span class="line">			<span class="comment">// Some oblets may be in b&#x27;s scalar tail, but</span></span><br><span class="line">			<span class="comment">// these will be marked as &quot;no more pointers&quot;,</span></span><br><span class="line">			<span class="comment">// so we&#x27;ll drop out immediately when we go to</span></span><br><span class="line">			<span class="comment">// scan those.</span></span><br><span class="line">			<span class="keyword">for</span> oblet := b + maxObletBytes; oblet &lt; s.base()+s.elemsize; oblet += maxObletBytes &#123;</span><br><span class="line">				<span class="keyword">if</span> !gcw.putFast(oblet) &#123;</span><br><span class="line">					gcw.put(oblet)</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Compute the size of the oblet. Since this object</span></span><br><span class="line">		<span class="comment">// must be a large object, s.base() is the beginning</span></span><br><span class="line">		<span class="comment">// of the object.</span></span><br><span class="line">		n = s.base() + s.elemsize - b</span><br><span class="line">		<span class="keyword">if</span> n &gt; maxObletBytes &#123;</span><br><span class="line">			n = maxObletBytes</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 从 b 开始，尝试寻找所有其所在 span 中可能的对象，并置灰 */</span></span><br><span class="line">	<span class="keyword">var</span> i <span class="type">uintptr</span></span><br><span class="line">	<span class="keyword">for</span> i = <span class="number">0</span>; i &lt; n; i, hbits = i+sys.PtrSize, hbits.next() &#123;</span><br><span class="line">		<span class="comment">// Load bits once. See CL 22712 and issue 16973 for discussion.</span></span><br><span class="line">		bits := hbits.bits()</span><br><span class="line">		<span class="keyword">if</span> bits&amp;bitScan == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">break</span> <span class="comment">// no more pointers in this object</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> bits&amp;bitPointer == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">continue</span> <span class="comment">// not a pointer</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Work here is duplicated in scanblock and above.</span></span><br><span class="line">		<span class="comment">// If you make changes here, make changes there too.</span></span><br><span class="line">		obj := *(*<span class="type">uintptr</span>)(unsafe.Pointer(b + i))</span><br><span class="line"></span><br><span class="line">		<span class="comment">// At this point we have extracted the next potential pointer.</span></span><br><span class="line">		<span class="comment">// Quickly filter out nil and pointers back to the current object.</span></span><br><span class="line">		<span class="keyword">if</span> obj != <span class="number">0</span> &amp;&amp; obj-b &gt;= n &#123;</span><br><span class="line">			<span class="comment">// Test if obj points into the Go heap and, if so,</span></span><br><span class="line">			<span class="comment">// mark the object.</span></span><br><span class="line">			<span class="comment">//</span></span><br><span class="line">			<span class="comment">// Note that it&#x27;s possible for findObject to</span></span><br><span class="line">			<span class="comment">// fail if obj points to a just-allocated heap</span></span><br><span class="line">			<span class="comment">// object because of a race with growing the</span></span><br><span class="line">			<span class="comment">// heap. In this case, we know the object was</span></span><br><span class="line">			<span class="comment">// just allocated and hence will be marked by</span></span><br><span class="line">			<span class="comment">// allocation itself.</span></span><br><span class="line">			<span class="keyword">if</span> obj, span, objIndex := findObject(obj, b, i); obj != <span class="number">0</span> &#123;</span><br><span class="line">				greyobject(obj, b, i, span, gcw, objIndex)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	gcw.bytesMarked += <span class="type">uint64</span>(n)</span><br><span class="line">	gcw.scanWork += <span class="type">int64</span>(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* GC phase 从 _GCmark -&gt; _GCmarktermination */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcMarkDone</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// Ensure only one thread is running the ragged barrier at a</span></span><br><span class="line">	<span class="comment">// time.</span></span><br><span class="line">	semacquire(&amp;work.markDoneSema)</span><br><span class="line"></span><br><span class="line">top:</span><br><span class="line">	... ...</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Flush all local buffers and collect flushedWork flags.</span></span><br><span class="line">	gcMarkDoneFlushed = <span class="number">0</span></span><br><span class="line">	systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		... ...</span><br><span class="line">    <span class="comment">/* forEachP 抢占所有 g，以尝试到达 safe point，然后执行传入函数 */</span></span><br><span class="line">		forEachP(<span class="function"><span class="keyword">func</span><span class="params">(_p_ *p)</span></span> &#123;</span><br><span class="line">			<span class="comment">/* 将 p 的 write barrier buffer 全部写入 gcw */</span></span><br><span class="line">			wbBufFlush1(_p_)</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* 将 p.gcw 中的对象全部写入 work.full */</span></span><br><span class="line">			_p_.gcw.dispose()</span><br><span class="line">			<span class="comment">/* 置位代表仍存在工作需要 worker 去做 */</span></span><br><span class="line">			<span class="keyword">if</span> _p_.gcw.flushedWork &#123;</span><br><span class="line">				atomic.Xadd(&amp;gcMarkDoneFlushed, <span class="number">1</span>)</span><br><span class="line">				_p_.gcw.flushedWork = <span class="literal">false</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;)</span><br><span class="line">		... ...</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> gcMarkDoneFlushed != <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">/* 如果没结束，重新继续 */</span></span><br><span class="line">		semrelease(&amp;worldsema)</span><br><span class="line">		<span class="keyword">goto</span> top</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 到达这里代表 mark 阶段的工作基本结束了，可以开始转换状态 */</span></span><br><span class="line">	... ...</span><br><span class="line">	systemstack(stopTheWorldWithSema)</span><br><span class="line">	<span class="comment">/* 由于写屏障还没关，有可能因为 gc 的过程，又产生了一些标记工作，wbBufFlush1 后重新回到 top 再来一遍 */</span></span><br><span class="line">	restart := <span class="literal">false</span></span><br><span class="line">	systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> _, p := <span class="keyword">range</span> allp &#123;</span><br><span class="line">			wbBufFlush1(p)</span><br><span class="line">			<span class="keyword">if</span> !p.gcw.empty() &#123;</span><br><span class="line">				restart = <span class="literal">true</span></span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">if</span> restart &#123;</span><br><span class="line">		getg().m.preemptoff = <span class="string">&quot;&quot;</span></span><br><span class="line">		systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			now := startTheWorldWithSema(<span class="literal">true</span>)</span><br><span class="line">			work.pauseNS += now - work.pauseStart</span><br><span class="line">			memstats.gcPauseDist.record(now - work.pauseStart)</span><br><span class="line">		&#125;)</span><br><span class="line">		semrelease(&amp;worldsema)</span><br><span class="line">		<span class="keyword">goto</span> top</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 关闭 worker */</span></span><br><span class="line">	atomic.Store(&amp;gcBlackenEnabled, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 对于在 mallocgc 时，由于没有足够的 gc credit，导致休眠的 g，在这里全部唤醒 */</span></span><br><span class="line">	gcWakeAllAssists()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Likewise, release the transition lock. Blocked</span></span><br><span class="line">	<span class="comment">// workers and assists will run when we start the</span></span><br><span class="line">	<span class="comment">// world again.</span></span><br><span class="line">	semrelease(&amp;work.markDoneSema)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// In STW mode, re-enable user goroutines. These will be</span></span><br><span class="line">	<span class="comment">// queued to run after we start the world.</span></span><br><span class="line">	schedEnableUser(<span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// endCycle depends on all gcWork cache stats being flushed.</span></span><br><span class="line">	<span class="comment">// The termination algorithm above ensured that up to</span></span><br><span class="line">	<span class="comment">// allocations since the ragged barrier.</span></span><br><span class="line">	nextTriggerRatio := gcController.endCycle(work.userForced)</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 执行 mark termination，并进入清扫阶段，执行清扫 */</span></span><br><span class="line">	gcMarkTermination(nextTriggerRatio)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* mark termination 阶段，全部在 STW 下执行 */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcMarkTermination</span><span class="params">(nextTriggerRatio <span class="type">float64</span>)</span></span> &#123;</span><br><span class="line">	<span class="comment">/* 设置 phase，这时写屏障还未关闭 */</span></span><br><span class="line">	setGCPhase(_GCmarktermination)</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* debug 参数，heap0: gc 开始前的 heapLive， heap1: gc 标记期间的 heapLive，heap2: gc 标记完成后的 heapLive */</span></span><br><span class="line">	work.heap1 = gcController.heapLive</span><br><span class="line">	startTime := nanotime()</span><br><span class="line"></span><br><span class="line">	mp := acquirem()</span><br><span class="line">	mp.preemptoff = <span class="string">&quot;gcing&quot;</span></span><br><span class="line">	_g_ := getg()</span><br><span class="line">	_g_.m.traceback = <span class="number">2</span></span><br><span class="line">	gp := _g_.m.curg</span><br><span class="line">	casgstatus(gp, _Grunning, _Gwaiting)</span><br><span class="line">	gp.waitreason = waitReasonGarbageCollection</span><br><span class="line"></span><br><span class="line">	systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">/* 检查标记工作完成，并设置 gcController.heapMarked，gcController.heapScan，gcController.heapLive */</span></span><br><span class="line">		gcMark(startTime)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		work.heap2 = work.bytesMarked</span><br><span class="line">		... ...</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* mark termination 结束，设置 phase 到 _GCoff，并关闭写屏障 */</span></span><br><span class="line">		setGCPhase(_GCoff)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* unpark bgsweep 这时后台扫描已经开始（bgsweep 和 bgscavenge 都在 main 中的 gcenable() 被创建，随即 park ） */</span></span><br><span class="line">		gcSweep(work.mode)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 下面开始收尾工作 */</span></span><br><span class="line">	... ...</span><br><span class="line">  </span><br><span class="line">	gcController.lastHeapGoal = gcController.heapGoal</span><br><span class="line">	memstats.last_heap_inuse = memstats.heap_inuse</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 更新 trigger ratio */</span></span><br><span class="line">	gcController.commit(nextTriggerRatio)</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 省略记录统计信息与重置状态 */</span></span><br><span class="line">	... ...</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 取消 STW */</span></span><br><span class="line">	systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; startTheWorldWithSema(<span class="literal">true</span>) &#125;)</span><br><span class="line"></span><br><span class="line">	... ...</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 清理 stackpool 和 stackLarge 中不再使用的 span */</span></span><br><span class="line">	systemstack(freeStackSpans)</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 清空所有 mcache */</span></span><br><span class="line">	systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		forEachP(<span class="function"><span class="keyword">func</span><span class="params">(_p_ *p)</span></span> &#123;</span><br><span class="line">			_p_.mcache.prepareForSweep()</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="comment">// Now that we&#x27;ve swept stale spans in mcaches, they don&#x27;t</span></span><br><span class="line">	<span class="comment">// count against unswept spans.</span></span><br><span class="line">	sl.dispose()</span><br><span class="line"></span><br><span class="line">	... ...</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 释放资源 */</span></span><br><span class="line">	semrelease(&amp;worldsema)</span><br><span class="line">	semrelease(&amp;gcsema)</span><br><span class="line">	<span class="comment">// Careful: another GC cycle may start now.</span></span><br><span class="line"></span><br><span class="line">	releasem(mp)</span><br><span class="line">	mp = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// now that gc is done, kick off finalizer thread if needed</span></span><br><span class="line">	<span class="keyword">if</span> !concurrentSweep &#123;</span><br><span class="line">		<span class="comment">// give the queued finalizers, if any, a chance to run</span></span><br><span class="line">		Gosched()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 后台清理 */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bgsweep</span><span class="params">()</span></span> &#123;</span><br><span class="line">	sweep.g = getg()</span><br><span class="line"></span><br><span class="line">	lockInit(&amp;sweep.lock, lockRankSweep)</span><br><span class="line">	lock(&amp;sweep.lock)</span><br><span class="line">	sweep.parked = <span class="literal">true</span></span><br><span class="line">	gcenable_setup &lt;- <span class="number">1</span></span><br><span class="line">	goparkunlock(&amp;sweep.lock, waitReasonGCSweepWait, traceEvGoBlock, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="comment">/* 每次清理一个 span，之后就主动换出 */</span></span><br><span class="line">    <span class="keyword">for</span> sweepone() != ^<span class="type">uintptr</span>(<span class="number">0</span>) &#123;</span><br><span class="line">			sweep.nbgsweep++</span><br><span class="line">			Gosched()</span><br><span class="line">		&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* span 清理完成了，将 free 的 wbuf 也释放掉，之后主动换出 */</span></span><br><span class="line">		<span class="keyword">for</span> freeSomeWbufs(<span class="literal">true</span>) &#123;</span><br><span class="line">			Gosched()</span><br><span class="line">		&#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">		lock(&amp;sweep.lock)</span><br><span class="line">    <span class="comment">/* 由于是并发清理，有可能存在其他的清理需求，如果清理未结束，直接 continue */</span></span><br><span class="line">		<span class="keyword">if</span> !isSweepDone() &#123;</span><br><span class="line">			unlock(&amp;sweep.lock)</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 执行到这里说明彻底完成清理了，park 当前 goroutine，等待下一次唤醒 */</span></span><br><span class="line">		sweep.parked = <span class="literal">true</span></span><br><span class="line">		goparkunlock(&amp;sweep.lock, waitReasonGCSweepWait, traceEvGoBlock, <span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 清扫主逻辑，清扫一个 span */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sweepone</span><span class="params">()</span></span> <span class="type">uintptr</span> &#123;</span><br><span class="line">	_g_ := getg()</span><br><span class="line">	... ...</span><br><span class="line">	sl := newSweepLocker()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Find a span to sweep.</span></span><br><span class="line">	npages := ^<span class="type">uintptr</span>(<span class="number">0</span>)</span><br><span class="line">	<span class="keyword">var</span> noMoreWork <span class="type">bool</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="comment">/* 从 mcentral 的 full 或 partial 中交替取出一个 unswept span */</span></span><br><span class="line">		s := mheap_.nextSpanForSweep()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 取不出了说明 mcentral 中的 span 已经全部清扫完成 */</span></span><br><span class="line">		<span class="keyword">if</span> s == <span class="literal">nil</span> &#123;</span><br><span class="line">			noMoreWork = atomic.Cas(&amp;mheap_.sweepDrained, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		... ...</span><br><span class="line">    <span class="comment">/* 尝试获取当前 span 的清扫权（获取不到就尝试拿下一个 span），同时给 mheap_.sweepers + 1 */</span></span><br><span class="line">		<span class="keyword">if</span> s, ok := sl.tryAcquire(s); ok &#123;</span><br><span class="line">			<span class="comment">// Sweep the span we found.</span></span><br><span class="line">			npages = s.npages</span><br><span class="line">      <span class="comment">/* 执行实际的清扫逻辑，若返回 true，代表整个 span 都已经清空并归还给 heap */</span></span><br><span class="line">			<span class="keyword">if</span> s.sweep(<span class="literal">false</span>) &#123;</span><br><span class="line">				<span class="comment">// Whole span was freed. Count it toward the</span></span><br><span class="line">				<span class="comment">// page reclaimer credit since these pages can</span></span><br><span class="line">				<span class="comment">// now be used for span allocation.</span></span><br><span class="line">				atomic.Xadduintptr(&amp;mheap_.reclaimCredit, npages)</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">// Span is still in-use, so this returned no</span></span><br><span class="line">				<span class="comment">// pages to the heap and the span needs to</span></span><br><span class="line">				<span class="comment">// move to the swept in-use list.</span></span><br><span class="line">				npages = <span class="number">0</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	sl.dispose()</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 假如没有新的 span 需要清扫了，就启动 scavenger */</span></span><br><span class="line">	<span class="keyword">if</span> noMoreWork &#123;</span><br><span class="line">		systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			lock(&amp;mheap_.lock)</span><br><span class="line">      <span class="comment">/* 设置新的一轮 scavenge */</span></span><br><span class="line">			mheap_.pages.scavengeStartGen()</span><br><span class="line">			unlock(&amp;mheap_.lock)</span><br><span class="line">		&#125;)</span><br><span class="line">		<span class="comment">/* 设置 scavenge.sysmonWake，这样在 sysmon 下一次执行时就可以启动 scavenger */</span></span><br><span class="line">		readyForScavenger()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	_g_.m.locks--</span><br><span class="line">	<span class="keyword">return</span> npages</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 清扫 span，执行过程中应避免被强占 */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sl *sweepLocked)</span></span> sweep(preserve <span class="type">bool</span>) <span class="type">bool</span> &#123;</span><br><span class="line">  ... ...</span><br><span class="line">	s := sl.mspan</span><br><span class="line">	... ...</span><br><span class="line">	sweepgen := mheap_.sweepgen</span><br><span class="line">	... ...</span><br><span class="line">	atomic.Xadd64(&amp;mheap_.pagesSwept, <span class="type">int64</span>(s.npages))</span><br><span class="line"></span><br><span class="line">	spc := s.spanclass</span><br><span class="line">	size := s.elemsize</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 对需要清理，但绑定了 finalizer 的对象，先清理其 finalizer */</span></span><br><span class="line">	hadSpecials := s.specials != <span class="literal">nil</span></span><br><span class="line">	siter := newSpecialsIter(s)</span><br><span class="line">	<span class="keyword">for</span> siter.valid() &#123;</span><br><span class="line">		... ...</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> hadSpecials &amp;&amp; s.specials == <span class="literal">nil</span> &#123;</span><br><span class="line">		spanHasNoSpecials(s)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	... ...</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 被 gc 标记，但却没有 alloc 记录的位视为僵尸对象 */</span></span><br><span class="line">	<span class="keyword">if</span> s.freeindex &lt; s.nelems &#123;</span><br><span class="line">		<span class="comment">/* freeindex 边界处特殊处理 */</span></span><br><span class="line">		obj := s.freeindex</span><br><span class="line">		<span class="keyword">if</span> (*s.gcmarkBits.bytep(obj / <span class="number">8</span>)&amp;^*s.allocBits.bytep(obj / <span class="number">8</span>))&gt;&gt;(obj%<span class="number">8</span>) != <span class="number">0</span> &#123;</span><br><span class="line">			s.reportZombies()</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/* 处理 freeindex 之后的位 */</span></span><br><span class="line">		<span class="keyword">for</span> i := obj/<span class="number">8</span> + <span class="number">1</span>; i &lt; divRoundUp(s.nelems, <span class="number">8</span>); i++ &#123;</span><br><span class="line">			<span class="keyword">if</span> *s.gcmarkBits.bytep(i)&amp;^*s.allocBits.bytep(i) != <span class="number">0</span> &#123;</span><br><span class="line">				s.reportZombies()</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* nalloc 是根据 gc 标记得出的活跃对象 */</span></span><br><span class="line">	nalloc := <span class="type">uint16</span>(s.countAlloc())</span><br><span class="line">	nfreed := s.allocCount - nalloc</span><br><span class="line">	... ...</span><br><span class="line"></span><br><span class="line">	s.allocCount = nalloc</span><br><span class="line">	s.freeindex = <span class="number">0</span> <span class="comment">// reset allocation index to start of span.</span></span><br><span class="line">	... ...</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* gc 标记后的 bitmap 就变成了当前实际的 alloc bitmap，赋值过后清空 gcmarkBits */</span></span><br><span class="line">	s.allocBits = s.gcmarkBits</span><br><span class="line">	s.gcmarkBits = newMarkBits(s.nelems)</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 重置 allocCache */</span></span><br><span class="line">	s.refillAllocCache(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">	... ...</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 设置该 span 的 sweepgen 为最新值，代表已经清理完毕，可以使用了 */</span></span><br><span class="line">	atomic.Store(&amp;s.sweepgen, sweepgen)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> spc.sizeclass() != <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">/* 处理分配小对象的 span */</span></span><br><span class="line">		... ...</span><br><span class="line">		<span class="keyword">if</span> !preserve &#123;</span><br><span class="line">			<span class="comment">/* 若该 span 已经彻底清空，则将其释放掉 */</span></span><br><span class="line">			<span class="keyword">if</span> nalloc == <span class="number">0</span> &#123;</span><br><span class="line">				<span class="comment">// Free totally free span directly back to the heap.</span></span><br><span class="line">				mheap_.freeSpan(s)</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">/* 根据 span 是否已满，归还到 mcentral 的对应链表中 */</span></span><br><span class="line">			<span class="keyword">if</span> <span class="type">uintptr</span>(nalloc) == s.nelems &#123;</span><br><span class="line">				mheap_.central[spc].mcentral.fullSwept(sweepgen).push(s)</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				mheap_.central[spc].mcentral.partialSwept(sweepgen).push(s)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> !preserve &#123;</span><br><span class="line">		<span class="comment">/* 处理大对象 span */</span></span><br><span class="line">		<span class="keyword">if</span> nfreed != <span class="number">0</span> &#123;</span><br><span class="line">			... ...</span><br><span class="line">      <span class="comment">/* 直接释放 */</span></span><br><span class="line">			mheap_.freeSpan(s)</span><br><span class="line">			... ...</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 若不需要释放，则归还到 fullSwept */</span></span><br><span class="line">		mheap_.central[spc].mcentral.fullSwept(sweepgen).push(s)</span><br><span class="line">	&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* false 代表 span 未归还 */</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* scavenger 在后台定期维护总 RSS 不超限 */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bgscavenge</span><span class="params">()</span></span> &#123;</span><br><span class="line">	scavenge.g = getg()</span><br><span class="line"></span><br><span class="line">	lockInit(&amp;scavenge.lock, lockRankScavenge)</span><br><span class="line">	lock(&amp;scavenge.lock)</span><br><span class="line">  <span class="comment">/* 启动后默认 park */</span></span><br><span class="line">	scavenge.parked = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">	scavenge.timer = <span class="built_in">new</span>(timer)</span><br><span class="line">  <span class="comment">/* timer callback 设置为唤醒 scavenger */</span></span><br><span class="line">	scavenge.timer.f = <span class="function"><span class="keyword">func</span><span class="params">(_ <span class="keyword">interface</span>&#123;&#125;, _ <span class="type">uintptr</span>)</span></span> &#123;</span><br><span class="line">		wakeScavenger()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	gcenable_setup &lt;- <span class="number">1</span></span><br><span class="line">  <span class="comment">/* 进入 park 休眠 */</span></span><br><span class="line">	goparkunlock(&amp;scavenge.lock, waitReasonGCScavengeWait, traceEvGoBlock, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* scavengeEWMA 用于设置下一次启动的时间 */</span></span><br><span class="line">	<span class="keyword">const</span> idealFraction = scavengePercent / <span class="number">100.0</span></span><br><span class="line">	scavengeEWMA := <span class="type">float64</span>(idealFraction)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		released := <span class="type">uintptr</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Time in scavenging critical section.</span></span><br><span class="line">		crit := <span class="type">float64</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Run on the system stack since we grab the heap lock,</span></span><br><span class="line">		<span class="comment">// and a stack growth with the heap lock means a deadlock.</span></span><br><span class="line">		systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			lock(&amp;mheap_.lock)</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* 如果当下的 RSS 比 scavengeGoal 要小，则不需要做 scavenge */</span></span><br><span class="line">			retained, goal := heapRetained(), mheap_.scavengeGoal</span><br><span class="line">			<span class="keyword">if</span> retained &lt;= goal &#123;</span><br><span class="line">				unlock(&amp;mheap_.lock)</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* 否则先 scavenge 一页，记录耗费的时间 */</span></span><br><span class="line">			start := nanotime()</span><br><span class="line">			released = mheap_.pages.scavenge(physPageSize, <span class="literal">true</span>)</span><br><span class="line">			mheap_.pages.scav.released += released</span><br><span class="line">			crit = <span class="type">float64</span>(nanotime() - start)</span><br><span class="line"></span><br><span class="line">			unlock(&amp;mheap_.lock)</span><br><span class="line">		&#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* released == 0 代表不需要操作，因此继续进入 park */</span></span><br><span class="line">		<span class="keyword">if</span> released == <span class="number">0</span> &#123;</span><br><span class="line">			lock(&amp;scavenge.lock)</span><br><span class="line">			scavenge.parked = <span class="literal">true</span></span><br><span class="line">			goparkunlock(&amp;scavenge.lock, waitReasonGCScavengeWait, traceEvGoBlock, <span class="number">1</span>)</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 省略对 crit 的调整 */</span></span><br><span class="line">    ... ...</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 休眠时间的计算是假设 scavenger 所占用的 cpu 时间是总 cpu 时间的百分之 scavengePercent，叠加一些调整 */</span></span><br><span class="line">		adjust := scavengeEWMA / idealFraction</span><br><span class="line">		sleepTime := <span class="type">int64</span>(adjust * crit / (scavengePercent / <span class="number">100.0</span>))</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Go to sleep.</span></span><br><span class="line">		slept := scavengeSleep(sleepTime)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Compute the new ratio.</span></span><br><span class="line">		fraction := crit / (crit + <span class="type">float64</span>(slept))</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Set a lower bound on the fraction.</span></span><br><span class="line">		<span class="keyword">const</span> minFraction = <span class="number">1.0</span> / <span class="number">1000.0</span></span><br><span class="line">		<span class="keyword">if</span> fraction &lt; minFraction &#123;</span><br><span class="line">			fraction = minFraction</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Update scavengeEWMA by merging in the new crit/slept ratio.</span></span><br><span class="line">		<span class="keyword">const</span> alpha = <span class="number">0.5</span></span><br><span class="line">		scavengeEWMA = alpha*fraction + (<span class="number">1</span>-alpha)*scavengeEWMA</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* scavenge nbytes 空间 */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *pageAlloc)</span></span> scavenge(nbytes <span class="type">uintptr</span>, mayUnlock <span class="type">bool</span>) <span class="type">uintptr</span> &#123;</span><br><span class="line">	assertLockHeld(p.mheapLock)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> (</span><br><span class="line">		addrs addrRange</span><br><span class="line">		gen   <span class="type">uint32</span></span><br><span class="line">	)</span><br><span class="line">	released := <span class="type">uintptr</span>(<span class="number">0</span>)</span><br><span class="line">	<span class="keyword">for</span> released &lt; nbytes &#123;</span><br><span class="line">		<span class="keyword">if</span> addrs.size() == <span class="number">0</span> &#123;</span><br><span class="line">      <span class="comment">/* 预留一块地址空间用于做 scavenge */</span></span><br><span class="line">			<span class="keyword">if</span> addrs, gen = p.scavengeReserve(); addrs.size() == <span class="number">0</span> &#123;</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 在预留的地址空间内找到一块连续的 nbytes-released 长度的内存，将其 scavenge，并返回剩余未扫描的区间 */</span></span><br><span class="line">		r, a := p.scavengeOne(addrs, nbytes-released, mayUnlock)</span><br><span class="line">		released += r</span><br><span class="line">		addrs = a</span><br><span class="line">	&#125;</span><br><span class="line">  </span><br><span class="line">	<span class="comment">/* 将最后一部分未扫描区间加回 p.scav.inUse */</span></span><br><span class="line">	p.scavengeUnreserve(addrs, gen)</span><br><span class="line">	<span class="keyword">return</span> released</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 清空最多 max bytes 的内存，返还给 os */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *pageAlloc)</span></span> scavengeOne(work addrRange, max <span class="type">uintptr</span>, mayUnlock <span class="type">bool</span>) (<span class="type">uintptr</span>, addrRange) &#123;</span><br><span class="line">	... ...</span><br><span class="line">	<span class="comment">/* 将 max bytes 转换为最多清空页数 */</span></span><br><span class="line">	maxPages := max / pageSize</span><br><span class="line">	<span class="keyword">if</span> max%pageSize != <span class="number">0</span> &#123;</span><br><span class="line">		maxPages++</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 最少清空页数 */</span></span><br><span class="line">	minPages := physPageSize / pageSize</span><br><span class="line">	<span class="keyword">if</span> minPages &lt; <span class="number">1</span> &#123;</span><br><span class="line">		minPages = <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	... ...</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* fast path: 先从最高地址处尝试搜索是否存在至少大于 minPages 的可清理空间，若有直接清理后返回 */</span></span><br><span class="line">	maxAddr := work.limit.addr() - <span class="number">1</span></span><br><span class="line">	maxChunk := chunkIndex(maxAddr)</span><br><span class="line">	<span class="keyword">if</span> p.summary[<span class="built_in">len</span>(p.summary)<span class="number">-1</span>][maxChunk].max() &gt;= <span class="type">uint</span>(minPages) &#123;</span><br><span class="line">		<span class="comment">/* 查找 maxChunk 中是否存在最少 minPages 的空闲且 unscavenge 的空间 */</span></span><br><span class="line">		base, npages := p.chunkOf(maxChunk).findScavengeCandidate(chunkPageIndex(maxAddr), minPages, maxPages)</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 找到了就将其清理掉，结束 */</span></span><br><span class="line">		<span class="keyword">if</span> npages != <span class="number">0</span> &#123;</span><br><span class="line">			work.limit = offAddr&#123;p.scavengeRangeLocked(maxChunk, base, npages)&#125;</span><br><span class="line"></span><br><span class="line">			assertLockHeld(p.mheapLock) <span class="comment">// Must be locked on return.</span></span><br><span class="line">			<span class="keyword">return</span> <span class="type">uintptr</span>(npages) * pageSize, work</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* 否则把刚刚扫描的 maxAddr 剔除出地址空间 */</span></span><br><span class="line">	work.limit = offAddr&#123;chunkBase(maxChunk)&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 从最高地址开始向下寻找可用于清理的 chunk */</span></span><br><span class="line">	findCandidate := <span class="function"><span class="keyword">func</span><span class="params">(work addrRange)</span></span> (chunkIdx, <span class="type">bool</span>) &#123;</span><br><span class="line">		<span class="keyword">for</span> i := chunkIndex(work.limit.addr() - <span class="number">1</span>); i &gt;= chunkIndex(work.base.addr()); i-- &#123;</span><br><span class="line">			<span class="comment">/* 空间不足的直接跳过 */</span></span><br><span class="line">			<span class="keyword">if</span> p.summary[<span class="built_in">len</span>(p.summary)<span class="number">-1</span>][i].max() &lt; <span class="type">uint</span>(minPages) &#123;</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* 检查是否包含至少 minPages 可清理空间 */</span></span><br><span class="line">			l2 := (*[<span class="number">1</span> &lt;&lt; pallocChunksL2Bits]pallocData)(atomic.Loadp(unsafe.Pointer(&amp;p.chunks[i.l1()])))</span><br><span class="line">			<span class="keyword">if</span> l2 != <span class="literal">nil</span> &amp;&amp; l2[i.l2()].hasScavengeCandidate(minPages) &#123;</span><br><span class="line">				<span class="keyword">return</span> i, <span class="literal">true</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>, <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Slow path: 迭代整个 work range，逐步寻找，由于放开了 heap lock，</span></span><br><span class="line"><span class="comment">   * 因此 findCandidate 是以乐观的形式返回结果，不保证实际清扫时空间仍然足够 </span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">	<span class="keyword">for</span> work.size() != <span class="number">0</span> &#123;</span><br><span class="line">		unlockHeap()</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Search for the candidate.</span></span><br><span class="line">		candidateChunkIdx, ok := findCandidate(work)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Lock the heap. We need to do this now if we found a candidate or not.</span></span><br><span class="line">		<span class="comment">// If we did, we&#x27;ll verify it. If not, we need to lock before returning</span></span><br><span class="line">		<span class="comment">// anyway.</span></span><br><span class="line">		lockHeap()</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> !ok &#123;</span><br><span class="line">			<span class="comment">/* 整个地址空间都没找到，直接退出 */</span></span><br><span class="line">			work.limit = work.base</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 尝试清扫 */</span></span><br><span class="line">		chunk := p.chunkOf(candidateChunkIdx)</span><br><span class="line">		base, npages := chunk.findScavengeCandidate(pallocChunkPages<span class="number">-1</span>, minPages, maxPages)</span><br><span class="line">		<span class="keyword">if</span> npages &gt; <span class="number">0</span> &#123;</span><br><span class="line">			work.limit = offAddr&#123;p.scavengeRangeLocked(candidateChunkIdx, base, npages)&#125;</span><br><span class="line"></span><br><span class="line">			assertLockHeld(p.mheapLock) <span class="comment">// Must be locked on return.</span></span><br><span class="line">			<span class="keyword">return</span> <span class="type">uintptr</span>(npages) * pageSize, work</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* 清扫失败，被骗了，重来一次 */</span></span><br><span class="line">		work.limit = offAddr&#123;chunkBase(candidateChunkIdx)&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	assertLockHeld(p.mheapLock) <span class="comment">// Must be locked on return.</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>, work</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* os空间释放 */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *pageAlloc)</span></span> scavengeRangeLocked(ci chunkIdx, base, npages <span class="type">uint</span>) <span class="type">uintptr</span> &#123;</span><br><span class="line">	assertLockHeld(p.mheapLock)</span><br><span class="line"></span><br><span class="line">	p.chunkOf(ci).scavenged.setRange(base, npages)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Compute the full address for the start of the range.</span></span><br><span class="line">	addr := chunkBase(ci) + <span class="type">uintptr</span>(base)*pageSize</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Update the scavenge low watermark.</span></span><br><span class="line">	<span class="keyword">if</span> oAddr := (offAddr&#123;addr&#125;); oAddr.lessThan(p.scav.scavLWM) &#123;</span><br><span class="line">		p.scav.scavLWM = oAddr</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Only perform the actual scavenging if we&#x27;re not in a test.</span></span><br><span class="line">	<span class="comment">// It&#x27;s dangerous to do so otherwise.</span></span><br><span class="line">	<span class="keyword">if</span> p.test &#123;</span><br><span class="line">		<span class="keyword">return</span> addr</span><br><span class="line">	&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 核心逻辑就是调用 sysUnused 归还 npages 的 os 内存 */</span></span><br><span class="line">	sysUnused(unsafe.Pointer(addr), <span class="type">uintptr</span>(npages)*pageSize)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Update global accounting only when not in test, otherwise</span></span><br><span class="line">	<span class="comment">// the runtime&#x27;s accounting will be wrong.</span></span><br><span class="line">	nbytes := <span class="type">int64</span>(npages) * pageSize</span><br><span class="line">	atomic.Xadd64(&amp;memstats.heap_released, nbytes)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Update consistent accounting too.</span></span><br><span class="line">	stats := memstats.heapStats.acquire()</span><br><span class="line">	atomic.Xaddint64(&amp;stats.committed, -nbytes)</span><br><span class="line">	atomic.Xaddint64(&amp;stats.released, nbytes)</span><br><span class="line">	memstats.heapStats.release()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> addr</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="抢占">6. 抢占</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 前文的启动流程中，我们可知，sysmon 独占一个 m，专门执行一些与定时相关的后台任务，</span></span><br><span class="line"><span class="comment"> * 包括检查 netpoll，定时启动 scavenger，抢占等等</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sysmon</span><span class="params">()</span></span> &#123;</span><br><span class="line">	... ...</span><br><span class="line">  <span class="comment">/* 每轮执行都执行 retake 尝试抢占 */</span></span><br><span class="line">  <span class="keyword">if</span> retake(now) != <span class="number">0</span> &#123;</span><br><span class="line">    idle = <span class="number">0</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    idle++</span><br><span class="line">  &#125;</span><br><span class="line">	... ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">retake</span><span class="params">(now <span class="type">int64</span>)</span></span> <span class="type">uint32</span> &#123;</span><br><span class="line">	n := <span class="number">0</span></span><br><span class="line">	<span class="comment">/* allp 上锁防止被修改（比如 GOMAXPROCS） */</span></span><br><span class="line">	lock(&amp;allpLock)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(allp); i++ &#123;</span><br><span class="line">		_p_ := allp[i]</span><br><span class="line">		<span class="keyword">if</span> _p_ == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="comment">// This can happen if procresize has grown</span></span><br><span class="line">			<span class="comment">// allp but not yet created new Ps.</span></span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		pd := &amp;_p_.sysmontick</span><br><span class="line">		s := _p_.status</span><br><span class="line">		sysretake := <span class="literal">false</span></span><br><span class="line">		<span class="keyword">if</span> s == _Prunning || s == _Psyscall &#123;</span><br><span class="line">			<span class="comment">// Preempt G if it&#x27;s running for too long.</span></span><br><span class="line">			t := <span class="type">int64</span>(_p_.schedtick)</span><br><span class="line">			<span class="keyword">if</span> <span class="type">int64</span>(pd.schedtick) != t &#123;</span><br><span class="line">				pd.schedtick = <span class="type">uint32</span>(t)</span><br><span class="line">				pd.schedwhen = now</span><br><span class="line">      <span class="comment">/* 假如上一次被调度的时间距离当下已经超过 forcePreemptNS（10ms），就强制在该 p 上实施抢占 */</span>  </span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> pd.schedwhen+forcePreemptNS &lt;= now &#123;</span><br><span class="line">				preemptone(_p_)</span><br><span class="line">				<span class="comment">// In case of syscall, preemptone() doesn&#x27;t</span></span><br><span class="line">				<span class="comment">// work, because there is no M wired to P.</span></span><br><span class="line">				sysretake = <span class="literal">true</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> s == _Psyscall &#123;</span><br><span class="line">			<span class="comment">/* 如果没有被抢占且 syscalltick 未更新（说明期间执行过 syscall），更新 syscalltick 并结束 */</span></span><br><span class="line">			t := <span class="type">int64</span>(_p_.syscalltick)</span><br><span class="line">			<span class="keyword">if</span> !sysretake &amp;&amp; <span class="type">int64</span>(pd.syscalltick) != t &#123;</span><br><span class="line">				pd.syscalltick = <span class="type">uint32</span>(t)</span><br><span class="line">				pd.syscallwhen = now</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">/* 只有当 p 没有工作，又存在自旋的 m 和空闲的 p，同时距离上一次 syscall 超过 10ms 后，才不对 p 做处理*/</span></span><br><span class="line">			<span class="keyword">if</span> runqempty(_p_) &amp;&amp; atomic.Load(&amp;sched.nmspinning)+atomic.Load(&amp;sched.npidle) &gt; <span class="number">0</span> &amp;&amp; pd.syscallwhen+<span class="number">10</span>*<span class="number">1000</span>*<span class="number">1000</span> &gt; now &#123;</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// Drop allpLock so we can take sched.lock.</span></span><br><span class="line">			unlock(&amp;allpLock)</span><br><span class="line">			<span class="comment">// Need to decrement number of idle locked M&#x27;s</span></span><br><span class="line">			<span class="comment">// (pretending that one more is running) before the CAS.</span></span><br><span class="line">			<span class="comment">// Otherwise the M from which we retake can exit the syscall,</span></span><br><span class="line">			<span class="comment">// increment nmidle and report deadlock.</span></span><br><span class="line">			incidlelocked(<span class="number">-1</span>)</span><br><span class="line">			<span class="keyword">if</span> atomic.Cas(&amp;_p_.status, s, _Pidle) &#123;</span><br><span class="line">				<span class="keyword">if</span> trace.enabled &#123;</span><br><span class="line">					traceGoSysBlock(_p_)</span><br><span class="line">					traceProcStop(_p_)</span><br><span class="line">				&#125;</span><br><span class="line">				n++</span><br><span class="line">				_p_.syscalltick++</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* 把 p 换出交给其他 m 执行 */</span></span><br><span class="line">				handoffp(_p_)</span><br><span class="line">			&#125;</span><br><span class="line">			incidlelocked(<span class="number">1</span>)</span><br><span class="line">			lock(&amp;allpLock)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	unlock(&amp;allpLock)</span><br><span class="line">	<span class="keyword">return</span> <span class="type">uint32</span>(n)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">preemptone</span><span class="params">(_p_ *p)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">	mp := _p_.m.ptr()</span><br><span class="line">	<span class="keyword">if</span> mp == <span class="literal">nil</span> || mp == getg().m &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	gp := mp.curg</span><br><span class="line">	<span class="keyword">if</span> gp == <span class="literal">nil</span> || gp == mp.g0 &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 设置当前 g 被抢占 */</span></span><br><span class="line">	gp.preempt = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 把抢占检测放到每一次 g 检查栈扩容时 */</span></span><br><span class="line">	gp.stackguard0 = stackPreempt</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Request an async preemption of this P.</span></span><br><span class="line">	<span class="keyword">if</span> preemptMSupported &amp;&amp; debug.asyncpreemptoff == <span class="number">0</span> &#123;</span><br><span class="line">		_p_.preempt = <span class="literal">true</span></span><br><span class="line">		preemptM(mp)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 发出抢占信号 */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">preemptM</span><span class="params">(mp *m)</span></span> &#123;</span><br><span class="line">  ... ...</span><br><span class="line">	signalM(mp, sigPreempt)</span><br><span class="line">  ... ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 处理抢占信号 */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doSigPreempt</span><span class="params">(gp *g, ctxt *sigctxt)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> wantAsyncPreempt(gp) &#123;</span><br><span class="line">		<span class="keyword">if</span> ok, newpc := isAsyncSafePoint(gp, ctxt.sigpc(), ctxt.sigsp(), ctxt.siglr()); ok &#123;</span><br><span class="line">      <span class="comment">/* asyncPreempt 在汇编代码实现，除了保存寄存器状态外，实际上在汇编中调用了 asyncPreempt2() */</span></span><br><span class="line">			ctxt.pushCall(funcPC(asyncPreempt), newpc)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">  ... ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 普通的抢占调用 gopreempt_m */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">asyncPreempt2</span><span class="params">()</span></span> &#123;</span><br><span class="line">	gp := getg()</span><br><span class="line">	gp.asyncSafePoint = <span class="literal">true</span></span><br><span class="line">	<span class="keyword">if</span> gp.preemptStop &#123;</span><br><span class="line">		mcall(preemptPark)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		mcall(gopreempt_m)</span><br><span class="line">	&#125;</span><br><span class="line">	gp.asyncSafePoint = <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gopreempt_m</span><span class="params">(gp *g)</span></span> &#123;</span><br><span class="line">  ... ...</span><br><span class="line">	goschedImpl(gp)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 相当于调用了 runtime.Gosched() */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">goschedImpl</span><span class="params">(gp *g)</span></span> &#123;</span><br><span class="line">	... ...</span><br><span class="line">  <span class="comment">/* 改状态，加入全局队列，并调用 schedule() */</span></span><br><span class="line">	casgstatus(gp, _Grunning, _Grunnable)</span><br><span class="line">	dropg()</span><br><span class="line">	lock(&amp;sched.lock)</span><br><span class="line">	globrunqput(gp)</span><br><span class="line">	unlock(&amp;sched.lock)</span><br><span class="line"></span><br><span class="line">	schedule()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 栈扩容时，当 gp.stackguard0 == stackPreempt，响应抢占 */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newstack</span><span class="params">()</span></span> &#123;</span><br><span class="line">  ... ...</span><br><span class="line">  <span class="keyword">if</span> preempt &#123;</span><br><span class="line">		... ...</span><br><span class="line">    <span class="comment">/* 仍旧是调用了 gopreempt_m */</span></span><br><span class="line">		gopreempt_m(gp) <span class="comment">// never return</span></span><br><span class="line">	&#125;</span><br><span class="line">  ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>

    
    
    

    <footer class="post-footer">
          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>Post author:  </strong>Lenshood
  </li>
  <li class="post-copyright-link">
      <strong>Post link: </strong>
      <a href="http://lenshood.github.io/2022/02/07/golang-boot/" title="Go Runtime 代码随笔">http://lenshood.github.io/2022/02/07/golang-boot/</a>
  </li>
  <li class="post-copyright-license">
      <strong>Copyright Notice:  </strong>All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> unless stating additionally.
  </li>
</ul>
</div>

          <div class="followme">
  <span>Welcome to my other publishing channels</span>

  <div class="social-list">

      <div class="social-item">
          <a target="_blank" class="social-link" href="/atom.xml">
            <span class="icon">
              <i class="fa fa-rss"></i>
            </span>

            <span class="label">RSS</span>
          </a>
      </div>
  </div>
</div>

          <div class="post-tags">
              <a href="/tags/source/" rel="tag"># source</a>
              <a href="/tags/go/" rel="tag"># go</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2022/01/01/2021-summary/" rel="prev" title="Summary of 2021">
                  <i class="fa fa-angle-left"></i> Summary of 2021
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2022/03/09/go-runtime-compute/" rel="next" title="Go Runtime 设计：计算资源调度">
                  Go Runtime 设计：计算资源调度 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments utterances-container"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Lenshood</span>
  </div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>
<script class="next-config" data-name="utterances" type="application/json">{"enable":true,"repo":"LENSHOOD/lenshood.github.io","issue_term":"pathname","theme":"github-light"}</script>
<script src="/js/third-party/comments/utterances.js" defer></script>

</body>
</html>
